<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>TCP |  Fanfan</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="Fanfan" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-计算机网络/TCP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  TCP
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/" class="article-date">
  <time datetime="2021-09-10T05:50:16.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">27 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><em>TCP</em></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
 <span id="more"></span>

<h3 id="TCP-如何保证可靠传输"><a href="#TCP-如何保证可靠传输" class="headerlink" title="TCP 如何保证可靠传输"></a>TCP 如何保证可靠传输</h3><p><em><strong>*TCP如何保证数据的完整性*</strong>***</em>*？*****包编号；校验和</p>
<p>应用数据被分割成 TCP 认为最适合发送的数据块。</p>
<p>\1. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传给应用层</p>
<p>\2. 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
<p>\3. TCP 的接收端会丢弃重复的数据</p>
<p>\4. 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段</p>
<p>\5. 流量控制：利用滑动窗口实现</p>
<p>\6. 停止等待ARQ和连续ARQ协议：确认和超时</p>
<p>\7. 拥塞控制</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 利用滑动窗口实现流量控制。</p>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p>TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p>
<h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议*"></a>ARQ 协议*</h3><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是数据链路层和传输层的错误纠正协议之一。它通过使用****确认*<em><strong>和</strong></em>*超时****这两个机制。</p>
<p>目的：在不可靠服务的基础上实现可靠的信息传输。</p>
<p>如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<p><em><strong>*停止等待*</strong>***</em>*ARQ协议****</p>
<p>基本原理：每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p>优点： 简单</p>
<p>缺点： 信道利用率低，等待时间长</p>
<p>运行机制：</p>
<p>\1. 无差错情况:发送方发送分组,接收方在规定时间内收到并回复确认.发送方发送新的分组。</p>
<p>\2. 出现差错情况（超时重传）:只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。</p>
<p>\3. 确认丢失：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</p>
<p>\4. 确认迟到：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</p>
<p><em><strong>*连续*</strong>***</em>*ARQ协议****</p>
<p>目的：提高信道利用率。</p>
<p>基本原理：发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</p>
<p>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传</p>
<p>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制***"></a>拥塞控制***</h3><p>拥塞定义：网络中的数据太多，导致某个路由器处理不过来或处理地太慢。</p>
<p>具体： 当发送的数据到达网络中的一个节点时（假设是路由器），它会根据数据包含的地址进行转发。但这些节点需要先将接收到的数据放入自己的内存（可能还要做一些处理），再从中取出进行转发。但路由器的内存是有限的，若同一时间到达某个路由器的数据太多，这个路由器将无法接收所有的数据，只能将一部分丢弃；或者要等待较长的时间才会被转发。</p>
<p>拥塞控制定义：在网络中发生拥塞时，减少向网络中发送数据的速度，防止造成恶性循环；同时在网络空闲时，提高发送数据的速度，最大限度地利用网络资源。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。</p>
<p>TCP的拥塞控制使用四种算法：</p>
<ol>
<li><p><strong>慢开始和拥塞避免</strong></p>
<p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p>
<p>慢开始算法：由小到大、乘法增长，逐渐增加拥塞窗口的大小。即1,2,4,8…目的：不要一开始就发送大量的数据，先探测一下网络的拥塞程度</p>
<p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh：</p>
<p>当cwnd&lt;ssthresh时，使用慢开始算法。</p>
<p>当cwnd&gt;ssthresh时，改用拥塞避免算法。</p>
<p>当cwnd=ssthresh时，慢开始与拥塞避免算法任意。</p>
<p>拥塞避免算法让拥塞窗口缓慢增长，拥塞窗口cwnd加1，而不是加倍。</p>
<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（没有收到确认、分组丢失），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。</p>
</li>
<li><p>快重传和快恢复</p>
<p>目的：快速恢复丢失的数据包</p>
<p>快重传：接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p>快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半。发送方将cwnd设置为ssthresh的大小，然后执行拥塞避免算法，加法增大。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞，所以不用慢开始。</p>
</li>
</ol>
<h3 id="TCP最大连接数"><a href="#TCP最大连接数" class="headerlink" title="TCP最大连接数*"></a>TCP最大连接数*</h3><p>client：内核开放了50000个端口可以供TCP连接使用，最大理论范围是0-65535。</p>
<p>client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大tcp连接数为65535。</p>
<p>用命令查看：</p>
<p>$ sysctl -a | grep ip_local_port_range</p>
<p>net.ipv4.ip_local_port_range = 15000   65000</p>
<p>当Linux作为客户端建立连接的时候，最大连接数量是受内核参数</p>
<p>net.ipv4.ip_local_port_range限制，而ip_local_port_range是可配置的，最大理论范围是0-65535。</p>
<p>对于有一个IP的客户端来说，受限于ip_local_port_range参数，也受限于65535。但单Linux可以配置多个ip，有几个ip，最大理论值就翻几倍。</p>
<p>server：</p>
<p>server通常固定在某个本地端口上监听，等待client的连接请求，本地监听端口是独占的。</p>
<p>一条TCP连接是由一个四元组组成的。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，对于我们这台Nginx Server来说，它的IP和端口是固定的。4元组中只有client ip和client port是可变的。因此最大的连接数是2的32次方（ip数）×2的16次方（port数）。</p>
<p>Linux上除了监听80以外，还可以监听其它的端口，例如Mysql的3306, Redis的6339，当然所有65535个端口你都可以用来监听一遍。这样理论上线就到了2的32次方（ip数）×2的16次方（port数）×2的16次方（服务器port数）个。</p>
<p>一条TCP连接如果不发送数据的话，消耗内存是3.3K左右。假设你只保持连接不发送数据，那么你服务器可以建立的连接最大数量 = 你的内存/3.3K。假如是4GB的内存，那么大约可接受的TCP连接数量是100万左右。</p>
<p>总结：</p>
<p>TCP连接的客户端机：每一个ip可建立的TCP连接理论受限于ip_local_port_range参数，也受限于65535。但可以通过配置多ip的方式来加大自己的建立连接的能力。</p>
<p>TCP连接的服务器机：每一个监听的端口虽然理论值很大，但这个数字没有实际意义。最大并发数取决你的内存大小，每一条静止状态的TCP连接大约需要吃3</p>
<p>.3K的内存。</p>
<h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式*"></a>TCP报文格式*</h3><p>固定首部长度为20字节,可变部分0~40字节</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps43.png" alt="img"> </p>
<p>\1. 源端口，16bits，范围0~65525。</p>
<p>\2. 目的端口，16bits，范围同上。</p>
<p>\3. sequence number： 数据序号，32bits，TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</p>
<p>\4. acknoledgement number： 确认号，32bits，期望收到对方的下一个报文段的数据的第一个字节的序号。</p>
<p>\5. 数据偏移，4bits，单位为4字节，它指出报文数据距TCP报头的起始处有多远(TCP报文头长度)。</p>
<p>\6. 保留字段 6bits，保留今后使用，目前置0处理。</p>
<p>\7. URG：紧急比特，1bit，当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</p>
<p>\8. ACK：确认比特，1bit，只有当 ACK=1时确认号字段才有效。当 ACK=0 时，确认号无效</p>
<p>\9. PSH：推送比特，1bit，接收方 TCP 收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付</p>
<p>\10. RST：复位比特，1bit，当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接</p>
<p>\11. SYN：同步比特，1bit，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文</p>
<p>\12. FIN：终止比特，1bit，用来释放一个连接。当FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</p>
<p>\13. 窗口大小，16bits，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</p>
<p>\14. 检验和，16bits，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p>
<p>\15. 紧急指针字段，16bits，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。</p>
<p>\16. 选项字段，长度可变，这部分最多包含40字节。TCP首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。，因为TCP头部最长是60字节</p>
<ol>
<li><p>选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。</p>
</li>
<li><p>第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。</p>
</li>
<li><p>第三个字段info（如果有的话）是选项的具体信息. kind=0是选项表结束选项kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍kind=2是最大报文段长度选项</p>
</li>
</ol>
<p>TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。</p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps39.jpg" alt="img"> </p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) ：建立连接</p>
<p>ACK：表示响应，告诉对方你发的信息我收到了</p>
<ol>
<li><p>主机A：发送syn=1，随机产生seq number=x的数据包 -&gt; 主机B，收到syn=1，知道A要建立连接（B确认了自己接收正常，对方发送正常）</p>
</li>
<li><p>主机B：确认连接信息，向A发送ack=1，ack number=x+1，syn=1，随机产生seq=y的数据包 -&gt; 主机A（A确认了自己发送、接收正常，对方发送、接收正常）</p>
</li>
<li><p>主机A：检查ack number是否正确，发送ack number=y+1，ack=1 -&gt; 主机B（B确认了自己发送正常，对方接收正常）</p>
</li>
</ol>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手*"></a>为什么要三次握手*</h3><p>三次握手的目的是建立可靠的通信信道，即双方确认自己与对方的发送与接收是正常的。</p>
<p>A和B进行三次握手：A先向B发送</p>
<ol>
<li><p>B确认了对方发送正常，自己接收正常</p>
</li>
<li><p>A确认了自己发送、接收正常，对方发送、接收正常</p>
</li>
<li><p>B确认了：自己发送正常，对方接收正常</p>
</li>
</ol>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p>“三次握手”的目的：“为了防止****已失效的连接请求报文段****突然又传送到了服务端，因而产生错误”</p>
<p>为了解决“网络中存在延迟的重复分组”的问题</p>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<p><em><strong>*为什么是三次，不是四次？*</strong></em></p>
<p>这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的.</p>
<h3 id="第2次握手传回了ACK，为什么还要传回SYN"><a href="#第2次握手传回了ACK，为什么还要传回SYN" class="headerlink" title="第2次握手传回了ACK，为什么还要传回SYN"></a>第2次握手传回了ACK，为什么还要传回SYN</h3><p>SYN 同步序列编号(Synchronize Sequence Numbers) ：建立连接</p>
<p>ACK：表示响应，告诉对方你发的信息我收到了</p>
<p>B给A所发送的ACK是为了告诉A，我接收到的信息确实就是你所发送的信号了，这表明从A到B的通信是正常的。而回传SYN则是为了建立从B到A的通信。</p>
<h3 id="如果第一次、第二次失败"><a href="#如果第一次、第二次失败" class="headerlink" title="如果第一次、第二次失败*"></a>如果第一次、第二次失败*</h3><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps40.jpg" alt="img"> </p>
<p>第一次失败（client向server发送SYN失败）：</p>
<p>两端都不会申请资源。如果一段时间后之前的SYN发送成功了，这时客户端只会接收他最后发送的SYN的SYN+ACK回应，其他的一概忽略，服务端也是如此，会将之前多申请的资源释放了。</p>
<p>第二次握手失败（server向client发送SYN+ACK失败）：</p>
<p>client由于没有收到这条响应，不会申请资源，虽然服务端申请了资源，但是迟迟收不到来自客户端的ACK，也会将该资源释放。</p>
<p>第三次握手失败（client向server发送ACK失败）：</p>
<p>server迟迟没有收到ACK，就会释放资源</p>
<p>但client认为自己已经连接好了，就会给server发送数据</p>
<p>server由于没有收到第三次握手，就会以RST包对客户端响应，重新建立链接</p>
<p>另外，server会因为没有收到客户端的ACK多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到客户端的ACK，则释放资源。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps41.jpg" alt="img"> </p>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>A 主动关闭         B被动关闭</p>
<ol>
<li><p>主机A：发送fin=1, seq=x 报文，用来关闭A到B的数据传送 -&gt; 主机B</p>
</li>
<li><p>主机B：发送 ack=1, seq=x+1 报文，确认收到关闭连接的信息 -&gt; 主机A</p>
</li>
<li><p>主机B：发送 fin=1, seq=y 报文，用来关闭B到A的数据传送 -&gt; 主机A</p>
</li>
<li><p>主机A：发送 ack=1, seq=y+1 报文，确认收到关闭连接的信息 -&gt; 主机B</p>
</li>
</ol>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps42.png" alt="img"> </p>
<h3 id="为什么三次握手，而关闭却是四次"><a href="#为什么三次握手，而关闭却是四次" class="headerlink" title="为什么三次握手，而关闭却是四次*"></a>为什么三次握手，而关闭却是四次*</h3><p>这是因为服务端收到SYN报文的连接请求后，它可以把ACK和SYN放在一个报文里来发送。</p>
<p>关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭。可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了。</p>
<p>所以关闭时ACK报文和FIN报文多数情况下都是分开发送的。</p>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT*"></a>TIME_WAIT*</h3><p>A主动关闭连接结束后，收到来自B的FIN，在A发送最后一个ack后，A会进入TIME_WAIT状态，再停留2个MSL时间，进入CLOSED状态。</p>
<p>用途：</p>
<p>\1. 可靠地实现TCP全双工连接的终止。避免对方收不到自己的ACK，等对方重发FIN。</p>
<p>\2. 保证旧连接的重复分组在网络中消逝。避免服务器重启（或者其他服务器绑定同样端口）接收到了上一次的数据。（TCP分组可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分组在路由器修复后也会被送到最终目的地，这个迟到的迷途分组到达时可能会引起问题。）</p>
<h3 id="TIME-WAIT状态后为什么需要等2MSL"><a href="#TIME-WAIT状态后为什么需要等2MSL" class="headerlink" title="TIME_WAIT状态后为什么需要等2MSL*"></a>TIME_WAIT状态后为什么需要等2MSL*</h3><p>****MSL****：maximum segment lifetime(最大报文生存时间），指报文能在互联网上生存的最长时间，超过这个时间报文将在网络中消失 。MSL在RFC 1122上建议是2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p>
<p>MSL多长？一般是60s.</p>
<p>cat /proc/sys/net/ipv4/tcp_fin_timeout</p>
<p>等待2MSL时间主要目的是怕四次握手的最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p>
<h3 id="TIME-WAIT状态过多原因与解决"><a href="#TIME-WAIT状态过多原因与解决" class="headerlink" title="TIME_WAIT状态过多原因与解决*"></a>TIME_WAIT状态过多原因与解决*</h3><p>查看当前系统下所有连接状态的数：</p>
<p>[root@vps ~]#netstat -n|awk ‘/^tcp/{++S[$NF]}END{for (key in S) print key,S[key]}’</p>
<p>TIME_WAIT 286</p>
<p>FIN_WAIT1 5</p>
<p>FIN_WAIT2 6</p>
<p>ESTABLISHED 269</p>
<p>SYN_RECV 5</p>
<p>CLOSING 1</p>
<p>原因：短时间内（比如1s）进行大量的短连接，可能出现time wait状态过多。</p>
<p>一般情况下，持续2MSL，不会有太大影响；但如果短时间内过多，会创建大量fd，导致fd被用尽，系统无法再发起新连接。</p>
<p>解决办法：<em><strong>*修改TIME_*</strong>***</em>*WAIT****<em><strong>*时间的Linux内核参数**</strong></em></p>
<p>在****/etc/sysctl.conf****文件中，加入：</p>
<p>net.ipv4.tcp_tw_reuse = 1（默认为0，表示关闭）</p>
<p># 表示开启重用。允许将TIME-WAIT的socket重新用于新的TCP连接</p>
<p>由于两端都使用了时间戳，所以能够避免序列号重复。</p>
<p>net.ipv4.tcp_tw_recycle = 1（默认为0，表示关闭）</p>
<p>#表示开启TCP连接中TIME-WAIT sockets的快速回收</p>
<p><em><strong>*内核如何回收socket**</strong></em></p>
<p>TCP有一种行为，可以缓存每个连接最新的时间戳，后续请求中如果时间戳小于缓存的时间戳，即视为无效，相应的数据包会被丢弃。</p>
<p>Linux是否启用这种行为取决于tcp_timestamps和tcp_tw_recycle，其中tcp_timestamps缺省就是开启的，所以当tcp_tw_recycle被开启后，实际上这种行为就被激活了。</p>
<p>在NAT系统中会共享套接字和时间戳，因此会出现时间戳错乱的情况，后面的数据包就被丢弃了，具体的表现通常是客户端明明发送的SYN，但服务端就是不响应ACK。</p>
<p>net.ipv4.tcp_max_tw_buckets = 5000    </p>
<p>#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。</p>
<p>建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置。</p>
<p>修改 linux kernel 的 tcp time wait的时间。</p>
<p>在 $KERNEL/include/net/tcp.h里面，有下面的行：</p>
<p>#define <em><strong>*TCP_TIMEWAIT_LEN*</strong></em> (60*HZ)</p>
<p>而这个宏是真正控制 TCP TIME_WAIT 状态的超时时间的。根据我们的测试，设置为 10 秒比较合适，即：  　　</p>
<p>#define TCP_TIMEWAIT_LEN (10*HZ)</p>
<p>然后重新编译内核，重启系统即可发现短连接造成的TIME_WAIT状态大大减少。一般情况都可以至少减少2/3。也能相应提高系统应对短连接的速度。</p>
<p>net.ipv4.tcp_fin_timeout = 5    </p>
<p># 修改系统默认的 TIMEOUT 时间（输出用，不用真正起作用）</p>
<p>net.ipv4.tcp_syncookies = 1    （默认为0，表示关闭）</p>
<p>#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击</p>
<p>最后输入下面的命令，让内核参数生效：sudo sysctl -p</p>
<p>net.ipv4.tcp_keepalive_time = 1200 （缺省是2小时，改为20分钟）</p>
<p>#表示当keepalive启用的时候，TCP发送keepalive消息的频度</p>
<p>net.ipv4.ip_local_port_range = 10000 65000    </p>
<p>#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。</p>
<p>net.ipv4.tcp_max_syn_backlog = 8192    </p>
<p>#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数</p>
<h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT*"></a>CLOSE_WAIT*</h3><p>CLOSE_WAIT，借用某位大牛的话来说应该倒过来叫做 WAIT_CLOSE，也就是说「等待关闭」</p>
<p>A发出 FIN 包，B响应 ACK 包，此时，B就进入了 CLOSE_WAIT 状态。如果一切正常，稍后B会发出 FIN 包，然后进入 LAST_ACK 状态。</p>
<p>如果出现大量的 CLOSE_WAIT 状态，那么就意味着B没有及时发出 FIN 包，一般有如下几种可能：</p>
<ol>
<li><p>程序问题：代码层面忘记关闭相应的 socket 连接导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到</p>
</li>
<li><p>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。</p>
</li>
<li><p>BACKLOG 太大：此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在队列里就被对方关闭了。</p>
</li>
</ol>
<p>服务器中存在大量close wait的危害：</p>
<p>大量close wait会占用服务器的fd，而一个机器能打开的fd数量是有限的，超过后就无法分配fd，无法建立新连接。</p>
<h3 id="CLOSE-WAIT-TIME-WAIT哪个危害大"><a href="#CLOSE-WAIT-TIME-WAIT哪个危害大" class="headerlink" title="CLOSE_WAIT TIME_WAIT哪个危害大*"></a>CLOSE_WAIT TIME_WAIT哪个危害大*</h3><p>通常情况下，time wait对服务器影响有限，而大量的close wait风险较高，一般正确编码可以避免。</p>
<h2 id="TCP粘包拆包"><a href="#TCP粘包拆包" class="headerlink" title="TCP粘包拆包"></a>TCP粘包拆包</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p>
<p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为一个进行发送，这就形成了粘包问题。</p>
<p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p>
<h3 id="具体出现场景"><a href="#具体出现场景" class="headerlink" title="具体出现场景"></a>具体出现场景</h3><p>假设client向服sever连续发送了两个数据包，packet1和packet2，server收到的数据可分为三种：</p>
<ol>
<li><p>正常收到两个数据包，没有发生拆包和粘包</p>
</li>
<li><p>只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包</p>
</li>
</ol>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps44.jpg" alt="img"> </p>
<ol start="3">
<li>接收端收到了两个数据包，但是这两个数据包是不完整的、或者是多出来一块，这种情况即发生了拆包和粘包（Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理）</li>
</ol>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps45.jpg" alt="img"> </p>
<h3 id="为什么TCP有拆包粘包-UDP没有"><a href="#为什么TCP有拆包粘包-UDP没有" class="headerlink" title="为什么TCP有拆包粘包  UDP没有"></a>为什么TCP有拆包粘包  UDP没有</h3><p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生，日常的网络应用开发大都在传输层进行。</p>
<p>UDP有消息保护边界，不会发生粘包拆包问题。</p>
<p>因此粘包拆包问题只发生在TCP中。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组。</p>
<p>常用方案：</p>
<ol>
<li><p>消息定长，比如每个报文的大小为固定长度200字节，如果不够，空位补空格</p>
</li>
<li><p>在包尾增加回车换行符进行分割，例如FTP协议</p>
</li>
<li><p>将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，只有读取到足够长度的消息之后才算是读到了一个完整的消息</p>
</li>
<li><p>通过自定义协议进行粘包和拆包的处理。</p>
</li>
</ol>
<h3 id="TCP粘包拆包-发生的原因"><a href="#TCP粘包拆包-发生的原因" class="headerlink" title="TCP粘包拆包 发生的原因"></a>TCP粘包拆包 发生的原因</h3><ol>
<li><p>应用程序写入的数据大于套接字的缓冲区大小，发生拆包</p>
</li>
<li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，发生粘包</p>
</li>
<li><p>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</p>
</li>
<li><p>接收方法不及时读取套接字缓冲区数据，这将发生粘包</p>
</li>
</ol>
<p>摘自：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/azraelly/archive/2012/12/25/2832393.html">https://www.cnblogs.com/azraelly/archive/2012/12/25/2832393.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4cd3de320f7">https://www.jianshu.com/p/e4cd3de320f7</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.huoding.com/2016/01/19/488">https://blog.huoding.com/2016/01/19/488</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/298214130">https://www.zhihu.com/question/298214130</a></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            cookie、session、token
          
        </div>
      </a>
    
    
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Websocket/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Websocket</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "",
    app_key: "",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> fyr
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/my.jpg" alt="Fanfan"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/life">生活</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>