<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Fanfan</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="Fanfan" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Fanfan</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="true"
          class="cover-logo"
          alt="Fanfan"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Spring/Mybatis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/Spring/Mybatis/"
    >Mybatis</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/Spring/Mybatis/" class="article-date">
  <time datetime="2021-09-10T05:00:40.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.<em><strong>优点</strong></em></h3><p>MyBatis框架的优点：</p>
<ol>
<li><p>与JDBC相比，减少了50%以上的代码量</p>
</li>
<li><p>MyBatis是最简单的持久化框架，小巧并且简单易学</p>
</li>
<li><p>MyBatis灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，降低耦合度，便于统一管理和优化，可重用</p>
</li>
<li><p>提供XML标签，支持编写动态SQL语句（XML中使用if, else）</p>
</li>
<li><p>提供映射标签，支持对象与数据库的ORM字段关系映射（在XML中配置映射关系，也可以使用注解）。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求</p>
</li>
<li><p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
</li>
</ol>
<p>MyBatis框架适用场合：</p>
<p>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</p>
<p>对性能的要求很高，或者需求变化较多的项目，如互联网项目</p>
<h3 id="2-Mybatis一级缓存-二级缓存"><a href="#2-Mybatis一级缓存-二级缓存" class="headerlink" title="2. Mybatis一级缓存 二级缓存"></a>2. <em><strong>Mybatis一级缓存 二级缓存</strong></em></h3><p>针对查询操作，mybatis支持通过缓存的方式来减少SQL的调用，提高查询性能。在缓存级别方面分为一级缓存和二级缓存，区别：</p>
<ol>
<li><p>一级缓存的粒度较小，是与某个SqlSession绑定的，只对该SqlSession的相关查询操作进行缓存，不同SqlSession实例之间相互不影响，缓存为使用本地内存实现</p>
</li>
<li><p>二级缓存是一种全局缓存，是由所有SqlSession实例所共享的，即不同SqlSession实例查询时产生的缓存，对其他SqlSession实例可见</p>
</li>
</ol>
<h3 id="3"><a href="#3" class="headerlink" title="3. #{} ${}"></a>3. <em><strong>#{}</strong></em> <em><strong>${}</strong></em></h3><p>${}是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。</p>
<p>#{}是 sql 的参数占位符，MyBatis 会将 sql 中的#{}替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName()。</p>
<h3 id="4-mybatis和jdbc区别"><a href="#4-mybatis和jdbc区别" class="headerlink" title="4. mybatis和jdbc区别"></a>4. <em><strong>mybatis和jdbc区别</strong></em></h3><p><em><strong>JDBC</strong></em>是Java提供的一个操作数据库的API；</p>
<p><em><strong>MyBatis</strong></em>是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p>
<p>MyBatis是对JDBC的封装。相对于JDBC，MyBatis有以下优点：</p>
<p><em><strong>*1. 优化获取和释放*</strong></em></p>
<p>我们一般在访问数据库时都是通过数据库连接池来操作数据库，数据库连接池有好几种，比如C3P0、DBCP，也可能采用容器本身的JNDI数据库连接池。我们可以通过DataSource进行隔离解耦，我们统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，所以我们将DataSource的具体实现通过让用户配置来应对变化。</p>
<p>C3P0 xml配置：</p>
<p><bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"><br>  <property name="driverClass" value=" oracle.jdbc.driver.OracleDriver ">   </property></bean></p>
  <property name="jdbcUrl" value=" jdbc:oracle:thin:@localhost:1521:ora9i ">   
  <property name="user" value="admin">   
  <property name="password" value="1234">   
 

<p>DBCP xml配置：</p>
<p><bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"><br>  <property name="driverClassName" value="com.mysql.jdbc.Driver"><br>  <property name="url" value="jdbc:mysql://localhost:3309/sampledb"><br>  <property name="username" value="root"><br>  <property name="password" value="1234"><br></property></property></property></property></bean></p>
<p>DURID xml配置：</p>
<bean name="dataSource" class="com.alibaba.druid.pool.DruidDataSource"> 

<p>　　<property name="driverClassName"> </property></p>
<p>　　　　<value>com.mysql.jdbc.Driver</value> </p>
<p>　　</p></bean></property> <p></p>
<p>　　<property name="url"> </property></p>
<p>　　　　<value>${jdbc_url_gx}</value> </p>
<p>　　</p></property> <p></p>
<p>　　<property name="username"> </property></p>
<p>　　　　<value>${jdbc_username_gx}</value> </p>
<p>　　</p></property> <p></p>
<p>　　<property name="password"> </property></p>
<p>　　　　<value>${jdbc_password_gx}</value> </p>
<p>　　 </p>


<p><em><strong>*2.SQL统一管理，对数据库进行存取操作*</strong></em></p>
<p>我们使用JDBC对数据库进行操作时，SQL查询语句分布在各个Java类中，这样可读性差，不利于维护，当我们修改Java类中的SQL语句时要重新进行编译。</p>
<p>Mybatis可以把SQL语句放在配置文件中统一进行管理，以后修改配置文件，也不需要重新就行编译部署。</p>
<p><em><strong>*3.生成动态SQL语句*</strong></em></p>
<p>我们在查询中可能需要根据一些属性进行组合查询，比如我们进行商品查询，我们可以根据商品名称进行查询，也可以根据发货地进行查询，或者两者组合查询。如果使用JDBC进行查询，这样就需要写多条SQL语句。</p>
<p>Mybatis可以在配置文件中通过使用<if test="””"></if>标签进行SQL语句的拼接，生成动态SQL语句。比如下面这个例子：</p>
<select id="getCountByInfo" parametertype="User" resulttype="int">
     select count(*) from user
     <where>
       <if test="nickname!=null">
         and nickname = #{nickname}
       </if>
       <if test="email!=null">
         and email = #{email}
       </if>
     </where>

</select>

<p>就是通过昵称或email或者二者的组合查找用户数。</p>
<p><em><strong>*4.能够对结果集进行映射*</strong></em></p>
<p>我们在使用JDBC进行查询时，返回一个结果集ResultSet,我们要从结果集中取出结果封装为需要的类型</p>
<p>在Mybatis中我们可以设置将结果直接映射为自己需要的类型，比如：JavaBean对象、一个Map、一个List等等。像上个例子中就是将结果映射为int类型。</p>
<h3 id="5-xml映射文件常见标签"><a href="#5-xml映射文件常见标签" class="headerlink" title="5. xml映射文件常见标签"></a>5. <em><strong>xml映射文件常见标签</strong></em></h3><p>select|insert|update|delete</p>
<p><resultMap><parameterMap></parameterMap></resultMap></p>
<p><sql> sql 片段标签</sql></p>
<p><include> 引入 sql 片段</include></p>
<p><selectKey> 为不支持自增的主键生成策略标签</selectKey></p>
<p>动态 sql 的 9 个标签：</p>
<p>trim|where|set|foreach|if|choose|when|otherwise|bind</p>
<h3 id="6-Da-o-接口工作原理"><a href="#6-Da-o-接口工作原理" class="headerlink" title="6. Da***o***接口工作原理"></a>6. <em><strong>Da</strong>***</em>o***<em><strong>接口工作原理</strong></em></h3><p>最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</p>
<p>Dao 接口，就是人们常说的 Mapper接口。</p>
<p>接口的全限名就是xml中的 namespace 的值，接口的方法名就是xml中MappedStatement的 id 值，接口方法内的参数就是传递给 sql 的参数。</p>
<p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个xml中的MappedStatement。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将 sql 执行结果返回。</p>
<p>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在 MyBatis 中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</delete></update></insert></select></p>
<p>Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复。可以这样实现：（能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法）</p>
<p>public interface StuMapper {</p>
<p>  List<Student> getAllStu();</Student></p>
<p>  List<Student> getAllStu(@Param(“id”) Integer id);</Student></p>
<p>}</p>
  <select id="getAllStu" resulttype="com.pojo.Student">

<p>​     select * from student</p>
<p>​    <where></where></p>
<p>​      <if test="id != null"></if></p>
<p>​        id = #{id}</p>
<p>​      </p>
<p>​    </p>
   </select>

<h3 id="7-动态-sql"><a href="#7-动态-sql" class="headerlink" title="7.动态 sql"></a>7.<em><strong>动态 sql</strong></em></h3><p>是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</p>
<p>MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。</p>
<p>MyBatis 提供了 9 种动态 sql 标签 trim|where|set|foreach|if|choose|when|otherwise|bind</p>
<p>其执行原理：使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h3 id="8-如何将-sql-执行结果封装为目标对象并返回"><a href="#8-如何将-sql-执行结果封装为目标对象并返回" class="headerlink" title="8. 如何将 sql 执行结果封装为目标对象并返回"></a>8. <em><strong>如何将 sql 执行结果封装为目标对象并返回</strong></em></h3><p>MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</p>
<p>映射形式：</p>
<ol>
<li><p>使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系</resultMap></p>
</li>
<li><p>使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p>
</li>
</ol>
<p>如何：有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h3 id="9-一对一、一对多的关联查询"><a href="#9-一对一、一对多的关联查询" class="headerlink" title="9. 一对一、一对多的关联查询"></a>9. <em><strong>一对一、一对多的关联查询</strong></em></h3><p>MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</p>
<p>能，MyBatis 不仅可以执行一对一、一对多的关联查询</p>
<p>还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为 selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为 selectList()即可。</p>
<p>关联对象查询，有两种实现方式：</p>
<ol>
<li><p>单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。</p>
</li>
<li><p>使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p>
</li>
</ol>
<p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据列值来完成 100 条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。</id></id></resultMap></p>
<p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p>
<h3 id="10-是否支持延迟加载"><a href="#10-是否支持延迟加载" class="headerlink" title="10. 是否支持延迟加载"></a>10. <em><strong>是否支持延迟加载</strong></em></h3><p>MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</p>
<p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。</p>
<p>association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。</p>
<p>原理：使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<h3 id="11-不同的-Xml-映射文件，id-是否可以重复"><a href="#11-不同的-Xml-映射文件，id-是否可以重复" class="headerlink" title="11. 不同的 Xml 映射文件，id 是否可以重复"></a>11. <em><strong>不同的 Xml 映射文件，id 是否可以重复</strong></em></h3><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p>
<p>原因就是 namespace+id 是作为 Map&lt;String, MappedStatement&gt;的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
<h3 id="12-如何执行批处理？"><a href="#12-如何执行批处理？" class="headerlink" title="12. 如何执行批处理？"></a>12. <em><strong>如何执行批处理？</strong></em></h3><p>使用 BatchExecutor 完成批处理。</p>
<h3 id="13-Executor-执行器"><a href="#13-Executor-执行器" class="headerlink" title="13. Executor 执行器"></a>13. <em><strong>Executor 执行器</strong></em></h3><p>MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？ </p>
<ol>
<li><p>SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象</p>
</li>
<li><p>ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p>
</li>
<li><p>BatchExecutor：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
</li>
</ol>
<p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<p>在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 DefaultSqlSessionFactory 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p>
<h3 id="14-是否可以映射枚举类"><a href="#14-是否可以映射枚举类" class="headerlink" title="14. 是否可以映射枚举类"></a>14. <em><strong>是否可以映射枚举类</strong></em></h3><p>MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。</p>
<p>映射方式为自定义一个 TypeHandler，实现 TypeHandler 的 setParameter()和 getResult()接口方法。TypeHandler 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 setParameter()和 getResult()两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p>
<h3 id="15-引用标签后，两个标签的位置"><a href="#15-引用标签后，两个标签的位置" class="headerlink" title="15. 引用标签后，两个标签的位置"></a>15. <em><strong>引用标签后，两个标签的位置</strong></em></h3><p>MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</p>
<p>虽然 MyBatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。</p>
<p>原理是：MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<h3 id="16-xml和内部数据结构映射关系"><a href="#16-xml和内部数据结构映射关系" class="headerlink" title="16. xml和内部数据结构映射关系"></a>16. <em><strong>xml和内部数据结构映射关系</strong></em></h3><p>简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</p>
<p>MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。</p>
<p><parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</parameterMap></p>
<p><resultMap>标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</resultMap></p>
<p>每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象。</delete></update></insert></select></p>
<p>标签内的 sql 会被解析为 BoundSql 对象。</p>
<h3 id="17-为什么说-MyBatis-是半自动-ORM-映射工具"><a href="#17-为什么说-MyBatis-是半自动-ORM-映射工具" class="headerlink" title="17. 为什么说 MyBatis 是半自动 ORM 映射工具"></a>17. <em><strong>为什么说</strong></em> <em><strong>MyBatis 是半自动 ORM 映射工具</strong></em></h3><p>为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</p>
<p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p>
<p>而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
<p> 摘自：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiushisoftware/article/details/98944211">https://blog.csdn.net/qiushisoftware/article/details/98944211</a></p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/love-Stefanie/p/6838269.html">https://www.cnblogs.com/love-Stefanie/p/6838269.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring/Servlet"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/Spring/Servlet/"
    >Servlet</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/Spring/Servlet/" class="article-date">
  <time datetime="2021-09-10T04:56:49.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="1-Servlet是什么"><a href="#1-Servlet是什么" class="headerlink" title="1. Servlet是什么"></a>1. Servlet是什么</h3><p>Servlet定义：一段处理 web 请求的逻辑</p>
<p>在Java中，servlet是一个接口，规定请求从容器到达 web 服务端的规范，最重要的三个步骤是:</p>
<ol>
<li><p>init()：初始化请求的时候要做什么；</p>
</li>
<li><p>service()：拿到请求的时候要做什么；</p>
</li>
<li><p>destory()：处理完请求销毁的时候要做什么。</p>
</li>
</ol>
<p>所有实现 Servlet 的实现都是在这个规范的基础上进行开发。</p>
<p>package javax.servlet;</p>
<p>import java.io.IOException;</p>
<p>public interface Servlet {</p>
<p>public void <em><strong>*init*</strong></em>(ServletConfig config) throws ServletException;</p>
<pre><code>  public ServletConfig ***\*getServletConfig\****();

  public void ***\*service\****(ServletRequest req, ServletResponse res)
</code></pre>
<p>​      throws ServletException, IOException;</p>
<pre><code>  public String ***\*getServletInfo\****();

  public void ***\*destroy\****();
</code></pre>
<p>}</p>
<h3 id="2-Servlet容器"><a href="#2-Servlet容器" class="headerlink" title="2. Servlet容器"></a>2. Servlet容器</h3><p>Servlet 只是一个处理请求的应用程序，光有Servlet是无法运行起来的，需要有一个 main 方法去调用你的这段 Servlet 程序才行。这就需要servlet容器了。</p>
<p>Servlet容器的主要作用是：</p>
<ol>
<li><p>建立连接；</p>
</li>
<li><p>调用Servlet处理请求；</p>
</li>
<li><p>响应请求给客户端；</p>
</li>
<li><p>释放连接；</p>
</li>
</ol>
<p>常见的Servlet容器Tomcat的流程：</p>
<p>监听了客户端的请求端口,根据请求信息确定将请求交给哪个Servlet 处理，找到处理的Servlet之后，调用该Servlet的 service() 方法，处理完毕将对应的处理结果包装成ServletResponse 对象返回给客户端。</p>
<p>Servlet容器只有一个，而 Servlet 可以有多个。</p>
<h3 id="3-DispatcherServlet"><a href="#3-DispatcherServlet" class="headerlink" title="3. DispatcherServlet"></a>3. DispatcherServlet</h3><p>定义：是 Spring 中定义的一个 Servlet，实现了 Servlet 接口，本质也是一个 Servlet。</p>
<p>它是 HttpServlet 的继承者，主要处理 http 请求。</p>
<p>所以 Spring 程序本质是就是一个 Servlet。SpringMVC 帮你做了本该你去实现的逻辑。</p>
<p>Spring 的核心就是一个 Servlet,它拦截了所有的请求,将请求交给 DispatcherServlet 去处理</p>
<h3 id="4-Tomcat"><a href="#4-Tomcat" class="headerlink" title="4. Tomcat*"></a>4. Tomcat*</h3><p>Tomcat：常见的Servlet容器Tomcat，实现了对 Java Servlet 规范的支持</p>
<p>Tomcat 也提供了处理HTTP请求的能力，所以也可以作为一个Web服务器。</p>
<p>Tomcat如何设计？如下图：</p>
<p><img src="/2021/09/10/Spring/Servlet/wps23.jpg" alt="img"> </p>
<p>Java web 应用如果部署到 Tomcat 中，一个Tomcat就表示一个服务。</p>
<p>一个 Server 服务器可以包含多个 Service 服务，Tomcat 默认的 Service 服务是 Catalina</p>
<p>一个 Service 服务可以包含</p>
<p>① 多个连接器，因为 Tomcat 支持多种网络协议，包括 HTTP/1.1、HTTP/2、AJP 等等</p>
<p>② 一个容器，容器外部会有一层 Engine 引擎所包裹，负责与处理连接器的请求与响应，连接器与容器之间通过 ServletRequest 和 ServletResponse 对象进行交流。</p>
<p>Server 组件：管理 tomcat 实例的组件，可以监听一个端口</p>
<p>Service 组件：是一个逻辑组件，用于绑定 connector 和 container，有了 service 表示可以向外提供服务，就像是一般的 daemon 类服务的 service。可以认为一个 service 就启动一个JVM，更严格地说，一个 engine 组件才对应一个 JVM （定义负载均衡时，jvmRoute 就定义在 Engine 组件上用来标识这个 JVM ），只不过 connector 也工作在 JVM 中。</p>
<p>Connector 组件：监听组件，它有四个作用：</p>
<ol>
<li><p>开启监听套接字，监听外界请求，并和客户端建立 TCP 连接</p>
</li>
<li><p>使用 protocolHandler 解析请求中的协议和端口等信息，如 http 协议、AJP 协议；</p>
</li>
<li><p>根据解析到的信息，使用 processer 将分析后的请求转发给绑定的 Engine；</p>
</li>
<li><p>接收响应数据并返回给客户端。</p>
</li>
</ol>
<p>Container ：表示一类组件，在配置文件(server.xml)中没有体现出来。它包含4个容器类组件：Engine容器、Host容器、Context容器 和 wrapper容器。</p>
<p>Engine 容器用于从 Connector 组件处接收已建立的 TCP 连接，还用于接收客户端发送的 HTTP 请求并分析请求，然后按照分析的结果将相关参数传递给匹配出的虚拟主机。Engine 还用于指定默认的虚拟主机。</p>
<p>Host 容器定义虚拟主机，对应了服务器中一个网络名实体（如”<a target="_blank" rel="noopener" href="http://www.baidu.com”,或ip地址”23.0.32.1”).为了使用户可以通过域名连接/">www.baidu.com”，或IP地址”23.0.32.1”）。为了使用户可以通过域名连接</a> Tomcat 服务器，这个域名应该在域名服务器已经注册过。</p>
<p>Context 容器主要是根据 path 和 docBase 获取一些信息，将结果交给其内的 wrapper 组件进行处理（它提供wrapper运行的环境，所以它叫上下文context）。一般来说，都采用默认的标准 wrapper 类，因此在 Context 容器中几乎不会出现 wrapper 组件。</p>
<p>wrapper 容器对应 Servlet 的处理过程。它开启 Servlet 的生命周期，根据 Context 给出的信息以及解析 web.xml 中的映射关系，负责装载相关的类，初始化 servlet 对象 init()、执行 servlet 代码 service() 以及服务结束时 servlet 对象的销毁 destory()。</p>
<p>摘自：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rickiyang/p/12764615.html">https://www.cnblogs.com/rickiyang/p/12764615.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring/SpringBoot"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/Spring/SpringBoot/"
    >SpringBoot</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/Spring/SpringBoot/" class="article-date">
  <time datetime="2021-09-10T04:54:22.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="1-Springboot是什么"><a href="#1-Springboot是什么" class="headerlink" title="1. Springboot是什么"></a>1. Springboot是什么</h3><p>Spring Boot 并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p>
<p>集成了大量常用的第三方库配置，Spring Boot中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p>
<h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ol>
<li><p>SpringBoot继承了Spring优秀的基因，在Spring中开发更为方便快捷，帮助开发者快速的搭建Spring框架</p>
</li>
<li><p>简化依赖。比如创建一个 web 项目，在使用 Spring 的时需要在 pom 文件中添加多个依赖，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。</p>
</li>
<li><p>简化配置。Spring各种XML、Annotation配置会让人眼花缭乱，Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。比如@Configuration。另外，Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可</p>
</li>
<li><p>简化部署。Spring 项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里。Spring Boot 不需要在服务器上去部署 tomcat，内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 java -jar xxx.jar一键式启动项目。</p>
</li>
</ol>
<h3 id="3-自动装配原理"><a href="#3-自动装配原理" class="headerlink" title="3. 自动装配原理"></a>3. 自动装配原理</h3><p><em><strong>是什么</strong></em></p>
<p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>
<p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 spring-boot-starter-data-redis即可。</p>
<p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。自动装配可以简单理解为：通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</p>
<p><em><strong>如何实现？</strong></em></p>
<p>@SpringBootApplication可以看做以下3个的集合：</p>
<ol>
<li><p>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</p>
</li>
<li><p>@Configuration：允许在上下文中注册额外的 bean 或导入其他配置</p>
</li>
<li><p>@ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。</p>
</li>
</ol>
<p>@EnableAutoConfiguration:实现自动装配的核心注解</p>
<p>EnableAutoConfiguration 只是一个简单地注解，自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector类。</p>
<p>AutoConfigurationImportSelector:加载自动装配类，该类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。实现如下：</p>
<p>private static final String[] NO_IMPORTS = new String[0];</p>
<p>public String[] selectImports(AnnotationMetadata annotationMetadata) {</p>
<p>​    // &lt;1&gt;.判断自动装配开关是否打开</p>
<p>​    if (!this.isEnabled(annotationMetadata)) {</p>
<p>​      return NO_IMPORTS;</p>
<p>​    } else {</p>
<p>​     //&lt;2&gt;.获取所有需要装配的bean</p>
<p>​      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);</p>
<p>​      AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</p>
<p>​      return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</p>
<p>​    }</p>
<p>  }</p>
<p>getAutoConfigurationEntry()方法：主要负责加载自动配置类的。源码如下：</p>
<p>AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {</p>
<p>​    //&lt;1&gt;.判断自动装配开关是否打开</p>
<p>​    if (!this.isEnabled(annotationMetadata)) {</p>
<p>​      return EMPTY_ENTRY;</p>
<p>​    } else {</p>
<p>​      //&lt;2&gt;.获取exclude 和 excludeName</p>
<p>​      AnnotationAttributes attributes = this.getAttributes(annotationMetadata);</p>
<p>​      //&lt;3&gt;.读取META-INF/spring.factories</p>
<p>​      List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</String></p>
<p>​      //&lt;4&gt;.选出@ConditionalOnXXX 中的所有条件</p>
<p>​      configurations = this.removeDuplicates(configurations);</p>
<p>​      Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);</String></p>
<p>​      this.checkExcludedClasses(configurations, exclusions);</p>
<p>​      configurations.removeAll(exclusions);</p>
<p>​      configurations = this.filter(configurations, autoConfigurationMetadata);</p>
<p>​      this.fireAutoConfigurationImportEvents(configurations, exclusions);</p>
<p>​      return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</p>
<p>​    }</p>
<p>  }</p>
<ol>
<li><p>判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</p>
</li>
<li><p>用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName</p>
</li>
<li><p>获取需要自动装配的所有配置类，读取META-INF/spring.factories</p>
</li>
</ol>
<p><img src="/2021/09/10/Spring/SpringBoot/wps22.jpg" alt="img"> </p>
<p>不光是这个依赖下的META-INF/spring.factories被读取到，所有 Spring Boot Starter 下的META-INF/spring.factories都会被读取到。所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了META-INF/spring.factories文件。</p>
<ol start="4">
<li><p>spring.factories中这么多配置，每次启动并不是全部加载。需要一遍筛选，@ConditionalOnXXX 中的所有条件都满足，该类才会生效。Spring Boot 提供的条件注解</p>
<ol>
<li><p>@ConditionalOnBean：当容器里有指定 Bean 的条件下</p>
</li>
<li><p>@ConditionalOnMissingBean：当容器里没有指定 Bean 的情况下</p>
</li>
<li><p>@ConditionalOnSingleCandidate：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</p>
</li>
<li><p>@ConditionalOnClass：当类路径下有指定类的条件下</p>
</li>
<li><p>@ConditionalOnMissingClass：当类路径下没有指定类的条件下</p>
</li>
<li><p>@ConditionalOnProperty：指定的属性是否有指定的值</p>
</li>
<li><p>@ConditionalOnResource：类路径是否有指定的值</p>
</li>
<li><p>等</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-版本"><a href="#4-版本" class="headerlink" title="4. 版本"></a>4. 版本</h3><p>2.3.4</p>
<h3 id="5-Springboot如何启动Tomcat"><a href="#5-Springboot如何启动Tomcat" class="headerlink" title="5. Springboot如何启动Tomcat*"></a>5. Springboot如何启动Tomcat*</h3><p>SpringBoot可以把web程序打包成jar包，直接启动，这得益于SpringBoot内置了容器，可以直接启动。</p>
<p>Springboot从main启动</p>
<p>@SpringBootApplication</p>
<p>public class TomcatDebugApplication {</p>
<p>  public static void main(String[] args) {</p>
<p>​    SpringApplication.run(TomcatDebugApplication.class, args);</p>
<p>  }</p>
<p>}</p>
<p>run方法是调用ConfigurableApplicationContext 方法</p>
<ol>
<li><p>配置属性，设置系统属性『java.awt.headless』</p>
</li>
<li><p>获取监听器，发布应用开始启动事件</p>
</li>
<li><p>初始化输入参数</p>
</li>
<li><p>配置环境。创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）；并遍历调用所有的SpringApplicationRunListener的environmentPrepared()方法，广播Environment准备完毕。</p>
</li>
<li><p>输出banner</p>
</li>
<li><p>创建ApplicationContext：<em><strong>*createApplicationContext()*</strong></em></p>
</li>
<li><p>通过SpringFactoriesLoader检索META-INF/spring.factories,获取并实例化异常分析器</p>
</li>
<li><p>prepareContext: </p>
<ol>
<li><p>为ApplicationContext加载environment，之后逐个执行ApplicationContextInitializer的initialize()方法来进一步封装ApplicationContext</p>
</li>
<li><p>调用所有的SpringApplicationRunListener的contextPrepared()方法</p>
</li>
<li><p>初始化IoC容器</p>
</li>
</ol>
</li>
<li><p>刷新<em><strong>*refreshContext(context);在此启动tomcat*</strong>***</em>*容器****</p>
</li>
<li><p>发布应用已经启动事件</p>
</li>
<li><p>发布应用启动完成事件</p>
</li>
</ol>
<p><em><strong>*createApplicationContext()*</strong></em></p>
<p>根据webApplicationType属于哪种类型的Servlet，分类如下：</p>
<ol>
<li><p>SERVLET  Web类型（我们建立的是web类型）</p>
</li>
<li><p>REACTIVE响应式Web类型</p>
</li>
<li><p>default 非Web类型</p>
</li>
</ol>
<p>我们建立的是Web类型，实例化对应的applicationContext。</p>
<p>即实例化DEFAULT_SERVLET_WEB_CONTEXT_CLASS指定的类。</p>
<p>也就是****AnnotationConfigServletWebServerApplicationContext****类</p>
<p>经过各种调用..</p>
<p>到达createWebServer()：启动web服务，但是还没有真正启动Tomcat</p>
<p>​    通过工厂方法TomcatServletWebServerFactory.getWebServer()获得</p>
<p>​        第一件事：把Connnctor对象添加到Tomcat中</p>
<p>第二件事：configureEngine。Engine是容器，上层接口Container</p>
<p>而启动Tomcat就是在第9步的“刷新上下文”</p>
<p>Tomcat的启动主要是初始化2个核心组件：连接器(Connector)和容器（Container）</p>
<p>一个Tomcat实例就是一个Server，一个Server包含多个Service，也就是多个应用程序，每个Service包含多个连接器（Connetor）和一个容器（Container)，而容器下又有多个子容器，按照父子关系分别为：Engine、Host、Context、Wrapper，其中除了Engine外，其余的容器都是可以有多个。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring/SpringMVC"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/Spring/SpringMVC/"
    >SpringMVC</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/Spring/SpringMVC/" class="article-date">
  <time datetime="2021-09-10T04:50:31.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="1-MVC是什么"><a href="#1-MVC是什么" class="headerlink" title="1. MVC是什么"></a>1. MVC是什么</h3><p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 **Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)**。</p>
<p>解决了什么问题：将前端页面和后端代码分离，实现了一个请求对应一个方法。</p>
<h3 id="2-工作原理（生命周期）"><a href="#2-工作原理（生命周期）" class="headerlink" title="2. 工作原理（生命周期）*"></a>2. 工作原理（生命周期）*</h3><ol>
<li><p>发起请求到DispatcherServlet (前端控制器)</p>
</li>
<li><p>DispatcherServlet根据请求信息调用HandlerMapping（处理器映射器）查找 Handler（处理器，也就是Controller）</p>
</li>
<li><p>HandlerMapping解析请求对应的Handler，并返回给DispatcherServlet</p>
</li>
<li><p>DispatcherServlet调用HandlerAdapter（处理器适配器）去处理Handler</p>
</li>
<li><p>Handler执行完成后返回ModelAndView给DispatcherServlet。ModelAndView是springmvc框架的一个底层对象，包括 Model和view</p>
</li>
<li><p>DispatcherServlet请求ViewResolver（视图解析器）去进行视图解析；根据逻辑视图名解析成真正的视图(jsp)</p>
</li>
<li><p>ViewResolver向DispatcherServlet返回View</p>
</li>
<li><p>DispatcherServlet进行视图渲染，即将模型数据(在ModelAndView对象中)填充到request域</p>
</li>
<li><p>DispatcherServlet向用户响应结果</p>
</li>
</ol>
<p><img src="/2021/09/10/Spring/SpringMVC/wps20.jpg" alt="img"> </p>
<h3 id="3-拦截器Interceptor"><a href="#3-拦截器Interceptor" class="headerlink" title="3. 拦截器Interceptor"></a>3. 拦截器Interceptor</h3><p>Spring MVC中的拦截器（Interceptor）主要用于<strong>拦截用户请求并作相应的处理</strong>。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。</p>
<p>如何使用：</p>
<ol>
<li><p>编写一个简单的拦截器处理类，实现HandlerInterceptor 接口，该接口包含三个方法：preHandle, postHandle, afterCompletion</p>
</li>
<li><p>将自定义好的拦截器处理类进行注册，并通过addPathPatterns、excludePathPatterns等属性设置需要拦截或需要排除的 URL。</p>
</li>
</ol>
<p>小demo：</p>
<p>自定义拦截器：</p>
<p>public class MyInterceptor implements HandlerInterceptor {</p>
<p>  private static final Logger logger =</p>
<p>  LoggerFactory.getLogger(MyInterceptor.class);</p>
<p>  @Override</p>
<p>  public boolean preHandle(HttpServletRequest request, HttpServletResponse</p>
<p>  response, Object handler) throws Exception {</p>
<p>​    HandlerMethod handlerMethod = (HandlerMethod) handler;</p>
<p>​    Method method = handlerMethod.getMethod();</p>
<p>​    String methodName = method.getName();</p>
<p>​    logger.info(“====拦截到了方法：{}，在该方法执行之前执行====”, methodName);</p>
<p>​    // 返回true才会继续执行，返回false则取消当前请求</p>
<p>​    return true;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void postHandle(HttpServletRequest request, HttpServletResponse</p>
<p>  response, Object handler, ModelAndView modelAndView) throws Exception {</p>
<p>​    logger.info(“执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染”);</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void afterCompletion(HttpServletRequest request, HttpServletResponse</p>
<p>  response, Object handler, Exception ex) throws Exception {</p>
<p>​    logger.info(“整个请求都处理完，DispatcherServlet也渲染了对应的视图，此时可以做一些清理的工作”);</p>
<p>  }</p>
<p>}</p>
<p>配置拦截器：</p>
<p>@Configuration</p>
<p>public class MyInterceptorConfig extends WebMvcConfigurationSupport {</p>
<p>  @Override</p>
<p>  protected void addInterceptors(InterceptorRegistry registry) {</p>
<p>​    // 将上面自定义好的拦截器添加进去。</p>
<p>​    registry.addInterceptor(new MyInterceptor()).addPathPatterns(“/**”);</p>
<p>​    super.addInterceptors(registry);</p>
<p>  }</p>
<p>}</p>
<h3 id="4-过滤器Filter"><a href="#4-过滤器Filter" class="headerlink" title="4. 过滤器Filter"></a>4. 过滤器Filter</h3><p>过滤器的配置比较简单，直接实现Filter 接口即可，也可以通过@WebFilter注解实现对特定URL拦截，看到Filter 接口中定义了三个方法。</p>
<p>init() ：在容器启动初始化过滤器时被调用，它在 Filter 的整个生命周期只会被调用一次。注意：这个方法必须执行成功，否则过滤器会不起作用。</p>
<p>doFilter() ：容器中的每一次请求都会调用该方法， FilterChain 用来调用下一个过滤器 Filter。</p>
<p>destroy()： 当容器销毁过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器 Filter 的整个生命周期也只会被调用一次</p>
<p>@Component</p>
<p>public class MyFilter implements Filter { </p>
<p>  @Override</p>
<p>  public void init(FilterConfig filterConfig) throws ServletException {</p>
<p>​    System.out.println(“Filter 前置”);</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {</p>
<p>​    System.out.println(“Filter 处理中”);</p>
<p>​    filterChain.doFilter(servletRequest, servletResponse);</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void destroy() {</p>
<p>​    System.out.println(“Filter 后置”);</p>
<p>  }</p>
<p>}</p>
<h3 id="5-AOP-拦截器-过滤器"><a href="#5-AOP-拦截器-过滤器" class="headerlink" title="5. AOP 拦截器  过滤器"></a>5. AOP 拦截器  过滤器</h3><ol>
<li><p>访问控制功能的粒度： </p>
<p>AOP：可以配置每个 Controller 的访问权限，访问控制功能要精确到每个请求</p>
<p>Filter和 Interceptor的粒度会粗一些，控制 HttpRequest、HttpResponse 的访问</p>
</li>
<li><p>Spring是否支持：Filter不能够使用 Spring 容器资源；而Interceptor是 Spring 提供的组件，由 Spring 来管理，因此它能使用 Spring 里的任何资源、对象，例如 Service 对象，通过 IoC 注入到 拦截器 中即可。</p>
</li>
<li><p>实现原理：Interceptor则是基于动态代理实现的，Filter是基于函数回调的</p>
</li>
<li><p>使用范围：Interceptor它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，也可以用于Application、Swing等程序中。Filter实现的是 javax.servlet.Filter 接口， 说明Filter 的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。</p>
</li>
<li><p>触发时机不同：Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。</p>
</li>
<li><p>拦截的请求范围不同：Filter几乎可以对所有进入容器的请求起作用，而Interceptor只会对Controller中请求或访问static目录下的资源请求起作用</p>
</li>
</ol>
<p><img src="/2021/09/10/Spring/SpringMVC/wps21.jpg" alt="img"> </p>
<h3 id="6-MVC优点"><a href="#6-MVC优点" class="headerlink" title="6. MVC优点"></a>6. MVC优点</h3><ol>
<li><p>清晰的角色划分：controller、model、DispatcherServlet、handler mapping、view  resolver等，每一个角色都可以由一个专门的对象来实现</p>
</li>
<li><p>强大而直接的配置方式：将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在controller中对业务对象的引用</p>
</li>
<li><p>灵活的model转换：在Springweb框架中，使用基于Map的键/值对来达到轻易的与各种视图技术集成</p>
</li>
<li><p>Spring Bean的生命周期：可以被限制在当前的HTTP Request或者HTTP Session。准确的说，这并非Spring MVC框架本身特性，而应归属于Spring MVC使用的WebApplicationContext容器。</p>
</li>
</ol>
<h3 id="7-Restful编程风格"><a href="#7-Restful编程风格" class="headerlink" title="7. Restful编程风格"></a>7. Restful编程风格</h3><p>****Restful 风格*<em><strong>的 API 是一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。<br>在 Restful 风格中，</strong></em>*用户请求的 url 使用同一个 url 而用请求方式：get，post，delete，put…等方式对请求的处理方法进行区分****，这样可以在前后台分离式的开发中使得前端开发人员不会对请求的资源地址产生混淆和大量的检查方法名的麻烦，形成一个统一的接口。</p>
<p>SpringMVC Restful 风格 url 配置实现的方式<br>SpringMVC 的 resturl 是通过 <a target="_blank" rel="noopener" href="https://tieba.baidu.com/home/main?un=RequestMapping&fr=pb&ie=utf-8&id=tb.1.af5ecb0a.Sjn8utRjosObEHsEEHuqlQ">@RequestMapping</a> 及 @PathVariable annotation 提供的，通过如 @RequestMapping(value=”/blog /{id}”,method=RequestMethod.DELETE) 即可处理 /blog/1 的 delete 请求。</p>
<p>GET（SELECT）：从服务器查询，可以在服务器通过请求的参数区分查询的 方式。<br>POST（CREATE）：在服务器端新建一个资源，调用 insert 操作。<br>PUT（UPDATE）：在服务器端更新资源，调用 update 操作。<br>PATCH（UPDATE）：在服务器端更新资源（客户端提供改变的属性）。(目前 jdk7 未实现，tomcat7 不支持)。<br>DELETE（DELETE）：从服务器端删除资源，调用 delete 语句。</p>
<p>摘自：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/l_blackeagle/article/details/61926695">https://blog.csdn.net/l_blackeagle/article/details/61926695</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring/常用注解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/Spring/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"
    >常用注解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/Spring/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time datetime="2021-09-10T04:48:06.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="1-常用"><a href="#1-常用" class="headerlink" title="1.常用"></a>1.常用</h3><ol>
<li><p>Spring bean依赖注入</p>
<ol>
<li><p>@Autowired：按照类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false</p>
</li>
<li><p>@Qualifier：按照名称来装配，搭配Autowired使用</p>
</li>
<li><p>@Resource：按照名称装配</p>
</li>
<li><p>@Component,@Repository,@Service, @Controller @RestController</p>
</li>
<li><p>@Configuration注解声明配置类更加语义化，可用@Component代替</p>
</li>
<li><p>@Scope声明 Spring Bean 的作用域：@Scope(“singleton”)</p>
</li>
</ol>
</li>
<li><p>请求</p>
<ol>
<li><p>@RequestMapping：用来处理请求地址映射的注解</p>
</li>
<li><p>@GetMapping请求从服务器获取特定资源</p>
</li>
<li><p>@PostMapping在服务器上创建一个新的资源</p>
</li>
<li><p>@PutMapping更新服务器上的资源（更新整个资源，比如编号12的学生信息）</p>
</li>
<li><p>@DeleteMapping从服务器删除特定的资源</p>
</li>
</ol>
</li>
<li><p>前后端传值</p>
<ol>
<li><p>@PathVariable：用于将请求URL中的模板变量映射到参数上</p>
</li>
<li><p>@RequestParam用于获取查询参数</p>
</li>
<li><p>@RequestBody用于读取请求的 body 部分并且Content-Type 为 application/json 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去</p>
</li>
<li><p>@ResponseBody：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用</p>
</li>
</ol>
</li>
<li><p>事务 </p>
<ol>
<li>@Transactional</li>
</ol>
</li>
<li><p>读取配置信息</p>
<ol>
<li><p>@Value(“${property}”) 读取比较简单的配置信息</p>
</li>
<li><p>@ConfigurationProperties读取配置信息并与 bean 绑定</p>
</li>
<li><p>@PropertySource读取指定 properties 文件</p>
</li>
</ol>
</li>
<li><p>全局处理Controller异常</p>
<ol>
<li><p>@ControllerAdvice :注解定义全局异常处理类</p>
</li>
<li><p>@ExceptionHandler :注解声明异常处理方法</p>
</li>
</ol>
</li>
<li><p>json数据处理</p>
<ol>
<li><p>@JsonIgnoreProperties 作用在类上用于过滤掉特定字段不返回或者不解析</p>
</li>
<li><p>@JsonIgnore一般用于类的属性上，作用和上面的@JsonIgnoreProperties 一样。</p>
</li>
<li><p>@JsonFormat一般用来格式化 json 数据</p>
</li>
<li><p>@JsonUnwrapped 扁平对象</p>
</li>
</ol>
</li>
<li><p>测试</p>
<ol>
<li><p>@ActiveProfiles一般作用于测试类上， 用于声明生效的 Spring 配置文件</p>
</li>
<li><p>@Test声明一个方法为测试方法</p>
</li>
<li><p>@Transactional被声明的测试方法的数据会回滚，避免污染测试数据</p>
</li>
</ol>
</li>
</ol>
<h3 id="2-Autowired-Resource-区别"><a href="#2-Autowired-Resource-区别" class="headerlink" title="2.@Autowired  @Resource 区别*"></a>2.@Autowired  @Resource 区别*</h3><p>@Autowired注解由Spring提供，只按照byType注入</p>
<p>@resource注解由J2EE提供，默认按照byName自动注入</p>
<h3 id="3-Controller-ResponseBody-RestController"><a href="#3-Controller-ResponseBody-RestController" class="headerlink" title="3.@Controller+@ResponseBody=@RestController"></a>3.@Controller+@ResponseBody=@RestController</h3><p>@Controller使用它标记的类就是一个SpringMVC Controller 对象，HandlerMapping会扫描使用了该注解的类的方法</p>
<p>单独使用：返回一个视图，属于比较传统的Spring MVC 的应用，前后端不分离</p>
<p>@ResponseBody ：将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p>
<p>@RestController只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<p>@Controller +@ResponseBody= @RestController</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>修饰类或方法，用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>常用请求注解：</p>
<p>GetMapping PostMapping PutMapping DeleteMapping</p>
<ol>
<li><p>get 请求从服务器获取特定资源</p>
</li>
<li><p>post 在服务器上创建一个新的资源</p>
</li>
<li><p>put 更新服务器上的资源（更新整个资源，比如编号12的学生信息）</p>
</li>
<li><p>delete 从服务器删除特定的资源</p>
</li>
</ol>
<p>常用的参数是什么？</p>
<ol>
<li><p>value：指定请求的实际地址</p>
</li>
<li><p>method：指定请求的method类型， GET、POST、PUT、DELETE等</p>
</li>
<li><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html</p>
</li>
<li><p>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p>
</li>
<li><p>params： 指定request中必须包含某些参数值时，才让该方法处理；适用情况：进一步帮助我们缩小请求映射的定位范围，可以让多个处理方法处理到同一个URL 的请求, 而这些请求的参数是不一样的。</p>
</li>
</ol>
<p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring/Spring事务"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/Spring/Spring%E4%BA%8B%E5%8A%A1/"
    >Spring事务</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/Spring/Spring%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time datetime="2021-09-10T04:39:16.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="1-Spring-管理事务的方式"><a href="#1-Spring-管理事务的方式" class="headerlink" title="1. Spring 管理事务的方式"></a>1. Spring 管理事务的方式</h3><p>两种方式：</p>
<ol>
<li><p>编程式事务：在代码中硬编码。(不推荐使用) 通过 TransactionTemplate或者TransactionManager手动管理事务，实际应用中很少使用</p>
</li>
<li><p>声明式事务：在配置文件中配置（推荐使用），又分为两种。代码侵入性最小，实际是通过 AOP 实现（基于@Transactional 的注解方式使用最多）</p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
</li>
</ol>
<h3 id="2-Spring事务管理的3个重要接口"><a href="#2-Spring事务管理的3个重要接口" class="headerlink" title="2. Spring事务管理的3个重要接口*"></a>2. Spring事务管理的3个重要接口*</h3><p>源码如何实现的*</p>
<ol>
<li><p><strong>PlatformTransactionManager</strong>：事务管理器，Spring 事务策略的核心</p>
<ol>
<li><p>Spring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是：PlatformTransactionManager 。通过这个接口，Spring 为各个平台如 JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
</li>
<li><p>接口中定义了三个方法：</p>
</li>
</ol>
<p>① 获得事务TransactionStatus getTransaction(TransactionDefinition var1)</p>
<p>② 提交事务commit</p>
<p>③ 回滚事务rollback</p>
</li>
<li><p><strong>TransactionDefinition</strong>：事务属性(事务隔离级别、传播行为、超时、只读、回滚规则)</p>
<ol>
<li><p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上</p>
</li>
<li><p>事务属性包含了 5 个方面：</p>
</li>
</ol>
<p>① 隔离级别</p>
<p>② 传播行为</p>
<p>③ 回滚规则</p>
<p>④ 是否只读</p>
<p>⑤ 事务超时</p>
</li>
<li><p><strong>TransactionStatus</strong>：事务状态</p>
<ol>
<li><p>该接口定义了一组方法,用来获取或判断事务的相应状态信息</p>
</li>
<li><p>接口中的方法：</p>
</li>
</ol>
<p>① isNewTransaction(); // 是否是新的事物</p>
<p>② setRollbackOnly();  // 设置为只回滚</p>
<p>③ isRollbackOnly(); // 是否为只回滚</p>
<p>④ isCompleted; // 是否已完成</p>
<p>⑤ hasSavepoint(); // 是否有恢复点</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>我们可以把 <strong>PlatformTransactionManager 接口可以被看作是事务上层的管理者，而 TransactionDefinition 和 TransactionStatus 这两个接口可以看作是事物的描述。</strong></p>
<p>PlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p>
<h3 id="3-5种事务隔离级别"><a href="#3-5种事务隔离级别" class="headerlink" title="3. 5种事务隔离级别"></a>3. 5种事务隔离级别</h3><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ol>
<li><p>ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，mysql默认采用的 REPEATABLE_READ 隔离级别， Oracle 默认采用的 READ_COMMITTED 隔离级别</p>
</li>
<li><p>ISOLATION_READ_UNCOMMITTED ：导致脏读、幻读、不可重复读</p>
</li>
<li><p>ISOLATION_READ_COMMITTED：导致幻读、不可重复读</p>
</li>
<li><p>ISOLATION_REPEATABLE_READ：导致幻读</p>
</li>
<li><p>ISOLATION_SERIALIZABLE</p>
</li>
</ol>
<h3 id="4-7种事务传播行为"><a href="#4-7种事务传播行为" class="headerlink" title="4. 7种事务传播行为"></a>4. 7种事务传播行为</h3><p><strong>什么是事务传播行为？</strong></p>
<p>事务传播行为是为了解决<strong>业务层方法之间互相调用的事务问题。</strong></p>
<p>事务传播行为用来描述一个事务方法被另一个事务方法调用时，事务如何传播。（内部方法如何传播）</p>
<p>Spring 在 TransactionDefinition 接口中规定了 7 种类型的事务传播行为。</p>
<ol>
<li><p>PROPAGATION_REQUIRED  (<strong>required</strong>)</p>
<ol>
<li><p>如果外部方法没有开启事务的话，required修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
</li>
<li><p>如果外部方法开启事务，并且被required修饰的话，内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。</p>
</li>
</ol>
</li>
<li><p>PROPAGATION_REQUIRES_NEW  <strong>(requires_new)</strong> </p>
<ol>
<li>不管外部方法是否开启事务，requires_new修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>
</ol>
</li>
<li><p>PROPAGATION_NESTED <strong>(nested)</strong> </p>
<ol>
<li><p>在外部方法未开启事务的情况下，nested修饰的内部方法都会新开启自己的事务 </p>
</li>
<li><p>如果外部方法开启事务的话，nested修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。</p>
</li>
</ol>
</li>
<li><p>PROPAGATION_MANDATORY  <strong>(mandatory)</strong></p>
<ol>
<li>如果当前存在事务，加入该事务；如果当前没有事务，则抛出异常</li>
</ol>
</li>
<li><p>PROPAGATION_SUPPORTS <strong>(supports)</strong> </p>
<ol>
<li>如果当前存在事务，加入该事务；如果当前没有事务，则以非事务的方式继续运行</li>
</ol>
</li>
<li><p>PROPAGATION_NOT_SUPPORTED <strong>(not_supported)</strong> </p>
<ol>
<li>以非事务方式运行，如果当前存在事务，则把当前事务挂起</li>
</ol>
</li>
<li><p>PROPAGATION_NEVER <strong>(never)</strong> </p>
<ol>
<li>以非事务方式运行，如果当前存在事务，则抛出异常</li>
</ol>
</li>
</ol>
<h3 id="5-事务超时"><a href="#5-事务超时" class="headerlink" title="5. 事务超时"></a>5. 事务超时</h3><p>就是指<strong>一个事务所允许执行的最长时间</strong>，如果超过该时间限制但事务还没有完成，则自动回滚事务。在TransactionDefinition中以 int 的值来表示超时时间，其单位是秒，默认值为-1.</p>
<h3 id="6-事务只读属性"><a href="#6-事务只读属性" class="headerlink" title="6. 事务只读属性"></a>6. 事务只读属性</h3><p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p>
<h3 id="7-事务回滚"><a href="#7-事务回滚" class="headerlink" title="7. 事务回滚"></a>7. 事务回滚</h3><p>事务回滚规则定义了<strong>哪些异常会导致事务回滚而哪些不会。</strong></p>
<p>默认情况下，事务只有遇到运行期异常和Error 会导致事务回滚，但是，在遇到检查型异常时不会回滚。</p>
<p>如果你想要回滚你定义的特定的异常类型的话，可以这样：</p>
<p>@Transactional(rollbackFor=MyException.class)</p>
<h3 id="8-Transactional"><a href="#8-Transactional" class="headerlink" title="8. @Transactional*"></a>8. @Transactional*</h3><p><strong>作用范围</strong></p>
<ol>
<li><p>方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。</p>
</li>
<li><p>类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</p>
</li>
<li><p>接口 ：不推荐在接口上使用。</p>
</li>
</ol>
<p><em><strong>常用配置参数</strong></em></p>
<p>@Transactional 的常用配置参数总结（只列5 个我平时比较常用的）：</p>
<ol>
<li><p>propagation：事务的传播行为，默认值为 REQUIRED</p>
</li>
<li><p>isolation    事务的隔离级别，默认值采用 DEFAULT</p>
</li>
<li><p>timeout    事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p>
</li>
<li><p>readOnly     指定事务是否为只读事务，默认值为 false。</p>
</li>
<li><p>rollbackFor用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</p>
</li>
</ol>
<p><em><strong>原理</strong>***</em>（基于AOP）***</p>
<p>@Transactional 的工作机制是基于 AOP 实现的。</p>
<p>如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p>
<h3 id="9-Transactional自调用问题"><a href="#9-Transactional自调用问题" class="headerlink" title="9. @Transactional自调用问题"></a>9. @Transactional自调用问题</h3><p>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有@Transactional 注解的方法的事务会失效。</p>
<p>这是由于Spring AOP代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p>
<p>解决办法：避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</p>
<h3 id="10-为什么数据查询操作还要启用事务支持"><a href="#10-为什么数据查询操作还要启用事务支持" class="headerlink" title="10. 为什么数据查询操作还要启用事务支持"></a>10. 为什么数据查询操作还要启用事务支持</h3><p>一次执行多条查询，需要开启事务；只执行一条，不需要开启。</p>
<p>MySQL 默认对每一个新建立的连接都启用了autocommit模式。在该模式下，每一个发送到 MySQL 服务器的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。也就是说：如果你给方法加上了Transactional注解的话，这个方法执行的所有sql会被放在一个事务中；如果不加Transactional，每条sql会开启一个单独的事务。</p>
<p>因此对于数据查询来说，事务是否启用是分场景分情况来考虑的：</p>
<p>① 如果一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</p>
<p>② 如果一次执行多条查询语句，例如统计查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring/Spring中的设计模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/Spring/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
    >Spring中的设计模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/Spring/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2021-09-10T04:29:47.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<p>以下几种：</p>
<ol>
<li><p>简单工厂：BeanFactory</p>
</li>
<li><p>工厂方法：FactoryBean</p>
</li>
<li><p>单例模式：单例注册表</p>
</li>
<li><p>代理模式：AOP</p>
</li>
<li><p>模板模式</p>
</li>
<li></li>
</ol>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><em><strong>简单工厂</strong></em></h3><p>简单工厂定义：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类</p>
<p>实现： <em><strong>*BeanFactory 接口*</strong></em></p>
<p>是一个管理bean的工厂，有多个实现类。</p>
<p>在<em><strong>*g*</strong>***</em>*etBean(beanName)****方法中，根据传入的参数beanName，动态决定创建哪一个Bean对象。</p>
<p>举例：在ClassPathXmlApplicationContext启动Spring中，使用DefaultListableBeanFactory。</p>
<p>在初始化该BeanFactory时，会加载配置文件，并解析为BeanDefinition，最后将这个beanDefinition注册到BeanFactory中，即将beanName-BeanDefinition放到beanDefinitionMap中。</p>
<p>在初始化单例 bean阶段，会调用getBean(beanName)，先从beanDefinitionMap中获取对应的BeanDefinition，然后进行后面的创建操作。</p>
<p>作用：</p>
<ol>
<li><p>封装创建过程，对调用者透明；适用于创建逻辑比较复杂的，将对象的创建和使用相分离。</p>
</li>
<li><p>代码复用：创建对象的代码可复用</p>
</li>
<li><p>隔离复杂性：调用者无需了解复杂的创建逻辑</p>
</li>
<li><p>职责单一：将创建代码抽离，使原来的函数或类职责更加单一，代码简洁</p>
</li>
</ol>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><em><strong>工厂方法</strong></em></h3><p>工厂方法定义：定义一个创建对象的接口，让其子类决定实例化哪一个工厂类，使对象的创建过程延迟到子类进行。</p>
<p>实现方式：<em><strong>*FactoryBean接口*</strong></em></p>
<p>实现原理：实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是spring会在使用getBean()调用获得该bean时，自动调用该bean的****getObject()****方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p>
<p>例子：典型的例子有spring与mybatis的结合。</p>
<p><img src="/2021/09/10/Spring/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/wps19.png" alt="img"> </p>
<p>sqlSessionFactory因为实现了FactoryBean接口，所以返回的不是 SqlSessionFactoryBean 的实例，而是它的 SqlSessionFactoryBean.getObject() 的返回值。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><em><strong>单例模式</strong></em></h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/twoheads/p/9723543.html">https://www.cnblogs.com/twoheads/p/9723543.html</a></p>
<p>单例模式定义： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>Spring框架对单例的支持是采用****单例注册表****的方式实现。原因：一般的将单例类构造方法定义为private是不可继承的。</p>
<p>singletonCache：Bean实例的缓存，作为单例注册表</p>
<ol>
<li><p>先singletonCache.get(beanName)，如果已经注册过，直接返回，否则下一步</p>
</li>
<li><p>加锁synchronized(this.singletonCache)</p>
</li>
<li><p>再次判断如果singletonCache.get(beanName)=null，创建bean，并将这个bean加入map中</p>
</li>
</ol>
<p>public abstract class AbstractBeanFactory implements ConfigurableBeanFactory{   </p>
<p>  private final Map <em><strong>*singletonCache*</strong></em>=new HashMap();   </p>
<p>  public Object getBean(String name)throws BeansException{   </p>
<p>​    return getBean(name,null,null);   </p>
<p>  }   </p>
<p>…   </p>
<p>  public Object getBean(String name,Class requiredType,Object[] args)</p>
<p>throws BeansException{   </p>
<p>   //处理传入的name  </p>
<p>   String beanName=transformedBeanName(name);   </p>
<p>   Object bean=null;   </p>
<p>   //手工检测单例注册表   </p>
<p>   Object sharedInstance=null;   </p>
<p>   //使用了代码锁定同步块，原理和同步方法相似，但是这种写法效率更高   </p>
<p>   <em><strong>*synchronized(this.singletonCache)*</strong></em>{   </p>
<p>​     sharedInstance=this.singletonCache.get(beanName);   </p>
<p>​    }   </p>
<p>   if(sharedInstance!=null){   </p>
<p>​     …   </p>
<p>​     //返回已缓存Bean实例   </p>
<p>​     bean=getObjectForSharedInstance(name,sharedInstance);   </p>
<p>   }else{   </p>
<p>​    …   </p>
<p>​    //取得Bean的定义   </p>
<p>​    RootBeanDefinition mergedBeanDefinition=getMergedBeanDefinition(beanName,false);   </p>
<p>​     …   </p>
<p>​    //根据Bean定义判断，如果是单例  </p>
<p>​    if(mergedBeanDefinition.isSingleton()){   </p>
<p>​      <em><strong>*synchronized(this.singletonCache)*</strong></em>{   </p>
<p>​      //再次检测单例注册表   </p>
<p>​       sharedInstance=this.singletonCache.get(beanName);   </p>
<p>​       if(sharedInstance==null){   </p>
<p>​        …   </p>
<p>​        try {   </p>
<p>​         //真正创建Bean实例   </p>
<p>​         sharedInstance=createBean(beanName,mergedBeanDefinition,args);   </p>
<p>​         //向单例注册表注册Bean实例   </p>
<p>​          <em><strong>*addSingleton(beanName,sharedInstance);*</strong></em>   </p>
<p>​        }catch (Exception ex) {   </p>
<p>​         …   </p>
<p>​        }finally{   </p>
<p>​         …   </p>
<p>​       }   </p>
<p>​       }   </p>
<p>​      }   </p>
<p>​     bean=getObjectForSharedInstance(name,sharedInstance);   </p>
<p>​    }   </p>
<p>​    //如果是非单例</p>
<p>​    else{   </p>
<p>​     bean=createBean(beanName,mergedBeanDefinition,args);   </p>
<p>​    }   </p>
<p>}   </p>
<p>…   </p>
<p>  return bean;   </p>
<p>}   </p>
<p>}</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><em><strong>代理模式</strong></em></h3><p>定义：在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<p>动态代理：不事先为每个原始类编写代理类，而是在运行时，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p>作用：与大业务代码解耦；保证业务类职责单一</p>
<p>实现方式：AOP底层，就是****动态代理****模式的实现。</p>
<h3 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a><em><strong>模版方法</strong></em></h3><p>定义：在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>
<p>Spring模板方法模式实质：是****模板方法模式和回调模式的结合****，Spring几乎所有的外接扩展都采用这种模式。</p>
<p>JDBC：</p>
<p>具体实现：JDBC的抽象和对Hibernate的集成，都采用了一种理念或者处理方式，那就是模板方法模式与相应的Callback接口相结合。</p>
<p>解决问题：</p>
<ol>
<li><p>复用。把算法中不变的流程抽象到父类的模板方法中，将可变部分留给子类来实现。所有子类复用父类模板方法中定义的流程代码。</p>
</li>
<li><p>扩展。不是指代码的扩展性，而是功能扩展，使框架用户可以不修改框架源码的情况下，定制化框架的功能。</p>
</li>
</ol>
<p>引入回调原因：</p>
<p>JdbcTemplate是抽象类，不能够独立使用，我们每次进行数据访问的时候都要给出一个相应的子类实现,这样肯定不方便，所以就引入了回调。</p>
<p>回调代码</p>
<p>Public interface StatementCallback{</p>
<p>  Object doWithStatement（Statement stmt）;</p>
<p>}</p>
<p>JdbcTemplate方法：</p>
<p>Public class JdbcTemplate {</p>
<p>  Public final Object execute（StatementCallback callback）{</p>
<p>​    Connection con=null;</p>
<p>​    Statement stmt=null;</p>
<p>​    try{</p>
<p>​      con=getConnection（）;</p>
<p>​      stmt=con.createStatement（）;</p>
<p>​      Object retValue=callback.doWithStatement（stmt）;</p>
<p>​      return retValue;</p>
<p>​    }catch（SQLException e）{</p>
<p>​      …</p>
<p>​    }finally{</p>
<p>​      closeStatement（stmt）;</p>
<p>​      releaseConnection（con）;</p>
<p>​    }</p>
<p>  }</p>
<p>  …//其它方法定义</p>
<p>}</p>
<p>Jdbc使用方法如下：</p>
<p>  JdbcTemplate jdbcTemplate=…;</p>
<p>  final String sql=…;</p>
<p>  StatementCallback callback=new StatementCallback(){</p>
<p>  public Object=doWithStatement(Statement stmt){</p>
<p>​    return …;</p>
<pre><code>    &#125;
</code></pre>
<p>  }</p>
<p>jdbcTemplate.execute(callback);</p>
<p>模板模式：基于继承实现，子类重写父类方法，是一种类之间的关系。</p>
<p>回调：基于组合关系实现，把一个对象传递给另一个对象，是一种对象之间的关系。组合优于继承。更加灵活。优势如下：</p>
<ol>
<li><p>类只能单继承</p>
</li>
<li><p>回调可以使用匿名类创建回调函数</p>
</li>
<li><p>某个类中有多个模板方法，每个方法都有对应的抽象方法，如果我们只用到一个模板方法，子类必须实现所有的抽象方法。回调更加灵活，只需要将需要的模板方法注入回调对象即可。</p>
</li>
</ol>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><em><strong>观察者模式</strong></em></h3><p>发布订阅模式</p>
<p>定义：在对象之间定义一个一对多的依赖，当一个对象（被观察者）状态改变时，所有依赖的对象（观察者）都会自动收到通知。</p>
<p>将观察者和被观察者的代码解耦。</p>
<p>事件的发布者（ApplicationEventPublisher）</p>
<p>事件类型（ApplicationEvent）</p>
<p>事件广播器（ApplicationEventMulticaster）：该类是整个观察者的核心，接收发布者的事件推送并选择适当的事件监听器进行事件的准确分发。</p>
<p>事件监听器（ApplicationListener）：该组件为观察者对象，由用户自行实现其void onApplicationEvent(E event)方法，定制业务逻辑。</p>
<p>导出项目中基于spring观察者模式的应用：</p>
<p>需求：在application初始化完成后，将事件类型和事件处理器映射存储到map中。方便Consumer中根据EventType调用不同的EventHandler，比如导出事件调用ExportHandler。</p>
<p>这样设计的作用：可扩展。</p>
<p>事件处理器接口EventHandler</p>
<p>导出事件实现EventHandler，定义为：ExportHandler</p>
<p>导入事件实现EventHandler，定义为：ImportHandler</p>
<p>具体设计：</p>
<ol>
<li><p>在Consumer类实现ApplicationListener<ApplicationReadyEvent>接口，并实现其onApplicationEvent方法，在完成ApplicationReadyEvent后，触发onApplicationEvent方法中的自定义的逻辑</ApplicationReadyEvent></p>
</li>
<li><p>Consumer类实现ApplicationContextAware，用来得到applicationContext，从中可获得EventHandler的所有bean</p>
</li>
<li><p>在onApplicationEvent中，从applicationContext中获取所有EventHandler的bean，将type和bean的映射存储到map中</p>
</li>
</ol>
<p>代码：</p>
<p>@Component</p>
<p>public class EventConsumer implements ApplicationContextAware, ApplicationListener<ApplicationReadyEvent> {</ApplicationReadyEvent></p>
<p>  private ApplicationContext applicationContext;</p>
<p>  private static final Map&lt;EventType, List<EventHandler>&gt; config = new HashMap&lt;&gt;();</EventHandler></p>
<p>  @Override</p>
<p>  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {</p>
<p>​    this.applicationContext = applicationContext;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) {</p>
<p>​    //初始化所有的事件</p>
<p>​    //获取所有EventHandler的实现类</p>
<p>​    Map&lt;String, EventHandler&gt; beans = applicationContext.getBeansOfType(EventHandler.class);</p>
<p>​    for (Map.Entry&lt;String, EventHandler&gt; entry : beans.entrySet()) {</p>
<p>​      List<EventType> types = entry.getValue().getSupportEventTypes();</EventType></p>
<p>​      for (EventType type : types) {</p>
<p>​        if(!config.containsKey(type)){</p>
<p>​          config.put(type, new ArrayList&lt;&gt;());</p>
<p>​        }</p>
<p>​        //一种事件类型对应多个处理类</p>
<p>​        config.get(type).add(entry.getValue());</p>
<p>​      }</p>
<p>​    }</p>
<p>}</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><em><strong>适配器模式</strong></em></h3><p>实现方式：SpringMVC中的适配器HandlerAdatper</p>
<p>实现原理：HandlerAdatper根据Handler规则找到对应的Handler，并让其执行。Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样再扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</p>
<p>实现意义：HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。</p>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a><em><strong>装饰器模式</strong></em></h3><p>定义：</p>
<ol>
<li><p>使用组合代替继承</p>
</li>
<li><p>装饰器类是对原始类功能相关的增强</p>
</li>
<li><p>装饰器类和原始类继承同样的父亲，这样可以对原始类嵌套多个装饰器类。</p>
</li>
</ol>
<p>实现方式：Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<p>实质：动态地给一个对象添加一些额外的职责。</p>
<p>摘自：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/114244039">https://zhuanlan.zhihu.com/p/114244039</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring/Spring容器的启动流程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/Spring/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"
    >Spring容器的启动流程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/Spring/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="article-date">
  <time datetime="2021-09-10T04:24:34.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="S-pring-容器的启动流程"><a href="#S-pring-容器的启动流程" class="headerlink" title="S***pring***容器的启动流程"></a><em><strong>S</strong>***</em>pring***<em><strong>容器的启动流程</strong></em></h3><p>spring容器的启动方式有很多种： </p>
<ol>
<li><p>xml的方式，入口为ClassPathXmlApplicationContext（从类路径中加载xml文件）或FileSystemXmlApplicationContext（从指定文件地址加载xml文件）</p>
</li>
<li><p>Java Config，基于注解中的方式，入口为AnnotationConfigApplicationContext</p>
</li>
</ol>
<h3 id="xml方式（源码分析）"><a href="#xml方式（源码分析）" class="headerlink" title="xml方式（源码分析）"></a>xml方式（源码分析）</h3><p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
<p>整个流程的大致过程：初始化BeanFactory；加载xml配置文件；将beanDefinition注册到beanFactory；创建bean（创建bean实例；属性填充；各种回调）</p>
<p>启动Spring容器，入口：</p>
<p>public static void main(String[] args) {</p>
<p>  ApplicationContext context </p>
<p>= new <em><strong>*ClassPathXmlApplicationContext*</strong></em>(“classpath:applicationfile.xml”);</p>
<p>}</p>
<p>maven中添加spring-context依赖，spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>
<p>从ClassPathXmlApplicationContext构造方法开始：</p>
<ol>
<li><p>处理文件路径</p>
</li>
<li><p>refresh()</p>
</li>
</ol>
<p>refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作</p>
<ol>
<li><p>prepareRefresh() 做一些准备工作，比如记录下容器的启动时间、标记“已启动”状态、检验xml配置文件</p>
</li>
<li><p>初始化BeanFactory，加载配置文件，并解析为BeanDefinition，最后将这个beanDefinition注册到BeanFactory中，这一步并不会生成Bean实例。ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</p>
<p><strong>1)</strong> <em><strong>初始化</strong>***</em>BeanFactory***，DefaultListableBeanFactory，这基本上是最厉害的BeanFactory</p>
<ol start="2">
<li>设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用customizeBeanFactory();</li>
</ol>
<p><strong>3)</strong> <strong>加载</strong>loadBeanDefinitions();通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean</p>
<p><strong>4)</strong> <em><strong>解析</strong></em>parseBeanDefinitions(root, this.delegate)核心解析方法</p>
<p><strong>5)</strong> <em><strong>注册</strong></em>registerBeanDefinition(String beanName, BeanDefinition beanDefinition)注册Bean，将beanName-BeanDefinition放到beanDefinitionMap中；把beanName添加到ArrayList&lt;&gt; beanDefinitionNames中</p>
<ol start="6">
<li>发送注册事件</li>
</ol>
</li>
<li><p>准备Bean容器prepareBeanFactory(beanFactory); </p>
<ol>
<li><p>设置 BeanFactory 的类加载器</p>
</li>
<li><p>添加****ApplicationContextAwareProcessor*<em><strong>，如果bean在初始化时实现了</strong></em>*Aware接口****，这个processor负责回调，回调ApplicationContextAware、EnvironmentAware、ResourceLoaderAware 等（导出项目中，EventConsumer实现了ApplicationContextAware接口，来获取ApplicationContext，从中获取EventHandler中的所有bean）</p>
</li>
<li><p>添加ApplicationListenerDetector，用来注册监听事件，如果bean实例化后，是ApplicationListener 的子类，那么将其添加到 listener 列表中</p>
</li>
<li><p>注册几个有用的bean：environment、systemProperties、systemEnvironment</p>
</li>
</ol>
</li>
<li><p>postProcessBeanFactory(beanFactory); 提供给子类的扩展点，此时所有的 Bean 都加载、注册完成了，但是都还没有初始化，子类可以在这里定义自己的BeanFactoryPostProcessor实现类</p>
</li>
<li><p>调用 <em><strong>*BeanFactoryPostProcessor*</strong></em> 各个实现类的 postProcessBeanFactory() 方法invokeBeanFactoryPostProcessors(beanFactory); </p>
</li>
<li><p>注册自定义的<em><strong>*BeanPostProcessor*</strong></em> ，registerBeanPostProcessors(beanFactory);，这个接口包含两个方法，分别在Bean初始化前、后执行</p>
</li>
<li><p>初始化国际化initMessageSource();初始化当前 ApplicationContext 的 MessageSource </p>
</li>
<li><p>初始化当前 ApplicationContext 的事件广播器initApplicationEventMulticaster();</p>
</li>
<li><p>onRefresh();典型的模板方法(钩子方法)，具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</p>
</li>
<li><p>registerListeners();注册事件监听器，监听器需要实现 ApplicationListener 接口</p>
</li>
</ol>
<p><strong>11.</strong> <em><strong>*初始化所有的*</strong></em> <em><strong>*singleton bean*</strong></em> ：finishBeanFactoryInitialization(beanFactory); </p>
<p>​    </p>
<ol start="12">
<li>finishRefresh();广播事件，ApplicationContext 初始化完成</li>
</ol>
<p><em><strong>*createBeanInstance*</strong></em>(beanName, mbd, args)</p>
<p>作用：实例化指定的类</p>
<ol>
<li><p>确保已经加载了此 class</p>
</li>
<li><p>校验一下这个类的访问权限</p>
</li>
<li><p>如果是FactoryBean，则采用工厂方法实例化；否则继续</p>
</li>
<li><p>根据args，调用无参构造函数、或者有参构造函数创建实例</p>
</li>
</ol>
<p><em><strong>*initializeBean*</strong></em>(beanName, exposedObject, mbd);</p>
<p>处理各种回调；init方法</p>
<ol>
<li><p>如果 bean 实现了 <em><strong>BeanNameAware</strong></em>、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</p>
</li>
<li><p>**** <em><strong>BeanPostProcessor</strong></em> 的 postProcessBeforeInitialization 回调</p>
</li>
<li><p>处理 bean 中定义的 ****init-method****，或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</p>
</li>
</ol>
<p><strong>4.</strong> <em><strong>BeanPostProcessor</strong></em> 的 postProcessAfterInitialization 回调</p>
<h3 id="Java-Config方式"><a href="#Java-Config方式" class="headerlink" title="Java Config方式"></a>Java Config方式</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35190492/article/details/110383213">https://blog.csdn.net/qq_35190492/article/details/110383213</a></p>
<p>如何设计一个IOC容器：</p>
<ol>
<li><p>提供入口AnnotationConfigApplicationContext，供用户使用，然后初始化一些工具组件，如下：</p>
</li>
<li><p>bean工厂（DefaultListableBeanFactory），用来生成bean对象</p>
</li>
<li><p>注解配置读取器（AnnotatedBeanDefinitionReader），对加了特定注解比如@Service、@Repository的类读取转化为BeanDefinition对象</p>
</li>
<li><p>路径扫描器（ClassPathBeanDefinitionScanner），对用户指定的包目录进行扫描查找 bean 对象</p>
</li>
<li></li>
</ol>
<p><img src="/2021/09/10/Spring/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/wps18.png" alt="img"> </p>
<p>第一步：new AnnotationConfigApplicationContext() 创建Spring容器，有参的构造方法如下，分为三步：</p>
<ol>
<li><p>通过this()调用无参构造方法，分为三步</p>
<ol>
<li><p>先执行父类GenericApplicationContext的初始化方法，实例化一个DefaultListableBeanFactory</p>
</li>
<li><p>实例化AnnotatedBeanDefinitionReader，registerAnnotationConfigProcessors()</p>
</li>
</ol>
<p>① 向容器中添加2个beanFactory后置处理器</p>
<ol>
<li><p>ConfigurationClassPostProcessor: 一个 beanFactory 后置处理器，用来完成 bean 的扫描与注入工作</p>
</li>
<li><p>EventListenerMethodProcessor</p>
</li>
</ol>
<p>② 向容器中添加2个bean后置处理器</p>
<ol>
<li><p>AutowiredAnnotationBeanPostProcessor：一个 bean 后置处理器，用来完成 @AutoWired 自动注入</p>
</li>
<li><p>CommonAnnotationBeanPostProcessor</p>
</li>
</ol>
<p>③ 向容器中添加普通组件：DefaultEventListenerFactory</p>
<ol start="3">
<li>实例化ClassPathBeanDefinitionScanner</li>
</ol>
</li>
<li><p>调用register(componentClasses); 注册传入的配置类，可以是多个类。最终调用doRegisterBean()，用来解析用户传入的 Spring 配置类，解析成一个 BeanDefinition 然后注册到容器中。</p>
</li>
</ol>
<p>\3. 调用refresh() 容器刷新，这是spring的核心方法</p>
<p>刷新流程</p>
<ol>
<li><p>prepareRefresh() 刷新前预处理</p>
</li>
<li><p>obtainFreashBeanFactory（）获取beanFactory，前面已经初始化过</p>
</li>
<li><p>prepareBeanFactory() 预处理beanFactory，向容器中添加一些组件</p>
</li>
<li><p>postProcessBeanFactory() 子类重写这个方法，可以在beanFactor</p>
</li>
<li><p>执行BeanFactoryPostProcessor方法</p>
</li>
<li><p>向容器中注册bean后置处理器</p>
</li>
<li><p>初始化MessageSource组件：国际化、消息绑定与解析</p>
</li>
<li><p>初始化事件派发器，在注册监听时会用到</p>
</li>
<li><p>onRefresh() 留给子类重写，在容器刷新时，可以自定义逻辑，web场景下会用到</p>
</li>
<li><p>registerListeners() 注册监听器，派发之前产生的一些事件</p>
</li>
<li><p>初始化所有bean</p>
</li>
<li><p>finishRefresh() 刷新完成，发布容器</p>
</li>
</ol>
<p>public AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses) {</p>
<p>​        this();</p>
<p>​        register(componentClasses);</p>
<p>​        refresh();</p>
<p>​    }</p>
<h3 id="测试demo"><a href="#测试demo" class="headerlink" title="测试demo"></a>测试demo</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/52b988e02c37">https://www.jianshu.com/p/52b988e02c37</a></p>
<p><em><strong>*配置*</strong></em></p>
<p><em><strong>*XML方式：*</strong></em></p>
<p>&lt;context:component-scan base-package=”com.me.xml”/&gt;</p>
<p>@Component</p>
<p>public class OneBean {</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>  ApplicationContext context </p>
<p>= new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>
<p>  OneBean bean = context.getBean(“oneBean”,OneBean.class);</p>
<p>  System.out.println(bean);</p>
<p>}</p>
<p><em><strong>*Java*</strong></em> <em><strong>*Config*</strong></em></p>
<p>@Configuration：标注了该注解的类是一个Spring的配置类,等价于原先的applicationContext.xml</p>
<p>@ComponentScan ：启动该注解，表明开启Spring的注解自动扫描 , 默认情况下,扫描当前类所在包及其子包</p>
<p>代码如下：</p>
<p>@Configuration </p>
<p>@ComponentScan </p>
<p>public class Config {</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>  ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);</p>
<p>  OneBean oneBean = context.getBean(OneBean.class);</p>
<p>  System.out.println(oneBean);</p>
<p>}</p>
<p>创建bean</p>
<bean id="oneBena" class="com.me.xml.OneBean">

<p>@Configuration</p>
<p>public class Config {</p>
<p>  @Bean // 表明这是一个Spring 管理的bean</p>
<p>  public OneBean oneBean() {</p>
<p>​    // 显然,这个Bean的CLass 是OneBean.class</p>
<p>​    // 在spring 中,bean的 id 是不能重复的,而现在使用java config来代替xml配置</p>
<p>​    // 在java config 方法名就是这个bean的id</p>
<p>​    return new OneBean();</p>
<p>  }</p>
<p>}</p>
</bean> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring/Spring Bean的生命周期"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
    >Spring Bean的生命周期</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time datetime="2021-09-10T04:20:53.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="1-Spring创建bean的流程图"><a href="#1-Spring创建bean的流程图" class="headerlink" title="1. Spring创建bean的流程图"></a>1. <em>Spring创建bean的流程图</em></h3><p><img src="/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/wps15.png" alt="img"> </p>
<h3 id="2-Spring-Bean的生命周期"><a href="#2-Spring-Bean的生命周期" class="headerlink" title="2. Spring Bean的生命周期"></a>2. Spring Bean的生命周期</h3><p>四个阶段（在核心方法doCreateBean中）：</p>
<ol>
<li><p>实例化Instantiation，创建bean实例</p>
</li>
<li><p>属性赋值Populate</p>
</li>
<li><p>初始化Initialization，执行init方法</p>
</li>
<li><p>销毁Destruction</p>
</li>
</ol>
<p>初始化和销毁是用户能自定义扩展的两个阶段。</p>
<p>加入扩展点的流程图：</p>
<p><img src="/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/wps16.jpg" alt="img"> </p>
<p>扩展点：</p>
<ol>
<li><p>Bean自身的方法，比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，对应这四个阶段</p>
</li>
<li><p>容器级的方法。主要是后处理器方法，比如下图的 InstantiationAwareBeanPostProcessor、BeanPostProcessor 接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用</p>
</li>
<li><p>Bean 级生命周期方法。比如 BeanNameAware、BeanFactoryAware、ApplicationContextAware、InitializingBean、DisposableBean 等方法，这些方法只对当前 Bean 生效。</p>
</li>
</ol>
<p><img src="/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/wps17.jpg" alt="img"> </p>
<p>摘自：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/118500805">https://blog.csdn.net/riemann_/article/details/118500805</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring/Bean相关接口"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/Spring/Bean%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/"
    >Bean相关接口</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/Spring/Bean%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time datetime="2021-09-10T04:17:53.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="1-BeanFactoryPostProcessor"><a href="#1-BeanFactoryPostProcessor" class="headerlink" title="1. BeanFactoryPostProcessor"></a>1. <em><strong>BeanFactoryPostProcessor</strong></em></h3><p>接口，只有一个方法postProcessBeanFactory</p>
<p>如果实现了此接口，那么会在所有的 Bean 都加载、注册到BeanFactory，但是都还没有初始化时，Spring 会负责调用里面的 postProcessBeanFactory 方法</p>
<p>@FunctionalInterface</p>
<p>public interface BeanFactoryPostProcessor {</p>
<p>  void <em><strong>*postProcessBeanFactory*</strong></em>(ConfigurableListableBeanFactory var1) </p>
<p>throws BeansException;</p>
<p>}</p>
<h3 id="2-BeanPostProcessor"><a href="#2-BeanPostProcessor" class="headerlink" title="2. BeanPostProcessor"></a>2. <em><strong>BeanPostProcessor</strong></em></h3><p>此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</p>
<p>分别在 Bean 初始化之前和初始化之后得到执行</p>
<p>public interface BeanPostProcessor {</p>
<p>  @Nullable</p>
<p>  default Object <em><strong>*postProcessBeforeInitialization*</strong></em>(Object bean, String beanName) throws BeansException {</p>
<p>​    return bean;</p>
<p>  }</p>
<p>  @Nullable</p>
<p>  default Object <em><strong>*postProcessAfterInitialization*</strong></em>(Object bean, String beanName) throws BeansException {</p>
<p>​    return bean;</p>
<p>  }</p>
<p>}</p>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a><em><strong>BeanDefinition</strong></em></h3><p>自己定义的各个 Bean 会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p>
<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>
<p>Bean是什么？Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p>
<p>public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {</p>
<p>  // 我们可以看到，默认只提供 sington 和 prototype 两种，</p>
<p>  // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</p>
<p>  // 不过，它们属于基于 web 的扩展。</p>
<p>  String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</p>
<p>  String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</p>
<p>  // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</p>
<p>  // 一句话就是：继承父 Bean 的配置信息而已</p>
<p>  void setParentName(String parentName);</p>
<p>  // 获取父 Bean</p>
<p>  String getParentName();</p>
<p>  // 设置 Bean 的类名称，将来是要通过反射来生成实例的</p>
<p>  void setBeanClassName(String beanClassName);</p>
<p>  // 获取 Bean 的类名称</p>
<p>  String getBeanClassName();</p>
<p>  // 设置 bean 的 scope</p>
<p>  void setScope(String scope);</p>
<p>  // 设置是否懒加载</p>
<p>  void setLazyInit(boolean lazyInit);</p>
<p>  // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</p>
<p>  // 是 depends-on=”” 属性设置的值。</p>
<p>  void setDependsOn(String… dependsOn);</p>
<p>  // 返回该 Bean 的所有依赖</p>
<p>  String[] getDependsOn();</p>
<p>  // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</p>
<p>  // 如果根据名称注入，即使这边设置了 false，也是可以的</p>
<p>  void setAutowireCandidate(boolean autowireCandidate);</p>
<p>  // 该 Bean 是否可以注入到其他 Bean 中</p>
<p>  boolean isAutowireCandidate();</p>
<p>  // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</p>
<p>  void setPrimary(boolean primary);</p>
<p>  // 是否是 primary 的</p>
<p>  boolean isPrimary();</p>
<p>  // 如果该 Bean 采用工厂方法生成，指定工厂名称。即有些实例不是用反射生成的，而是用工厂模式生成的</p>
<p>  void setFactoryBeanName(String factoryBeanName);</p>
<p>  // 获取工厂名称</p>
<p>  String getFactoryBeanName();</p>
<p>  // 指定工厂类中的 工厂方法名称</p>
<p>  void setFactoryMethodName(String factoryMethodName);</p>
<p>  // 获取工厂类中的 工厂方法名称</p>
<p>  String getFactoryMethodName();</p>
<p>  // 构造器参数</p>
<p>  ConstructorArgumentValues getConstructorArgumentValues();</p>
<p>  // Bean 中的属性值，后面给 bean 注入属性值的时候会说到</p>
<p>  MutablePropertyValues getPropertyValues();</p>
<p>  // 是否 singleton</p>
<p>  boolean isSingleton();</p>
<p>  // 是否 prototype</p>
<p>  boolean isPrototype();</p>
<p>  // 如果这个 Bean 是被设置为 abstract，那么不能实例化，</p>
<p>  // 常用于作为 父bean 用于继承，其实也很少用……</p>
<p>  boolean isAbstract();</p>
<p>  int getRole();</p>
<p>  String getDescription();</p>
<p>  String getResourceDescription();</p>
<p>  BeanDefinition getOriginatingBeanDefinition();</p>
<p>}</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> fyr
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/my.jpg" alt="Fanfan"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/life">生活</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>