<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fanfan</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-10T06:35:35.053Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>fyr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>其它知识点</title>
    <link href="http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-09-10T05:57:16.000Z</published>
    <updated>2021-09-10T06:35:35.053Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="应用层常见协议"><a href="#应用层常见协议" class="headerlink" title="应用层常见协议"></a>应用层常见协议</h2><ol><li><p>HTTP：超文本传输协议，端口号：80</p></li><li><p>FTP：文件传输协议，端口号：21</p></li><li><p>DNS：域名系统 (Domain Name System)，端口号：53</p></li><li><p>SMTP（SimpleMailTransferProtocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，端口号：25</p></li><li><p>Telnet协议：是Internet远程登陆服务的标准协议和主要方式，端口号：23</p><span id="more"></span></li></ol><h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a><em><strong>ARP</strong></em> <em><strong>协议</strong></em></h2><p>通过 IP 地址向 MAC 地址的转换，网络层协议</p><p>工作过程：</p><p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p><p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p><p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><p>\1. A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址</p><p>\2. 如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址。将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</p><p>\3. 主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p><p>\4. 主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</p><p>\5. 当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p><h2 id="NAT-协议"><a href="#NAT-协议" class="headerlink" title="NAT 协议"></a><em><strong>NAT</strong></em> <em><strong>协议</strong></em></h2><p>NAT协议（Network Address Translation），网络地址转换协议。</p><p>作用：将局域网中的IP地址(私有地址)映射到公网的IP（全局地址）。</p><p>NAT功能通常运行在网关设备上，NAT路由器会维护一张NAT转化表。</p><p>工作过程：</p><p>\1. 主机H想访问Web服务器，首先会发送数据包到NAT路由器；</p><p>\2. NAT路由器在NAT转换表上记录主机H的内网地址和端口，并为它分配一个全局地址和全局端口与之映射，按照目的地址发送给服务器。</p><p>\3. 服务器回应给NAT路由器后，路由器查询NAT转换表，将对应关系转换回去发送给主机H。</p><h2 id="公网私网地址"><a href="#公网私网地址" class="headerlink" title="公网私网地址"></a><em><strong>公网私网地址</strong></em></h2><p>在IPv4地址协议中预留了3个IP地址段，作为私有地址，供组织机构内部使用。</p><p>这三个地址段分别位于A、B、C三类地址内：</p><p>A类地址：10.0.0.0–10.255.255.255</p><p>B类地址：172.16.0.0–172.31.255.255 </p><p>C类地址：192.168.0.0–192.168.255.255</p><h2 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI URL"></a><em><strong>URI</strong></em> <em><strong>URL</strong></em></h2><p>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</p><p>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p><p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h2 id="socket可以TCP和UDP共用吗"><a href="#socket可以TCP和UDP共用吗" class="headerlink" title="*socket可以TCP和UDP共用吗*"></a><em><strong>*socket可以TCP和UDP共用吗*</strong></em></h2><p>可以</p><p>linux是以协议、ip、端口来绑定端口的，所以不同协议相同的ip和端口也是可以绑定成功的</p><h2 id="为什么DNS即使用TCP又使用UDP"><a href="#为什么DNS即使用TCP又使用UDP" class="headerlink" title="*为什么DNS即使用TCP又使用UDP**"></a><em><strong>*为什么DNS即使用TCP又使用UDP**</strong></em></h2><p>大多数情况下，DNS解析请求和响应都很小，使用UDP协议更加高效，虽然没有TCP可靠，但是速度快，消耗的系统资源更少，非常适合少量数据包的传输。</p><p>一些DNS事务，比如区域传输或其他附加查询，可能会产生大于512字节的数据包，因此使用TCP更加可靠，使用TCP会减少丢包和重新发包的情况，因此更加可靠与高效。</p><p>DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；</p><p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。</p><p>区域传输是DNS的事务，对准确性要求比较高，而且会产生大于512字节的数据包，因此使用TCP协议。</p><p>为什么既使用TCP又使用UDP？</p><p>UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。</p><p>区域传送时使用TCP，原因如下：</p><p>\1. 数据同步传送的数据量比一个请求和应答的数据量要多得多，比如区域传送</p><p>\2. TCP是一种可靠的连接，保证了数据的准确性</p><p>域名解析时使用UDP协议</p><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p><h2 id="进程可以共用多个端口号吗"><a href="#进程可以共用多个端口号吗" class="headerlink" title="*进程可以共用多个端口号吗**"></a><em><strong>*进程可以共用多个端口号吗**</strong></em></h2><p>可以</p><p>数据接收时时根据五元组{传输协议，源IP，目的IP，源端口，目的端口}判断接受者的。</p><p>TCP、UDP可以同时绑定一个端口8888，但是一个端口在同一时刻不可以被TCP或者UDP绑定2次。</p><p>TCP和UDP传输协议监听同一个端口后，接收数据互不影响，不冲突。因为数据接收时时根据五元组{传输协议，源IP，目的IP，源端口，目的端口}判断接受者的。</p><p>端口号可以用来标识同一个主机上通信的不同应用程序，端口号+IP地址就可以组成一个套接字，用来标识一个进程。</p><h2 id="MAC-IP-TCP-UDP-头＊"><a href="#MAC-IP-TCP-UDP-头＊" class="headerlink" title="*MAC* *IP*　*TCP* *UDP*****头＊****"></a><em><strong>*MAC*</strong></em> <em><strong>*IP*</strong></em>　<em><strong>*TCP*</strong></em> <em><strong>*UDP*</strong>***</em>*头＊****</h2><p><em><strong>*MAC：1*</strong>***</em>*4B****</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps48.jpg" alt="img"> </p><p><em><strong>*IP*</strong>***</em>*：2*<strong><strong><strong>*0B+*</strong></strong></strong>*可选字段****</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps49.jpg" alt="img"> </p><p><em><strong>*TCP：2*</strong>***</em>*0*<strong><strong><strong>*B*</strong></strong></strong>*+****<em><strong>*可变长度*</strong></em></p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps50.jpg" alt="img"> </p><p><em><strong>*UDP头：*</strong>***</em>*8****<em><strong>*B*</strong></em></p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps51.jpg" alt="img"> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;应用层常见协议&quot;&gt;&lt;a href=&quot;#应用层常见协议&quot; class=&quot;headerlink&quot; title=&quot;应用层常见协议&quot;&gt;&lt;/a&gt;应用层常见协议&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HTTP：超文本传输协议，端口号：80&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FTP：文件传输协议，端口号：21&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DNS：域名系统 (Domain Name System)，端口号：53&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SMTP（SimpleMailTransferProtocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，端口号：25&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Telnet协议：是Internet远程登陆服务的标准协议和主要方式，端口号：23&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>cookie、session、token</title>
    <link href="http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/"/>
    <id>http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/</id>
    <published>2021-09-10T05:56:16.000Z</published>
    <updated>2021-09-10T06:35:40.763Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>存储在浏览器中</p><p>浏览器实现的一种数据存储功能</p><p>工作过程：cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到本地，下一次请求同一网站时会把该cookie发送给服务器，服务器可以通过cookie中携带的数据区分不同的用户。</p> <span id="more"></span><p>cookie存在客户端上的，浏览器：</p><p>加入了一些限制确保cookie不会被恶意使用</p><p>每个域的cookie数量是有限的，保证cookie不会占据太多磁盘空间</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>存储在服务器上</p><p>作用：服务器用来区分请求来自谁</p><p>server给每个client分配不同的“身份标识”， client每次向server发请求的时候，都带上这个“身份标识”，server就知道这个请求来自于谁了。</p><p>对于浏览器客户端，一般采用 cookie 的方式存储session</p><p>缺点：服务器端保存占用内存</p><p>工作过程：</p><p>\1. 浏览器端第一次发送请求到server，server创建一个Session，同时会创建一个特殊的****Cookie*<em><strong>（name为</strong></em>*JSESSIONID****的固定值，value为session对象的ID），然后将该Cookie发送至client</p><p>\2. client再发送请求到server时，浏览器端就会携带该JSESSIONID的Cookie对象</p><p>\3. server端根据JSESSIONID这个Cookie的value(sessionId),去查询Session对象，从而区分不同用户</p><h3 id="cookie-session-区别"><a href="#cookie-session-区别" class="headerlink" title="cookie session 区别**"></a>cookie session 区别**</h3><p>cookie：浏览器实现的一种数据存储功能</p><p>session：服务器用来区分请求来自谁。有很多种实现方法，浏览器客户端一般用cookie来实现。</p><p>具体区别：</p><p><strong>1.</strong> ****存放位置****：cookie在客户的浏览器上，session在服务器上</p><p><strong>2.</strong> ****安全性****：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗； session安全</p><p><strong>3.</strong> ****服务器内存占用****：session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能； cookie存在在客户端，不存在这个问题</p><p><strong>4.</strong> ****大小限制****：一个站点在客户端存放的cookie不能超过3K</p><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token令牌</p><p>存储在客户端</p><p>应用：在Web领域基于Token的身份验证</p><p>解决的问题：session保存在服务器端，会有很大的压力。token的目的就是让客户端保存数据，并且客户端不能伪造数据信息。</p><p><em><strong>*特点：*</strong></em></p><p>\1. 无状态、可扩展</p><p>\2. 支持移动设备</p><p>\3. 跨程序调用</p><p>\4. 安全</p><p>****缺点：****Token 中的数据是明文保存的（虽然会用Base64做下编码， 但那不是加密），不能在其中保存像密码这样的敏感信息</p><p>****优点：****server不保存session对象， 只是生成token ，然后验证token，即用CPU计算时间获取了session 存储空间</p><p><em><strong>*工作流程：*</strong></em></p><p>\1. 用户A登录系统后， 服务器给他发一个令牌(token)， 里边包含了A的用户数据</p><p>\2. 为了保证安全，对数据做了签名。比如使用HMAC-SHA256 算法，加上一个server才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。这个token保存在客户端，server不保存。</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/wps46.jpg" alt="img"> </p><p>\3. 下一次A再次通过Http 请求访问服务器时，在HTTP请求头中带上这个token </p><p>\4. server收到token后，再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/wps47.jpg" alt="img"> </p><h3 id="token如何使用"><a href="#token如何使用" class="headerlink" title="token如何使用"></a>token如何使用</h3><p>将登陆信息等重要信息存放为session</p><p>其他信息如果需要保留，可以放在cookie中</p><h3 id="多个服务器如何共享session"><a href="#多个服务器如何共享session" class="headerlink" title="多个服务器如何共享session"></a>多个服务器如何共享session</h3><p>通过redis共享session，把session放在内存中，并可以实现持久化和主从同步。</p><p>其他方案的问题：</p><p>\1. 使用专门的mysql服务器存储所有的session信息，用户的请求会先在这个数据库中check一下session的情况</p><ol><li>缺点：依赖性太强，当mysql出问题时会影响整个系统</li></ol><p>\2. 把session信息写在客户端cookie中。当访问服务器A时，登录成功后，将产生的session信息存放在cookie当中，发给客户端。当请求分发到服务器B时，B先判断自己是否存储了这个session的信息，如果没有，再去客户端的cookie中获取这个session信息，并把这个信息存储到B</p><ol><li>缺点：cookie安全性不高，容易伪造；如果客户端禁止使用cookie可能造成无法共享session</li></ol><p>\3. 通过服务器之间的数据同步session，使用一台服务器作为登录服务器，当用户成功后，会将session写到当前服务器上，通过脚本或守护进程将session信息同步到其他服务器</p><ol><li>缺点：速度慢，同步session有延迟；单向同步时，整个系统不能正常运行</li></ol><p>\4. 通过memcache同步session，把web服务器的内存组合起来，成为一个内存池，所有服务器产生的session都存放在这个内存池中</p><ol><li><p>优点：不会加大数据库的负担，安全性也比cookie方式高，并且把session存在内存中，比文件中读取快</p></li><li><p>缺点：memcache把内存分成存储块，这样memcache可能会产生内存碎片；如果内存块不足，可能产生内存溢出</p></li></ol><p>实际中，使用memcache和redis。</p><h3 id="session如何创建"><a href="#session如何创建" class="headerlink" title="session如何创建"></a>session如何创建</h3><p>sessionid第一次产生是在某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建。</p><p>tomcat的ManagerBase类提供创建sessionid的方法：随机数+时间+jvmid；</p><h3 id="session攻击与防御"><a href="#session攻击与防御" class="headerlink" title="session攻击与防御"></a>session攻击与防御</h3><p>基于session的攻击有很多种方式。大部分的手段都是首先通过捕获合法用户的session, 然后冒充该用户来访问系统。攻击者至少可以通过以下三种方式来获取一个有效的session标识符：预测、捕获（劫持）、固定。</p><p>防御方法：</p><p>\1. 在登录后重置sessionID。在登录验证成功后，通过重置session，是之前的匿名sessionId失效，这样可以避免使用伪造的sessionId进行攻击。</p><p>\2. 关闭透明化Session ID。透明化Session ID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。</p><p>\3. 设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击</p><p>\4. 验证HTTP头部信息，确保User-Agent头部信息一致的确是有效的</p><h3 id="除了session和cookies还有什么缓存"><a href="#除了session和cookies还有什么缓存" class="headerlink" title="除了session和cookies还有什么缓存"></a>除了session和cookies还有什么缓存</h3><p><a href="https://blog.csdn.net/weixin_30481087/article/details/102073804">https://blog.csdn.net/weixin_30481087/article/details/102073804</a></p><p>\1. localStorage： 是一种你不主动清除它，它会一直将存储数据存储在客户端的存储方式，即使你关闭了客户端（浏览器)，属于本地持久层储存 </p><p>\2. sessionStorage： 用于本地存储一个会话（session）中的数据，一旦会话关闭，那么数据会消失，比如刷新。</p><p>有时候，我们需要将数据存储到sessionStorage和localStorage中，这样做的好处有：</p><p>\1. 缓存数据</p><p>\2. 减少对内存的占用</p><p>但是，storage只能存储字符串的数据，对于JS中常用的数组或对象却不能直接存储。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie&quot;&gt;&lt;/a&gt;cookie&lt;/h3&gt;&lt;p&gt;存储在浏览器中&lt;/p&gt;
&lt;p&gt;浏览器实现的一种数据存储功能&lt;/p&gt;
&lt;p&gt;工作过程：cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到本地，下一次请求同一网站时会把该cookie发送给服务器，服务器可以通过cookie中携带的数据区分不同的用户。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP</title>
    <link href="http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/"/>
    <id>http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/</id>
    <published>2021-09-10T05:50:16.000Z</published>
    <updated>2021-09-10T06:35:58.167Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><em>TCP</em></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p> <span id="more"></span><h3 id="TCP-如何保证可靠传输"><a href="#TCP-如何保证可靠传输" class="headerlink" title="TCP 如何保证可靠传输"></a>TCP 如何保证可靠传输</h3><p><em><strong>*TCP如何保证数据的完整性*</strong>***</em>*？*****包编号；校验和</p><p>应用数据被分割成 TCP 认为最适合发送的数据块。</p><p>\1. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传给应用层</p><p>\2. 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p><p>\3. TCP 的接收端会丢弃重复的数据</p><p>\4. 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段</p><p>\5. 流量控制：利用滑动窗口实现</p><p>\6. 停止等待ARQ和连续ARQ协议：确认和超时</p><p>\7. 拥塞控制</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 利用滑动窗口实现流量控制。</p><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p>TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p><h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议*"></a>ARQ 协议*</h3><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是数据链路层和传输层的错误纠正协议之一。它通过使用****确认*<em><strong>和</strong></em>*超时****这两个机制。</p><p>目的：在不可靠服务的基础上实现可靠的信息传输。</p><p>如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</p><p>ARQ包括停止等待ARQ协议和连续ARQ协议。</p><p><em><strong>*停止等待*</strong>***</em>*ARQ协议****</p><p>基本原理：每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p>优点： 简单</p><p>缺点： 信道利用率低，等待时间长</p><p>运行机制：</p><p>\1. 无差错情况:发送方发送分组,接收方在规定时间内收到并回复确认.发送方发送新的分组。</p><p>\2. 出现差错情况（超时重传）:只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。</p><p>\3. 确认丢失：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</p><p>\4. 确认迟到：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</p><p><em><strong>*连续*</strong>***</em>*ARQ协议****</p><p>目的：提高信道利用率。</p><p>基本原理：发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</p><p>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传</p><p>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制***"></a>拥塞控制***</h3><p>拥塞定义：网络中的数据太多，导致某个路由器处理不过来或处理地太慢。</p><p>具体： 当发送的数据到达网络中的一个节点时（假设是路由器），它会根据数据包含的地址进行转发。但这些节点需要先将接收到的数据放入自己的内存（可能还要做一些处理），再从中取出进行转发。但路由器的内存是有限的，若同一时间到达某个路由器的数据太多，这个路由器将无法接收所有的数据，只能将一部分丢弃；或者要等待较长的时间才会被转发。</p><p>拥塞控制定义：在网络中发生拥塞时，减少向网络中发送数据的速度，防止造成恶性循环；同时在网络空闲时，提高发送数据的速度，最大限度地利用网络资源。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。</p><p>TCP的拥塞控制使用四种算法：</p><ol><li><p><strong>慢开始和拥塞避免</strong></p><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p><p>慢开始算法：由小到大、乘法增长，逐渐增加拥塞窗口的大小。即1,2,4,8…目的：不要一开始就发送大量的数据，先探测一下网络的拥塞程度</p><p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh：</p><p>当cwnd&lt;ssthresh时，使用慢开始算法。</p><p>当cwnd&gt;ssthresh时，改用拥塞避免算法。</p><p>当cwnd=ssthresh时，慢开始与拥塞避免算法任意。</p><p>拥塞避免算法让拥塞窗口缓慢增长，拥塞窗口cwnd加1，而不是加倍。</p><p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（没有收到确认、分组丢失），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。</p></li><li><p>快重传和快恢复</p><p>目的：快速恢复丢失的数据包</p><p>快重传：接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p><p>快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半。发送方将cwnd设置为ssthresh的大小，然后执行拥塞避免算法，加法增大。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞，所以不用慢开始。</p></li></ol><h3 id="TCP最大连接数"><a href="#TCP最大连接数" class="headerlink" title="TCP最大连接数*"></a>TCP最大连接数*</h3><p>client：内核开放了50000个端口可以供TCP连接使用，最大理论范围是0-65535。</p><p>client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大tcp连接数为65535。</p><p>用命令查看：</p><p>$ sysctl -a | grep ip_local_port_range</p><p>net.ipv4.ip_local_port_range = 15000   65000</p><p>当Linux作为客户端建立连接的时候，最大连接数量是受内核参数</p><p>net.ipv4.ip_local_port_range限制，而ip_local_port_range是可配置的，最大理论范围是0-65535。</p><p>对于有一个IP的客户端来说，受限于ip_local_port_range参数，也受限于65535。但单Linux可以配置多个ip，有几个ip，最大理论值就翻几倍。</p><p>server：</p><p>server通常固定在某个本地端口上监听，等待client的连接请求，本地监听端口是独占的。</p><p>一条TCP连接是由一个四元组组成的。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，对于我们这台Nginx Server来说，它的IP和端口是固定的。4元组中只有client ip和client port是可变的。因此最大的连接数是2的32次方（ip数）×2的16次方（port数）。</p><p>Linux上除了监听80以外，还可以监听其它的端口，例如Mysql的3306, Redis的6339，当然所有65535个端口你都可以用来监听一遍。这样理论上线就到了2的32次方（ip数）×2的16次方（port数）×2的16次方（服务器port数）个。</p><p>一条TCP连接如果不发送数据的话，消耗内存是3.3K左右。假设你只保持连接不发送数据，那么你服务器可以建立的连接最大数量 = 你的内存/3.3K。假如是4GB的内存，那么大约可接受的TCP连接数量是100万左右。</p><p>总结：</p><p>TCP连接的客户端机：每一个ip可建立的TCP连接理论受限于ip_local_port_range参数，也受限于65535。但可以通过配置多ip的方式来加大自己的建立连接的能力。</p><p>TCP连接的服务器机：每一个监听的端口虽然理论值很大，但这个数字没有实际意义。最大并发数取决你的内存大小，每一条静止状态的TCP连接大约需要吃3</p><p>.3K的内存。</p><h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式*"></a>TCP报文格式*</h3><p>固定首部长度为20字节,可变部分0~40字节</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps43.png" alt="img"> </p><p>\1. 源端口，16bits，范围0~65525。</p><p>\2. 目的端口，16bits，范围同上。</p><p>\3. sequence number： 数据序号，32bits，TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</p><p>\4. acknoledgement number： 确认号，32bits，期望收到对方的下一个报文段的数据的第一个字节的序号。</p><p>\5. 数据偏移，4bits，单位为4字节，它指出报文数据距TCP报头的起始处有多远(TCP报文头长度)。</p><p>\6. 保留字段 6bits，保留今后使用，目前置0处理。</p><p>\7. URG：紧急比特，1bit，当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</p><p>\8. ACK：确认比特，1bit，只有当 ACK=1时确认号字段才有效。当 ACK=0 时，确认号无效</p><p>\9. PSH：推送比特，1bit，接收方 TCP 收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付</p><p>\10. RST：复位比特，1bit，当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接</p><p>\11. SYN：同步比特，1bit，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文</p><p>\12. FIN：终止比特，1bit，用来释放一个连接。当FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</p><p>\13. 窗口大小，16bits，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</p><p>\14. 检验和，16bits，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p><p>\15. 紧急指针字段，16bits，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。</p><p>\16. 选项字段，长度可变，这部分最多包含40字节。TCP首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。，因为TCP头部最长是60字节</p><ol><li><p>选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。</p></li><li><p>第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。</p></li><li><p>第三个字段info（如果有的话）是选项的具体信息. kind=0是选项表结束选项kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍kind=2是最大报文段长度选项</p></li></ol><p>TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。</p><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps39.jpg" alt="img"> </p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><p>SYN 同步序列编号(Synchronize Sequence Numbers) ：建立连接</p><p>ACK：表示响应，告诉对方你发的信息我收到了</p><ol><li><p>主机A：发送syn=1，随机产生seq number=x的数据包 -&gt; 主机B，收到syn=1，知道A要建立连接（B确认了自己接收正常，对方发送正常）</p></li><li><p>主机B：确认连接信息，向A发送ack=1，ack number=x+1，syn=1，随机产生seq=y的数据包 -&gt; 主机A（A确认了自己发送、接收正常，对方发送、接收正常）</p></li><li><p>主机A：检查ack number是否正确，发送ack number=y+1，ack=1 -&gt; 主机B（B确认了自己发送正常，对方接收正常）</p></li></ol><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手*"></a>为什么要三次握手*</h3><p>三次握手的目的是建立可靠的通信信道，即双方确认自己与对方的发送与接收是正常的。</p><p>A和B进行三次握手：A先向B发送</p><ol><li><p>B确认了对方发送正常，自己接收正常</p></li><li><p>A确认了自己发送、接收正常，对方发送、接收正常</p></li><li><p>B确认了：自己发送正常，对方接收正常</p></li></ol><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><p>“三次握手”的目的：“为了防止****已失效的连接请求报文段****突然又传送到了服务端，因而产生错误”</p><p>为了解决“网络中存在延迟的重复分组”的问题</p><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><p><em><strong>*为什么是三次，不是四次？*</strong></em></p><p>这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的.</p><h3 id="第2次握手传回了ACK，为什么还要传回SYN"><a href="#第2次握手传回了ACK，为什么还要传回SYN" class="headerlink" title="第2次握手传回了ACK，为什么还要传回SYN"></a>第2次握手传回了ACK，为什么还要传回SYN</h3><p>SYN 同步序列编号(Synchronize Sequence Numbers) ：建立连接</p><p>ACK：表示响应，告诉对方你发的信息我收到了</p><p>B给A所发送的ACK是为了告诉A，我接收到的信息确实就是你所发送的信号了，这表明从A到B的通信是正常的。而回传SYN则是为了建立从B到A的通信。</p><h3 id="如果第一次、第二次失败"><a href="#如果第一次、第二次失败" class="headerlink" title="如果第一次、第二次失败*"></a>如果第一次、第二次失败*</h3><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps40.jpg" alt="img"> </p><p>第一次失败（client向server发送SYN失败）：</p><p>两端都不会申请资源。如果一段时间后之前的SYN发送成功了，这时客户端只会接收他最后发送的SYN的SYN+ACK回应，其他的一概忽略，服务端也是如此，会将之前多申请的资源释放了。</p><p>第二次握手失败（server向client发送SYN+ACK失败）：</p><p>client由于没有收到这条响应，不会申请资源，虽然服务端申请了资源，但是迟迟收不到来自客户端的ACK，也会将该资源释放。</p><p>第三次握手失败（client向server发送ACK失败）：</p><p>server迟迟没有收到ACK，就会释放资源</p><p>但client认为自己已经连接好了，就会给server发送数据</p><p>server由于没有收到第三次握手，就会以RST包对客户端响应，重新建立链接</p><p>另外，server会因为没有收到客户端的ACK多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到客户端的ACK，则释放资源。</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps41.jpg" alt="img"> </p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>A 主动关闭         B被动关闭</p><ol><li><p>主机A：发送fin=1, seq=x 报文，用来关闭A到B的数据传送 -&gt; 主机B</p></li><li><p>主机B：发送 ack=1, seq=x+1 报文，确认收到关闭连接的信息 -&gt; 主机A</p></li><li><p>主机B：发送 fin=1, seq=y 报文，用来关闭B到A的数据传送 -&gt; 主机A</p></li><li><p>主机A：发送 ack=1, seq=y+1 报文，确认收到关闭连接的信息 -&gt; 主机B</p></li></ol><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps42.png" alt="img"> </p><h3 id="为什么三次握手，而关闭却是四次"><a href="#为什么三次握手，而关闭却是四次" class="headerlink" title="为什么三次握手，而关闭却是四次*"></a>为什么三次握手，而关闭却是四次*</h3><p>这是因为服务端收到SYN报文的连接请求后，它可以把ACK和SYN放在一个报文里来发送。</p><p>关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭。可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了。</p><p>所以关闭时ACK报文和FIN报文多数情况下都是分开发送的。</p><h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT*"></a>TIME_WAIT*</h3><p>A主动关闭连接结束后，收到来自B的FIN，在A发送最后一个ack后，A会进入TIME_WAIT状态，再停留2个MSL时间，进入CLOSED状态。</p><p>用途：</p><p>\1. 可靠地实现TCP全双工连接的终止。避免对方收不到自己的ACK，等对方重发FIN。</p><p>\2. 保证旧连接的重复分组在网络中消逝。避免服务器重启（或者其他服务器绑定同样端口）接收到了上一次的数据。（TCP分组可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分组在路由器修复后也会被送到最终目的地，这个迟到的迷途分组到达时可能会引起问题。）</p><h3 id="TIME-WAIT状态后为什么需要等2MSL"><a href="#TIME-WAIT状态后为什么需要等2MSL" class="headerlink" title="TIME_WAIT状态后为什么需要等2MSL*"></a>TIME_WAIT状态后为什么需要等2MSL*</h3><p>****MSL****：maximum segment lifetime(最大报文生存时间），指报文能在互联网上生存的最长时间，超过这个时间报文将在网络中消失 。MSL在RFC 1122上建议是2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p><p>MSL多长？一般是60s.</p><p>cat /proc/sys/net/ipv4/tcp_fin_timeout</p><p>等待2MSL时间主要目的是怕四次握手的最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p><h3 id="TIME-WAIT状态过多原因与解决"><a href="#TIME-WAIT状态过多原因与解决" class="headerlink" title="TIME_WAIT状态过多原因与解决*"></a>TIME_WAIT状态过多原因与解决*</h3><p>查看当前系统下所有连接状态的数：</p><p>[root@vps ~]#netstat -n|awk ‘/^tcp/{++S[$NF]}END{for (key in S) print key,S[key]}’</p><p>TIME_WAIT 286</p><p>FIN_WAIT1 5</p><p>FIN_WAIT2 6</p><p>ESTABLISHED 269</p><p>SYN_RECV 5</p><p>CLOSING 1</p><p>原因：短时间内（比如1s）进行大量的短连接，可能出现time wait状态过多。</p><p>一般情况下，持续2MSL，不会有太大影响；但如果短时间内过多，会创建大量fd，导致fd被用尽，系统无法再发起新连接。</p><p>解决办法：<em><strong>*修改TIME_*</strong>***</em>*WAIT****<em><strong>*时间的Linux内核参数**</strong></em></p><p>在****/etc/sysctl.conf****文件中，加入：</p><p>net.ipv4.tcp_tw_reuse = 1（默认为0，表示关闭）</p><p># 表示开启重用。允许将TIME-WAIT的socket重新用于新的TCP连接</p><p>由于两端都使用了时间戳，所以能够避免序列号重复。</p><p>net.ipv4.tcp_tw_recycle = 1（默认为0，表示关闭）</p><p>#表示开启TCP连接中TIME-WAIT sockets的快速回收</p><p><em><strong>*内核如何回收socket**</strong></em></p><p>TCP有一种行为，可以缓存每个连接最新的时间戳，后续请求中如果时间戳小于缓存的时间戳，即视为无效，相应的数据包会被丢弃。</p><p>Linux是否启用这种行为取决于tcp_timestamps和tcp_tw_recycle，其中tcp_timestamps缺省就是开启的，所以当tcp_tw_recycle被开启后，实际上这种行为就被激活了。</p><p>在NAT系统中会共享套接字和时间戳，因此会出现时间戳错乱的情况，后面的数据包就被丢弃了，具体的表现通常是客户端明明发送的SYN，但服务端就是不响应ACK。</p><p>net.ipv4.tcp_max_tw_buckets = 5000    </p><p>#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。</p><p>建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置。</p><p>修改 linux kernel 的 tcp time wait的时间。</p><p>在 $KERNEL/include/net/tcp.h里面，有下面的行：</p><p>#define <em><strong>*TCP_TIMEWAIT_LEN*</strong></em> (60*HZ)</p><p>而这个宏是真正控制 TCP TIME_WAIT 状态的超时时间的。根据我们的测试，设置为 10 秒比较合适，即：  　　</p><p>#define TCP_TIMEWAIT_LEN (10*HZ)</p><p>然后重新编译内核，重启系统即可发现短连接造成的TIME_WAIT状态大大减少。一般情况都可以至少减少2/3。也能相应提高系统应对短连接的速度。</p><p>net.ipv4.tcp_fin_timeout = 5    </p><p># 修改系统默认的 TIMEOUT 时间（输出用，不用真正起作用）</p><p>net.ipv4.tcp_syncookies = 1    （默认为0，表示关闭）</p><p>#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击</p><p>最后输入下面的命令，让内核参数生效：sudo sysctl -p</p><p>net.ipv4.tcp_keepalive_time = 1200 （缺省是2小时，改为20分钟）</p><p>#表示当keepalive启用的时候，TCP发送keepalive消息的频度</p><p>net.ipv4.ip_local_port_range = 10000 65000    </p><p>#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。</p><p>net.ipv4.tcp_max_syn_backlog = 8192    </p><p>#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数</p><h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT*"></a>CLOSE_WAIT*</h3><p>CLOSE_WAIT，借用某位大牛的话来说应该倒过来叫做 WAIT_CLOSE，也就是说「等待关闭」</p><p>A发出 FIN 包，B响应 ACK 包，此时，B就进入了 CLOSE_WAIT 状态。如果一切正常，稍后B会发出 FIN 包，然后进入 LAST_ACK 状态。</p><p>如果出现大量的 CLOSE_WAIT 状态，那么就意味着B没有及时发出 FIN 包，一般有如下几种可能：</p><ol><li><p>程序问题：代码层面忘记关闭相应的 socket 连接导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到</p></li><li><p>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。</p></li><li><p>BACKLOG 太大：此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在队列里就被对方关闭了。</p></li></ol><p>服务器中存在大量close wait的危害：</p><p>大量close wait会占用服务器的fd，而一个机器能打开的fd数量是有限的，超过后就无法分配fd，无法建立新连接。</p><h3 id="CLOSE-WAIT-TIME-WAIT哪个危害大"><a href="#CLOSE-WAIT-TIME-WAIT哪个危害大" class="headerlink" title="CLOSE_WAIT TIME_WAIT哪个危害大*"></a>CLOSE_WAIT TIME_WAIT哪个危害大*</h3><p>通常情况下，time wait对服务器影响有限，而大量的close wait风险较高，一般正确编码可以避免。</p><h2 id="TCP粘包拆包"><a href="#TCP粘包拆包" class="headerlink" title="TCP粘包拆包"></a>TCP粘包拆包</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为一个进行发送，这就形成了粘包问题。</p><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p><h3 id="具体出现场景"><a href="#具体出现场景" class="headerlink" title="具体出现场景"></a>具体出现场景</h3><p>假设client向服sever连续发送了两个数据包，packet1和packet2，server收到的数据可分为三种：</p><ol><li><p>正常收到两个数据包，没有发生拆包和粘包</p></li><li><p>只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包</p></li></ol><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps44.jpg" alt="img"> </p><ol start="3"><li>接收端收到了两个数据包，但是这两个数据包是不完整的、或者是多出来一块，这种情况即发生了拆包和粘包（Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理）</li></ol><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps45.jpg" alt="img"> </p><h3 id="为什么TCP有拆包粘包-UDP没有"><a href="#为什么TCP有拆包粘包-UDP没有" class="headerlink" title="为什么TCP有拆包粘包  UDP没有"></a>为什么TCP有拆包粘包  UDP没有</h3><p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生，日常的网络应用开发大都在传输层进行。</p><p>UDP有消息保护边界，不会发生粘包拆包问题。</p><p>因此粘包拆包问题只发生在TCP中。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组。</p><p>常用方案：</p><ol><li><p>消息定长，比如每个报文的大小为固定长度200字节，如果不够，空位补空格</p></li><li><p>在包尾增加回车换行符进行分割，例如FTP协议</p></li><li><p>将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，只有读取到足够长度的消息之后才算是读到了一个完整的消息</p></li><li><p>通过自定义协议进行粘包和拆包的处理。</p></li></ol><h3 id="TCP粘包拆包-发生的原因"><a href="#TCP粘包拆包-发生的原因" class="headerlink" title="TCP粘包拆包 发生的原因"></a>TCP粘包拆包 发生的原因</h3><ol><li><p>应用程序写入的数据大于套接字的缓冲区大小，发生拆包</p></li><li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，发生粘包</p></li><li><p>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</p></li><li><p>接收方法不及时读取套接字缓冲区数据，这将发生粘包</p></li></ol><p>摘自：</p><p><a href="https://www.cnblogs.com/azraelly/archive/2012/12/25/2832393.html">https://www.cnblogs.com/azraelly/archive/2012/12/25/2832393.html</a></p><p><a href="https://www.jianshu.com/p/e4cd3de320f7">https://www.jianshu.com/p/e4cd3de320f7</a></p><p><a href="https://blog.huoding.com/2016/01/19/488">https://blog.huoding.com/2016/01/19/488</a></p><p><a href="https://www.zhihu.com/question/298214130">https://www.zhihu.com/question/298214130</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;&lt;em&gt;TCP&lt;/em&gt;&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Websocket</title>
    <link href="http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Websocket/"/>
    <id>http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Websocket/</id>
    <published>2021-09-10T05:49:02.000Z</published>
    <updated>2021-09-10T06:36:11.089Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>WebSocket 是一种网络通信协议，应用层协议。</p><p>已经有了 HTTP 协议，为什么还需要另一个协议：因为 HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><span id="more"></span><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>特点：</p><ol><li><p>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</p></li><li><p>建立在 TCP 协议之上，服务器端的实现比较容易</p></li><li><p>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</p></li><li><p>数据格式比较轻量，性能开销小，通信高效</p></li><li><p>可以发送文本，也可以发送二进制数据</p></li><li><p>没有同源限制，客户端可以与任意服务器通信</p></li><li><p>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。比如ws://example.com:80/some/path</p></li></ol><p>WebSocket依赖于HTTP连接，那么它如何从连接的HTTP协议转化为WebSocket协议？</p><p>每个WebSocket连接都始于一个HTTP请求。具体来说，WebSocket协议在第一次握手连接时，通过HTTP协议在传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端：</p><p>GET /chat HTTP/1.1</p><p>Host: server.example.com</p><p>Upgrade: websocket</p><p>Connection: Upgrade</p><p>Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==</p><p>Origin: <a href="http://example.com/">http://example.com</a></p><p>Sec-WebSocket-Version: 13</p><p>Upgrade首部，用来把当前的HTTP请求升级到WebSocket协议。</p><p>WebSocket为什么要依赖于HTTP协议的连接？</p><ol><li><p>WebSocket设计上就是天生为HTTP增强通信（全双工通信等），所以在HTTP协议连接的基础上是很自然的一件事，并因此而能获得HTTP的诸多便利</p></li><li><p>兼容支持，比如即使服务器不支持WebSocket也能建立HTTP通信，只不过返回的是onerror而已，这显然比服务器无响应要好的多。</p></li></ol><h3 id="HTTP-长连接-WebSocket-长连接"><a href="#HTTP-长连接-WebSocket-长连接" class="headerlink" title="HTTP 长连接  WebSocket 长连接*"></a>HTTP 长连接  WebSocket 长连接*</h3><p>在http1.1中，Connection默认为Keep-alive参数，可以用这个来作为长连接。</p><p>缺点：没法做到服务端主动发送通知给客户端的。</p><p>在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。WebSocket是一种双向通信协议。</p><p>摘自：</p><p><a href="https://www.jianshu.com/p/86a550a521c5">https://www.jianshu.com/p/86a550a521c5</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;WebSocket 是一种网络通信协议，应用层协议。&lt;/p&gt;
&lt;p&gt;已经有了 HTTP 协议，为什么还需要另一个协议：因为 HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/"/>
    <id>http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/</id>
    <published>2021-09-10T05:45:40.000Z</published>
    <updated>2021-09-10T06:35:53.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>[TOC]</p><h3 id="1-HTTPS是什么"><a href="#1-HTTPS是什么" class="headerlink" title="1. HTTPS是什么"></a>1. HTTPS是什么</h3><p>定义：HTTPS（全称： Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。HTTPS由两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体来说，HTTPS是HTTP报文直接将报文信息传输给SSL套接字进行加密，SSL加密后将加密后的报文发送给TCP套接字，然后TCP套接字再将加密后的报文发送给目的主机，目的主机将通过TCP套接字获取加密后的报文给SSL套接字，SSL解密后交给对应进程。</p> <span id="more"></span><p>HTTP： 直接通过明文在浏览器和服务器之间传递信息。</p><p>HTTPS： 采用 对称加密算法加密数据+非对称加密算法交换密钥+数字证书验证身份 结合的方式来保护浏览器和服务端之间的通信安全。</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/wps37.jpg" alt="img"> </p><h3 id="2-HTTPS-请求-加密过程"><a href="#2-HTTPS-请求-加密过程" class="headerlink" title="2. HTTPS 请求/加密过程"></a>2. HTTPS 请求/加密过程</h3><p><em><strong>*HTTPS是对称加密还是非对称加密**</strong></em></p><p>随机值：非对称加密</p><p>数据传输：对称加密</p><p>\1. client用户在浏览器里输入一个HTTPS网址，然后连接到服务端的443端口。以明文传输请求信息，包含版本信息，加密-套件候选列表，压缩算法候选列表，随机数，扩展字段等信息</p><p>\2. 服务端配置。采用HTTPS协议的服务器必须要有一套数字证书，这个证书中包含私钥和公钥。可以自己制作和向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。</p><p>\3. server返回证书，以及包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S</p><p>\4. client验证证书的合法性，包括可信性，是否吊销，过期时间和域名(这部分工作是由客户端的SSL/TLS来完成的)。首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题<em><strong>*（*</strong>***</em>*如何验证合法性*********）****。</p><p>\5. 如果证书没有问题，client就生成一个随机值。然后用证书的公钥对这个随机值进行加密，发送给server</p><p>\6. server用证书的私钥解密，得到这个随机值。将这个随机值作为对称加密的密匙，对要传输的数据进行加密，并传输给client。</p><p>\7. client使用随机值解密信息，获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p><p><img src="file:///C:\Users\FYR\AppData\Local\Temp\ksohtml21792\wps38.jpg" alt="img"> </p><p>公钥和私钥：</p><p>公钥：锁；私钥：钥匙。</p><p>锁可以给别人，别人可以用这个锁把重要的东西锁起来，发给你。</p><p>钥匙只有一把，也就是只有你能看到被锁起来的数据。</p><h3 id="3-为什么不直接用非对称加密传输数据"><a href="#3-为什么不直接用非对称加密传输数据" class="headerlink" title="3. 为什么不直接用非对称加密传输数据*"></a>3. 为什么不直接用非对称加密传输数据*</h3><p>\1. 只有server有私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密</p><p>\2. 非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的</p><h3 id="4-对称加密-非对称加密"><a href="#4-对称加密-非对称加密" class="headerlink" title="4. 对称加密  非对称加密"></a>4. 对称加密  非对称加密</h3><p>对称加密：采用的是使用相同密钥对报文进行加密解密</p><p>encrypt(明文，秘钥) = 密文</p><p>decrypt(密文，秘钥) = 明文</p><p>典型的对称加密算法有DES、AES等；</p><p>非对称加密：加密和解密是需要不同的秘钥的。</p><p>encrypt(明文，公钥) = 密文</p><p>decrypt(密文，私钥) = 明文</p><p>典型的非对称加密算法有RSA、DSA等。</p><h3 id="5-为什么非对称加密慢"><a href="#5-为什么非对称加密慢" class="headerlink" title="5. 为什么非对称加密慢"></a>5. 为什么非对称加密慢</h3><p>对称加密主要的运算是****位运算****，速度非常快，如果使用硬件计算，速度会更快。以 AES 算法为例，如下图所示，其运算本质上来说就是位移和替换。另外还有一个原因是，AES 中的许多中间计算过程是可以事先计算好的。加密数据时许多中间过程可以直接查表，而不需要实时地计算。</p><p>但是非对称加密计算****一般都比较复杂****，比如 RSA，它里面涉及到大数乘法、大数模等等运算。</p><h3 id="6-HTTPS用到了哪些加密技术"><a href="#6-HTTPS用到了哪些加密技术" class="headerlink" title="6. HTTPS用到了哪些加密技术*"></a>6. HTTPS用到了哪些加密技术*</h3><p><a href="https://www.cnblogs.com/xdyixia/p/9237742.html">https://www.cnblogs.com/xdyixia/p/9237742.html</a></p><p><a href="https://blog.csdn.net/WoTrusCA/article/details/100105031">https://blog.csdn.net/WoTrusCA/article/details/100105031</a></p><p>非对称加密技术：</p><h3 id="7-TLS-SSL-HTTP-HTTPS的关系"><a href="#7-TLS-SSL-HTTP-HTTPS的关系" class="headerlink" title="7.TLS/SSL, HTTP, HTTPS的关系"></a>7.TLS/SSL, HTTP, HTTPS的关系</h3><p>SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协 议，均用于在传输层为数据通讯提供安全支持。 </p><p>可以将HTTPS协议简单理解为HTTP协议＋TLS/SSL </p><p>引用</p><p><a href="https://www.jianshu.com/p/e30a8c4fa329">https://www.jianshu.com/p/e30a8c4fa329</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-HTTPS是什么&quot;&gt;&lt;a href=&quot;#1-HTTPS是什么&quot; class=&quot;headerlink&quot; title=&quot;1. HTTPS是什么&quot;&gt;&lt;/a&gt;1. HTTPS是什么&lt;/h3&gt;&lt;p&gt;定义：HTTPS（全称： Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。HTTPS由两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体来说，HTTPS是HTTP报文直接将报文信息传输给SSL套接字进行加密，SSL加密后将加密后的报文发送给TCP套接字，然后TCP套接字再将加密后的报文发送给目的主机，目的主机将通过TCP套接字获取加密后的报文给SSL套接字，SSL解密后交给对应进程。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"/>
    <id>http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/</id>
    <published>2021-09-10T05:35:17.000Z</published>
    <updated>2021-09-10T06:35:50.227Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-HTTP是什么"><a href="#1-HTTP是什么" class="headerlink" title="1. HTTP是什么"></a>1. HTTP是什么</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p> <span id="more"></span><h3 id="2-状态码"><a href="#2-状态码" class="headerlink" title="2. 状态码"></a>2. 状态码</h3><p><strong>1XX：Informational信息性状态码，接收的请求正在处理</strong></p><p><strong>2XX：Success成功状态码，请求正常处理完毕</strong></p><p>​    200：ok 请求成功</p><p>​    204：no content请求成功，但没有结果返回</p><p>​    206：partial content客户端请求一部分资源，服务端成功响应，返回一部分资源</p><p><strong>3XX：Redirection重定向状态码</strong></p><p>代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请    求地址（重定向目标）在本次响应的Location域中指明。</p><p>​    300 Multiple Choices</p><p>​    被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议    信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p><p>​    301：move permanently永久性重定向</p><p>​    被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。</p><p>​    302：found临时性重定向</p><p>​    要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。</p><p>​    注意：很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。[20]因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p><p>​    303：see other</p><p>​    对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</p><p>​    304：not modified </p><p>​    表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</p><p>​    307 temporary redirect </p><p>​    在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求。</p><p><strong>4XX：Client Error客户端错误状态码，服务器无法处理的请求</strong></p><p>​    400：bad request</p><p>​    由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗    性路由请求），服务器不能或不会处理该请求。</p><p>​    401：unauthorized</p><p>​    该状态码表示当前请求需要用户验证。</p><p>​    第一次请求后，响应包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户    信息。客户端第二次请求，重复提交一个包含恰当的Authorization头信息的请求，如果再次    返回401响应代表着服务器验证已经拒绝了那些证书，认证失败。</p><p>​    403：forbidden</p><p>​    服务器已经理解请求，但是拒绝执行它。</p><p>​    404：not found</p><p>​    服务器上无法找到请求的资源</p><p>​    405：method not allow请求所针对的资源不支持对应的请求方法</p><p><strong>5XX：Server Error服务器错误状态码，服务器处理请求出错</strong></p><p>​    500：internal server error服务端执行请求时发生了错误</p><p>​    502：bad Gateway网关错误</p><p>​    503：service unavailable服务器正在超负载或停机维护，无法处理请求</p><h3 id="3-HTTP-请求头字段"><a href="#3-HTTP-请求头字段" class="headerlink" title="3. HTTP 请求头字段"></a>3. HTTP 请求头字段</h3><ol><li><p>Accept : 浏览器可以接收的内容类型，例如 Accept: text/plain</p></li><li><p>Accept-Charset：浏览器能识别的字符集，例如 Accept-Charset: utf-8</p></li><li><p>Accept-Encoding：浏览器可以处理的编码方式，注意这里的编码方式有别于字符集，这里的编码方式通常指gzip,deflate等。例如 Accept-Encoding: gzip, deflate</p></li><li><p>Accept-Language：浏览器接收的语言，其实也就是用户在什么语言地区，例如简体中文的就是 Accept-Language: zh-CN</p></li><li><p>Accept-Datetime：设置接受的版本时间，例如Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</p></li><li><p>Via：用来记录一个请求经过了哪些代理或网关才被送到目标服务器上</p></li><li><p>Referer：指当前请求的URL是在什么地址引用的</p></li><li><p>User-Agent： 通常就是用户的浏览器相关信息。例如：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0</p></li><li><p>Cache-Control：这个指令在request和response中都有，用来指示缓存系统（服务器上的，或者浏览器上的）应该怎样处理缓存。eg：Cache-Control: no-cache</p></li><li><p>Connection：告诉服务器这个浏览器想要使用怎样的连接方式。值有keep-alive和close</p></li></ol><p>等等。</p><h3 id="4-HTTP-长连接-短连接"><a href="#4-HTTP-长连接-短连接" class="headerlink" title="4. HTTP  长连接 短连接*"></a>4. HTTP  长连接 短连接*</h3><p><em><strong>如何保证长连接</strong></em></p><p>短连接：客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。在HTTP/1.0中默认使用。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在请求头中设置：<em><strong>Connection:keep-alive</strong></em></p><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>开启Keep-Alive的优缺点：</p><p>优点：Keep-Alive模式更加高效，因为避免了连接建立和释放的开销。</p><p>缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</p><h3 id="5-HTTP-无状态，如何保存用户状态"><a href="#5-HTTP-无状态，如何保存用户状态" class="headerlink" title="5. HTTP 无状态，如何保存用户状态"></a>5. HTTP 无状态，如何保存用户状态</h3><p>HTTP 是一种无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p><p>那么我们保存用户状态呢？Session 机制。</p><p>主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p>Cookie 被禁用怎么办?</p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p><h3 id="6-HTTP-八种请求方式"><a href="#6-HTTP-八种请求方式" class="headerlink" title="6. HTTP 八种请求方式*"></a>6. HTTP 八种请求方式*</h3><p><em><strong>*get*</strong></em> 请求从服务器获取特定资源</p><p><em><strong>*post*</strong></em> 在服务器上创建一个新的资源</p><p>put 更新服务器上的资源（更新整个资源，比如编号12的学生信息）</p><p>delete 从服务器删除特定的资源</p><p>head 类似于get，只不过返回的响应中没有具体内容，用于获取报头</p><p>options 返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</p><p>connect 预留给能够将连接改为管道方式的代理服务器</p><p>trace 回显服务器收到的请求，主要用于测试或诊断</p><h3 id="7-HTTP-1-0-HTTP-1-1"><a href="#7-HTTP-1-0-HTTP-1-1" class="headerlink" title="7. HTTP 1.0 HTTP 1.1"></a>7. HTTP 1.0 HTTP 1.1</h3><p>主要区别主要体现在：</p><ol><li><p>长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求</p></li><li><p>错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除</p></li><li><p>缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略</p></li><li><p>带宽优化及网络连接的使用 :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。、</p></li></ol><h4 id="9-http-1-0、1-1、2-0"><a href="#9-http-1-0、1-1、2-0" class="headerlink" title="9. http***1.0、1.1、2.0***"></a>9. <em><strong>http</strong>***</em>1.0、1.1、2.0***</h4><p><em><strong>HTTP1.0版本的特性：</strong></em></p><p>①　早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。</p><p>②　HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p><p> <strong>HTTP1.1版本新特性</strong></p><p>①　默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</p><p>②　管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</p><p>③　断点续传原理</p><p><strong>HTTP2.0版本的特性</strong></p><p>①　二进制分帧（采用二进制格式的编码将其封装）</p><p>②　首部压缩（设置了专门的首部压缩设计的HPACK算法。）</p><p>③　流量控制（设置了接收某个数据流的多少字节一些流量控制）</p><p>④　多路复用（可以在共享TCP链接的基础上同时发送请求和响应）</p><p>⑤　请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）</p><p>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。</p><h3 id="10-HTTP断点重传"><a href="#10-HTTP断点重传" class="headerlink" title="10. HTTP断点重传"></a>10. HTTP断点重传</h3><p>定义：HTTP/FTP 服务器或下载软件具有断点续传能力，允许用户从上传/下载断线的地方继续传送。 </p><p>HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。它通过在 Header 里两个参数实现的，客户端发请求时对应的是 <em><strong>*Range*</strong></em> ，服务器端响应时对应的是 ****Content-Range****。</p><p>Range：用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：</p><p>Range:(unit=first byte pos)-[last byte pos]</p><p>Range 头部的格式有以下几种情况：</p><p>Range: bytes=0-499 表示第 0-499 字节范围的内容 </p><p>Range: bytes=500-999 表示第 500-999 字节范围的内容 </p><p>Range: bytes=-500 表示最后 500 字节的内容 </p><p>Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容 </p><p>Range: bytes=0-0,-1 表示第一个和最后一个字节 </p><p>Range: bytes=500-600,601-999 同时指定几个范围</p><p>Content-Range：用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。一般格式：</p><p>Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth]</p><p>例如：</p><p>Content-Range: bytes 0-499/22400</p><p>0－499 是指当前发送的数据的范围，而 22400 则是文件的总大小。</p><p>而在响应完成后，返回的响应头状态码也不同：</p><p>HTTP/1.1 <em><strong>*200*</strong></em> Ok（不使用断点续传方式） </p><p>HTTP/1.1 <em><strong>*206*</strong></em> Partial Content（使用断点续传方式）表示客户端请求一部分资源，服务端成功响应，返回一部分资源</p><p>增强校验</p><p>在实际场景中，会出现一种情况，即在终端发起续传请求时，URL 对应的文件内容在服务器端已经发生变化，此时续传的数据肯定是错误的。解决办法：</p><ol><li><p>Last-Modified 来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动。</p></li><li><p>使用 ETag 头来放置文件的唯一标识</p></li></ol><p>检测服务器是否支持断点续传</p><p>[root@localhost ~]# curl <em><strong>*-i –range 0-9*</strong></em> <a href="http://www.baidu.com/img/bdlogo.gif">http://www.baidu.com/img/bdlogo.gif</a></p><p>HTTP/1.1 206 Partial Content</p><p>Date: Mon, 21 Nov 2016 05:26:29 GMT</p><p>Server: Apache</p><p>P3P: CP=” OTI DSP COR IVA OUR IND COM “</p><p>Set-Cookie: BAIDUID=0CD0E23B4D4F739954DFEDB92BE6CE03:FG=1; expires=Tue, 21-Nov-17 05:26:29 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p><p>Last-Modified: Fri, 22 Feb 2013 03:45:02 GMT</p><p>ETag: “627-4d648041f6b80”</p><p>Accept-Ranges: bytes</p><p>Content-Length: 10</p><p>Cache-Control: max-age=315360000</p><p>Expires: Thu, 19 Nov 2026 05:26:29 GMT</p><p>Content-Range: bytes 0-9/1575</p><p>Connection: Keep-Alive</p><p>Content-Type: image/gif</p><p>能够找到 Content-Range，则表明服务器支持断点续传。有些服务器还会返回 Accept-Ranges，输出结果 Accept-Ranges: bytes ，说明服务器支持按字节下载。</p><p><em><strong>*Last-Modified*</strong></em>    服务器发给客户</p><p>If-Modified-Since    客户发给服务器</p><p>都是用于记录页面最后修改时间的 HTTP 头信息。再次请求本地存在的 cache 页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的 Last-Modified 最后修改时间戳发送回去，这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担。</p><p>（304：not modified 服务端已经执行了GET，但文件未变化）</p><p><em><strong>*Etag*</strong></em></p><p>为了解决 Last-Modified 无法解决的一些问题。</p><p>一些文件也许会周期性的更改，但是内容并不改变（仅改变修改时间），这时候我们并不希望客户端认为这个文件被修改了，而重新 GET。</p><p>某些文件修改非常频繁，例如：在秒以下的时间内进行修改（1s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）。</p><p>某些服务器不能精确的得到文件的最后修改时间。</p><p>为此，HTTP/1.1 引入了 Etag。Etag 仅仅是一个和文件相关的标记，可以是一个版本标记，例如：v1.0.0；或者说 “627-4d648041f6b80” 这么一串看起来很神秘的编码。但是 HTTP/1.1 标准并没有规定 Etag 的内容是什么或者说要怎么实现，唯一规定的是 Etag 需要放在 “” 内。</p><p>If-Range</p><p>用于判断实体是否发生改变，如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。一般格式：If-Range: Etag | HTTP-Date</p><p>也就是说，If-Range 可以使用 Etag 或者 Last-Modified 返回的值。当没有 ETage 却有 Last-modified 时，可以把 Last-modified 作为 If-Range 字段的值。</p><p>例如：</p><p>If-Range: “627-4d648041f6b80” </p><p>If-Range: Fri, 22 Feb 2013 03:45:02 GMT</p><p>If-Range 必须与 Range 配套使用。如果请求报文中没有 Range，那么 If-Range 就会被忽略。如果服务器不支持 If-Range，那么 Range 也会被忽略。</p><p>如果请求报文中的 Etag 与服务器目标内容的 Etag 相等，即没有发生变化，那么应答报文的状态码为 206。如果服务器目标内容发生了变化，那么应答报文的状态码为 200。</p><p>用于校验的其他 HTTP 头信息：If-Match/If-None-Match、If-Modified-Since/If-Unmodified-Since。</p><h3 id="11-HTTP-HTTPS"><a href="#11-HTTP-HTTPS" class="headerlink" title="11. HTTP  HTTPS*"></a>11. HTTP  HTTPS*</h3><p>区别：</p><ol><li><p>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p></li><li><p>安全性： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在****SSL/TLS****之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以，HTTP 安全性没有 HTTPS高。</p></li><li><p>资源消耗：HTTPS 比HTTP耗费更多服务器资源</p></li><li></li></ol><h3 id="12-HTTP-Request-Response格式"><a href="#12-HTTP-Request-Response格式" class="headerlink" title="12. HTTP Request Response格式*"></a>12. HTTP Request Response格式*</h3><p>HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息︰ </p><p>请求（requests）–由客户端发送用来触发一个服务器上的动作</p><p>​    起始行</p><p>​    Headers</p><p>​    Body</p><p>响应（responses）–来自服务器的应答。</p><p>​    状态行</p><p>​    Headers</p><p>​    Body</p><p><em><strong>*Request*</strong>***</em>*- 起始行****</p><p>包含三个元素：</p><p>\1. HTTP 方法，GET, PUT 或者 POST等</p><p>\2. 请求目标 ，通常是一个 URL，或者是协议、端口和域名的绝对路径，通常以请求的环境为特征。</p><p>\3. HTTP 版本 </p><p><em><strong>*Request*</strong>***</em>*- Headers****</p><p>整个 header（包括值）由一行组成，这一行可以相当长。</p><p>有许多请求头可用，它们可以分为几组：</p><p>\1. General headers，例如 Via，适用于整个报文。</p><p>\2. Request headers，例如 User-Agent，Accept-Type，通过进一步的定义(例如 Accept-Language)，或者给定上下文(例如 Referer)，或者进行有条件的限制 (例如 If-None) 来修改请求。</p><p>\3. Entity headers，例如 Content-Length，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/wps35-1631252167679.jpg" alt="img"> </p><p><em><strong>*Request*</strong>***</em>*- Body****</p><p>请求的最后一部分是它的 body。不是所有的请求都有一个 body：例如获取资源的请求，GET，HEAD，DELETE 和 OPTIONS，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 POST 请求（包含 HTML 表单数据）。</p><p>Body 大致可分为两类：</p><p>\1. Single-resource bodies，由一个单文件组成。该类型 body 由两个 header 定义： Content-Type 和 Content-Length.</p><p>\2. Multiple-resource bodies，由多部分 body 组成，每一部分包含不同的信息位。通常是和  HTML Forms 连系在一起。</p><p><em><strong>*Response*</strong>***</em>*-状态行****</p><p>HTTP 响应的起始行被称作 状态行 (status line)，包含以下信息：</p><p>\1. 协议版本，通常为 HTTP/1.1</p><p>\2. 状态码 (status code)，表明请求是成功或失败。常见的状态码是 200，404，或 302。</p><p>\3. 状态文本 (status text)。一个简短的，纯粹的信息，通过状态码的文本描述，帮助人们理解该 HTTP 消息。</p><p>一个典型的状态行看起来像这样：HTTP/1.1 404 Not Found。</p><p><em><strong>*Response*</strong>***</em>*-Headers****</p><p>有许多响应头可用，这些响应头可以分为几组：</p><p>\1. General headers，例如 Via，适用于整个报文</p><p>\2. Response headers，例如 Vary 和 Accept-Ranges，提供其它不符合状态行的关于服务器的信息</p><p>\3. Entity headers，例如 Content-Length，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/wps36-1631252167678.jpg" alt="img"> </p><p><em><strong>*Response*</strong>***</em>*-Body****</p><p>响应的最后一部分是 body。不是所有的响应都有 body：具有状态码 (如 201 或 204) 的响应，通常不会有 body。</p><p>Body 大致可分为三类：</p><ol><li><p>Single-resource bodies，由已知长度的单个文件组成。该类型 body 由两个 header 定义：Content-Type 和 Content-Length。</p></li><li><p>Single-resource bodies，由未知长度的单个文件组成，通过将 Transfer-Encoding 设置为 chunked 来使用 chunks 编码</p></li><li><p>Multiple-resource bodies，由多部分 body 组成，每部分包含不同的信息段。但这是比较少见的。</p></li></ol><p>引用：</p><p><a href="https://www.cnblogs.com/findumars/p/5745345.html">https://www.cnblogs.com/findumars/p/5745345.html</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-HTTP是什么&quot;&gt;&lt;a href=&quot;#1-HTTP是什么&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP是什么&quot;&gt;&lt;/a&gt;1. HTTP是什么&lt;/h3&gt;&lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>DNS</title>
    <link href="http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/"/>
    <id>http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/</id>
    <published>2021-09-10T05:31:16.000Z</published>
    <updated>2021-09-10T06:35:45.765Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-DNS"><a href="#1-DNS" class="headerlink" title="1. DNS"></a>1. <strong>DNS</strong></h2><p>域名系统(Domain Name System：将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><span id="more"></span> <p>DNS域名解析过程：</p><p>在主机中输入<a href="http://www.bytedancom/">www.bytedancom</a></p><ol><li><p>浏览器缓存中查询</p></li><li><p>系统缓存中查询，本地的hosts文件</p></li><li><p>路由器缓存</p></li><li><p>主机开始****递归查询****本地域名服务器。</p><ol><li><p>先查本地域名服务器的缓存。如果没有，继续下一步</p></li><li><p>本地域名服务器代替主机，以DNS client的身份，进行下一步查询，这个查询过程称为<em><strong>*迭代查询*</strong></em></p></li></ol><p>​    ① 请求根域名服务器，返回com服务器地址</p><p>​    ② 请求com服务器，返回bytedance.com服务器地址</p><p>​    ③ 请求bytedance.com服务器，返回<a href="http://www.bytedance.com/">www.bytedance.com</a>服务器地址</p><ol start="3"><li>把这个地址返回给主机</li></ol></li></ol><p>本地DNS服务器一般是网络服务商提供的DNS，也可以自己修改为常用的公共DNS。</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps31.jpg" alt="img"> </p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps32.jpg" alt="img"> </p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps33.jpg" alt="img"> </p><h2 id="2-域名解析记录"><a href="#2-域名解析记录" class="headerlink" title="2. 域名解析记录"></a>2. <em><strong>域名解析记录</strong></em></h2><p>域名注册完成后首先需要做域名解析，即把域名指向网站所在服务器的IP。</p><p>域名解析时会添加解析记录，这些记录有：A记录、AAAA记录、CNAME记录、MX记录、NS记录、TXT记录、SRV记录、URL转发。</p><p><em><strong>*A记录*</strong>***</em>******： 将域名指向一个IPv4地址</p><p>****CNAME记录****： 将域名指向另一个域名，实现与被指向域名相同的访问效果</p><p>****NS记录****：将子域名指定某个域名服务器来解析</p><p>****SOA记录****：起始授权机构记录，用于在众多NS记录中标记哪一台是主服务器</p><p>****AAAA记录****： 将域名指向一个IPv6地址</p><p>****MX记录****： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录</p><p>****TXT记录****： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录</p><p>****SRV记录****：记录哪台计算机提供哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）</p><p>****PTR记录****： A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名</p><p><em><strong>*显性*</strong>***</em>*URL转发记录****： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址。例如：将<a href="http://www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。">www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。</a></p><p><em><strong>*隐性*</strong>***</em>*UR转发记录L****： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将<a href="http://www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn。">www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn。</a></p><h2 id="3-我的域名如何实现"><a href="#3-我的域名如何实现" class="headerlink" title="3. 我的域名如何实现"></a>3. <em><strong>我的域名如何实现</strong></em></h2><p>购买域名<a href="https://www.namesilo.com/">https://www.namesilo.com/</a></p><p>配置自己域名的CNAME Record：</p><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps34.jpg" alt="img"> </p><p>设置github自定义域名：</p><p>本地博客public目录下新建CNAME文件(无后缀名,纯文件),在其中填入新的域名</p><p>juliajiang.top</p><h2 id="4-在浏览器中输入-url地址直到显示页面的过程"><a href="#4-在浏览器中输入-url地址直到显示页面的过程" class="headerlink" title="4. 在浏览器中输入***url地址直到显示页面的过程*******"></a>4. <em><strong>在浏览器中输入</strong>***</em>url地址<strong><strong><strong>直到</strong></strong></strong>显示<strong><strong><strong>页面</strong></strong></strong>的过程*******</h2><ol><li><p>浏览器输入url后，DNS解析</p><p>① DNS，查找过程：浏览器缓存、路由器缓存、DNS缓存</p></li><li><p>建立TCP连接</p><p>① TCP：与服务器建立TCP连接（传输层）</p><p>② IP：建立TCP连接时，需要发送数据，发送数据在网络层使用IP协议（网络层）</p><p>③ OSPF：open shortest path first开放最短路径优先，IP数据包在路由器之间进行选择时使用（网络层）</p><p>④ ARP：路由器在与服务器通信时，将IP地址转为MAC地址（数据链路层）</p></li><li><p>浏览器向web服务器发送http请求</p><p>① HTTP：使用http协议访问网页（应用层）</p></li><li><p>服务器处理请求，并返回http报文</p></li><li><p>浏览器解析渲染页面</p></li><li><p>连接结束</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-DNS&quot;&gt;&lt;a href=&quot;#1-DNS&quot; class=&quot;headerlink&quot; title=&quot;1. DNS&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;DNS&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;域名系统(Domain Name System：将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机体系结构</title>
    <link href="http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2021-09-10T05:28:07.000Z</published>
    <updated>2021-09-10T06:44:31.189Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/wps30.jpg" alt="img"> </p> <span id="more"></span><h3 id="1-对比"><a href="#1-对比" class="headerlink" title="1. 对比"></a>1. <em><strong>对比</strong></em></h3><p>OSI模型：是一个完整的、完善的宏观理论模型</p><p>TCP/IP：更加侧重的是围绕TCP/IP协议展开的一系列通信协议的分层</p><h3 id="2-OSI每一层的作用"><a href="#2-OSI每一层的作用" class="headerlink" title="2. OSI每一层的作用"></a>2. <em><strong>OSI每一层的作用</strong></em></h3><table><thead><tr><th><em><strong>*OSI七层模型*</strong></em></th><th><em><strong>*功能*</strong></em></th><th><em><strong>*对应的网络协议*</strong></em></th></tr></thead><tbody><tr><td><em><strong>*应用层*</strong></em></td><td>应用层是网络体系中最高的一层，也是唯一面向用户的一层，也可视为****为用户提供常用的应用程序****，每个网络应用都对应着不同的协议</td><td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td></tr><tr><td><em><strong>*表示层*</strong></em></td><td>主要负责****数据格式的转换****，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密，同时也对应用层的协议进行翻译</td><td>Telnet, Rlogin, SNMP, Gopher</td></tr><tr><td><em><strong>*会话层*</strong></em></td><td>负责网络中两节点的建立，在数据传输中****维护计算机网络中两台计算机之间的通信连接****，并决定何时终止通信</td><td>SMTP, DNS</td></tr><tr><td><em><strong>*传输层*</strong></em></td><td>是整个网络关键的部分，是实现****两个用户进程间端到端的可靠通信，****处理数据包的错误等传输问题。是向下通信服务最高层，向上用户功能最底层。即向网络层提供服务，向会话层提供独立于网络层的传送服务和可靠的透明数据传输。</td><td>TCP, UDP</td></tr><tr><td><em><strong>*网络层*</strong></em></td><td>进行逻辑地址寻址，实现不同****网络之间的路径选择****，IP就在网络层</td><td>IP, ICMP, ARP, RARP, AKP, UUCP</td></tr><tr><td><em><strong>*数据链路层*</strong></em></td><td>物理地址（MAC地址），网络设备的唯一身份标识。****建立逻辑连接、进行硬件地址寻址****，相邻的两个设备间的互相通信</td><td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继</td></tr><tr><td><em><strong>*物理层*</strong></em></td><td>七层模型中的最底层，主要是****物理介质传输媒介*<em><strong>（网线或者是无线），</strong></em>*在不同设备中传输比特****，将0/1信号与电信号或者光信号互相转化</td><td>IEEE 802.1A, IEEE 802.2到IEEE 802</td></tr></tbody></table><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="3-五层-每一层作用"><a href="#3-五层-每一层作用" class="headerlink" title="3. 五层 每一层作用"></a>3. <em><strong>五层</strong></em> <em><strong>每一层作用</strong></em></h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><em><strong>应用层</strong></em></h4><ol><li><p>任务：应用进程间的通信和交互。</p></li><li><p>应用层协议：域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP</p></li><li><p>交互的数据单元称为报文</p></li></ol><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a><em><strong>运输层</strong></em></h4><ol><li><p>任务：负责向两台主机进程之间的通信提供的数据传输服务。应用进程利用该服务传送应用层报文。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用是运输层把收到的信息分别交付上面应用层中的相应进程。</p></li><li><p>两种协议</p><ol><li><p>传输控制协议 TCP（Transmission Control Protocol），提供面向连接的，可靠的数据传输服务</p></li><li><p>用户数据协议 UDP（User Datagram Protocol），提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</p></li></ol></li></ol><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><em><strong>网络层</strong></em></h4><ol><li><p>任务：选择合适的网间路由和交换结点，确保数据及时传送。</p></li><li><p>数据单元：IP数据报。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。</p></li><li><p>协议：无连接的网际协议IP（Internet Protocol）和许多路由选择协议ARP RARP OSPF</p></li><li><p>注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p></li></ol><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ol><li><p>任务：两台主机之间的链路上的数据传输 </p></li><li><p>数据单元：帧。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p></li></ol><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><em><strong>物理层</strong></em></h4><ol><li><p>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p></li><li><p>数据单位：比特。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/wps30.jpg&quot; alt=&quot;img&quot;&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://example.com/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-09-10T05:25:12.000Z</published>
    <updated>2021-09-10T06:45:03.380Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="复杂度总结"><a href="#复杂度总结" class="headerlink" title="复杂度总结"></a><em><strong>复杂度总结</strong></em></h4><p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/wps29.jpg" alt="img"> </p><span id="more"></span><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a><em><strong>思路</strong></em></h4><h5 id="（1）直接插入"><a href="#（1）直接插入" class="headerlink" title="*（1）直接插入*"></a><em><strong>*（1）直接插入*</strong></em></h5><p>每次将一个待排序的数据，插入到前面已经排好序的序列之中，直到全部数据插入完成。</p><h5 id="（2）-二分法插入排序"><a href="#（2）-二分法插入排序" class="headerlink" title="*（2） 二分法插入排序*"></a><em><strong>*（2） 二分法插入排序*</strong></em></h5><p>首先取出原有序中间数与新插的数比较，然后插入新数大小包含于其中的一半数组，再次取该数组中间数,如此重复下去，直至最后得到数组个数为一，将最后得到的数之后的数后移，然后将新插入的数放在该索引处。</p><h5 id="（3）希尔排序"><a href="#（3）希尔排序" class="headerlink" title="*（3）希尔排序*"></a><em><strong>*（3）希尔排序*</strong></em></h5><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称希尔排序为“跳着插”</p><h5 id="（4）简单选择排序"><a href="#（4）简单选择排序" class="headerlink" title="*（4）简单选择排序*"></a><em><strong>*（4）简单选择排序*</strong></em></h5><p>数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，直到整个数组变有序区。</p><h5 id="（5）堆排序"><a href="#（5）堆排序" class="headerlink" title="*（5）堆排序*"></a><em><strong>*（5）堆排序*</strong></em></h5><p>堆排序的难点就在于堆的的插入和删除。</p><p>堆的插入就是——每次插入都是将新数据放在数组最后，而从这个新数据的父结点到根结点必定是一个有序的数列，因此只要将这个新数据插入到这个有序数列中即可。</p><p>堆的删除就是——堆的删除就是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点开始将一个数据在有序数列中进行“下沉”。</p><p>因此，堆的插入和删除非常类似直接插入排序，只不是在二叉树上进行插入过程。所以可以将堆排序形容为“树上插”</p><h5 id="（6）冒泡排序"><a href="#（6）冒泡排序" class="headerlink" title="*（6）冒泡排序*"></a><em><strong>*（6）冒泡排序*</strong></em></h5><p>通过交换使相邻的两个数变成小数在前大数在后，这样每次遍历后，最大的数就“沉”到最后面了。重复N次即可以使数组有序。</p><p>冒泡排序改进1：在某次遍历中如果没有数据交换，说明整个数组已经有序。因此通过设置标志位来记录此次遍历有无数据交换就可以判断是否要继续循环。</p><p>冒泡排序改进2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</p><h5 id="（7）快速排序"><a href="#（7）快速排序" class="headerlink" title="*（7）快速排序*"></a><em><strong>*（7）快速排序*</strong></em></h5><p>“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。因此将数组分成二部分再分别重复上述步骤就完成了排序。</p><h5 id="（8）归并排序"><a href="#（8）归并排序" class="headerlink" title="*（8）归并排序*"></a><em><strong>*（8）归并排序*</strong></em></h5><p>当一个数组左边有序，右边也有序，那合并这两个有序数组就完成了排序。如何让左右两边有序了？用递归！这样递归下去，合并上来就是归并排序。</p><h5 id="（9）基数排序"><a href="#（9）基数排序" class="headerlink" title="*（9）基数排序*"></a><em><strong>*（9）基数排序*</strong></em></h5><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;复杂度总结&quot;&gt;&lt;a href=&quot;#复杂度总结&quot; class=&quot;headerlink&quot; title=&quot;复杂度总结&quot;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;复杂度总结&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/wps29.jpg&quot; alt=&quot;img&quot;&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>常用数据结构总结</title>
    <link href="http://example.com/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</id>
    <published>2021-09-10T05:08:03.000Z</published>
    <updated>2021-09-10T06:44:49.905Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.<em>数组</em></h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><em>概念</em></h4><p><strong>数组</strong>（Array） 是一种很常见的数据结构。它由****相同类型的元素****（element）组成，并且是使用一块连续的内存来存储。</p><p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p><p>数组的特点是：****提供随机访问 并且容量有限****。</p> <span id="more"></span><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong><strong>使用场景</strong></strong></h4><p>1）数据量较小。</p><p>2）数据规模已知。</p><p>3）随机访问，修改元素值。</p><p>如果插入速度很重要，选择无序数组。如果查找速度很重要，选择有序数组，并使用二分查找。</p><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. <em>链表</em></h2><p>****链表*<em><strong>（LinkedList） 虽然是一种</strong></em>*线性表****，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p><p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在<em><strong>*查找一个节点或者访问特定位置的节点的时候复杂度为 O(n)*</strong></em> 。</p><p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p><h4 id="链表分类"><a href="#链表分类" class="headerlink" title="链表分类"></a>链表分类</h4><ol><li><p>单链表</p></li><li><p>双向链表</p></li><li><p>循环链表</p></li><li><p>双向循环链表</p></li></ol><p><strong>单链表</strong></p><p>单链表 单向链表****只有一个方向，结点只有一个后继指针 next 指向后面的节点****。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p><p><strong>循环链表</strong></p><p>循环链表 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p><p><strong>双向链表</strong></p><p>双向链表 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p><p><strong>双向循环链表</strong></p><p>双向循环链表 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>如果需要支持随机访问的话，链表没办法做到。</p><p>如果需要****存储的数据元素的个数不确定*<em><strong>，并且需要</strong></em>*经常添加和删除数据****的话，使用链表比较合适。</p><p>如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。</p><h4 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h4><p>· 数组支持随机访问，而链表不支持。</p><p>· 数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</p><p>· 数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</p><h2 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>****栈 (stack)*<em><strong>只允许在</strong></em>*有序的线性数据集合的一端（称为栈顶 top）进行加入数据****（push）和移除数据（pop）。因而按照 <em><strong>*后进先出*<em><strong>（LIFO, Last In First Out） 的原理运作。在栈中，</strong></em>*push 和 pop 的操作都发生在栈顶。*</strong></em></p><p>栈常用一维****数组或链表****来实现，用数组实现的栈叫作 顺序栈 ，用链表实现的栈叫作 链式栈 。</p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 后进先出（LIFO, Last In First Out） 的特性时，我们就可以使用栈这个数据结构。</p><p><strong>1.实现浏览器的回退和前进功能</strong></p><p>我们只需要使用<em><strong>*两个栈*</strong></em>(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 ****1,2,3,4 这四个页面压入 Stack1 中****。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 ****4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中****。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。</p><p>2.<strong>检查符号是否成对出现</strong></p><p>括号匹配问题：</p><ol><li><p>首先我们将括号间的对应规则存放在 Map 中，这一点应该毋容置疑；</p></li><li><p>创建一个栈。遍历字符串，如果字符是****左括号就直接加入stack中****，否则将stack 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果stack为空，返回 true。</p></li></ol><p>3.<strong>反转字符串</strong></p><p>将字符串中的每个字符先入栈再出栈就可以了。</p><p>4.<strong>维护函数调用</strong></p><p>最后一个被调用的函数必须先完成执行，符合栈的 后进先出（LIFO, Last In First Out） 特性。</p><h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h2><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>队列 是 <em><strong>*先进先出*</strong></em>( FIFO，First In, First Out) 的线性表。在具体应用中通常用****链表或者数组*<em><strong>来实现，用数组实现的队列叫作 顺序队列 ，用链表实现的队列叫作 链式队列 。队列只允许在</strong></em>*后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除****操作也就是出队 dequeue</p><p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p><h4 id="队列分类"><a href="#队列分类" class="headerlink" title="队列分类"></a>队列分类</h4><p><strong>单队列</strong></p><p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <em><strong>*顺序队列（数组实现）*</strong></em> 和 ****链式队列（链表实现）****。</p><p><em><strong>*顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。*</strong></em></p><p><strong>循环队列</strong></p><p>****循环队列*<em><strong>可以解决顺序队列的</strong></em>*假溢出和越界问题****。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p><p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p><p><strong>·</strong> <em><strong>阻塞队列：</strong></em> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</p><p><strong>·</strong> <em><strong>线程池中的请求/任务队列：</strong></em> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：FixedThreadPool 使用无界队列 LinkedBlockingQueue。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出java.util.concurrent.RejectedExecutionException 异常。</p><p>· Linux 内核进程队列（按优先级排队）</p><p>· 现实生活中的派对，播放器上的播放列表;</p><p>· 消息队列</p><h2 id="5-图"><a href="#5-图" class="headerlink" title="5. 图"></a>5. 图</h2><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>图就是由****顶点*<em><strong>的有穷非空集合和</strong></em>*顶点之间的边**<strong>组成的集合。通常表示为：</strong>G(V,E)**，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>无向图和有向图</strong></p><p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就<em><strong>不用关注方向，用不带箭头的边表示，这样的图就是无向图。</strong></em></p><p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是<strong>有向图</strong>。</p><p><strong>无权图和带权图</strong></p><p>对于一个关系，如果我们只****关心关系的有无，而不关心关系有多强*<em><strong>，那么就可以用</strong></em>*无权图****表示二者的关系。</p><p>对于一个关系，如果我们****既关心关系的有无，也关心关系的强度*<em><strong>，比如描述地图上两个城市的关系，需要用到距离，那么就用</strong></em>*带权图****来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。</p><h4 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h4><p><strong>邻接矩阵存储</strong></p><p>邻接矩阵将图用****二维矩阵存储****，是一种较为直观的表示方式。</p><p>如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 A[i][j]=n 。</p><p>在****无向图****中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，A[i][j]=1，当顶点i和顶点j没有关系时，A[i][j]=0。</p><p><strong>邻接表存储</strong></p><p>针对上面<em><strong>*邻接矩阵比较浪费内存空间*<em><strong>的问题，诞生了图的另外一种存储方法—</strong></em>*邻接表*</strong></em> 。</p><p>邻接链表使用****一个链表来存储某个顶点的所有后继相邻顶点****。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 邻接表。</p><h4 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h4><p><strong>广度优先搜索-队列</strong></p><p>广度优先搜索就像水面上的波纹一样一层一层向外扩展。</p><p><strong>深度优先搜索-栈</strong></p><p>深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”。</p><h2 id="6-堆"><a href="#6-堆" class="headerlink" title="6. 堆"></a>6. 堆</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>堆是一种满足以下条件的树：</p><p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p><p><strong>·</strong> <em><strong>堆不一定是完全二叉树</strong></em>，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。</p><p>· （<em><strong>二叉</strong></em>）堆是一个数组，它可以被看成是一个 ****近似的完全二叉树****。——《算法导论》第三版</p><h4 id="堆的用途"><a href="#堆的用途" class="headerlink" title="堆的用途"></a>堆的用途</h4><p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p><p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 O(nlog(n))，查找最大值或者最小值时间复杂度都是 O(1)，但是，涉及到更新（插入或删除）数据时，时间复杂度为 O(n)，即使是使用复杂度为 O(log(n)) 的二分法找到要插入或者删除的数据，在移动数据时也需要 O(n) 的时间复杂度。</p><p><em><strong>*相对于有序数组而言，堆的主要优势在于更新数据效率较高。*</strong></em> 堆的初始化时间复杂度为 O(nlog(n))，堆可以做到O(1)时间复杂度取出最大值或者最小值，O(log(n))时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。</p><h4 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h4><p>堆分为 <em><strong>*最大堆*</strong></em> 和 ****最小堆****。二者的区别在于节点的排序方式。</p><p><strong>·</strong> <em><strong>*最大堆*</strong></em> ：堆中的每一个节点的值都大于等于子树中所有节点的值</p><p><strong>·</strong> <em><strong>*最小堆*</strong></em> ：堆中的每一个节点的值都小于等于子树中所有节点的值</p><h4 id="堆的操作总结"><a href="#堆的操作总结" class="headerlink" title="堆的操作总结"></a>堆的操作总结</h4><p><strong>·</strong> <em><strong>*插入元素*</strong></em> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</p><p><strong>·</strong> <em><strong>*删除堆顶元素*</strong></em> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</p><h2 id="7-树"><a href="#7-树" class="headerlink" title="7. 树"></a>7. 树</h2><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a><em>概念</em></h4><p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。</p><p>一棵树具有以下特点：</p><ol><li><p>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</p></li><li><p>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</p></li><li><p>一棵树不包含回路。</p></li></ol><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>①　二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p><p>②　二叉树 的分支通常被称作“左子树”或“右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒。</p><p>③　二叉树 的第 i 层至多拥有 2^(i-1) 个节点，深度为 k 的二叉树至多总共有 2^k-1 个节点</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 ****满二叉树****。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 ****满二叉树****。如下图所示：</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 <em><strong>*完全二叉树*</strong></em> 。</p><p>大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><em><strong>平衡二叉树</strong></em> 是一棵二叉排序树，且具有以下性质：</p><ol><li><p>可以是一棵空树</p></li><li><p>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p></li></ol><p>平衡二叉树的常用实现方法有 <em><strong>红黑树</strong></em>、<em><strong>AVL 树</strong></em>、<em><strong>替罪羊树</strong></em>、<em><strong>加权平衡树</strong></em>、<em><strong>伸展树</strong></em> 等。</p><h4 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h4><p>二叉树的存储主要分为 <em><strong>*链式存储*</strong></em> 和 <em><strong>*顺序存储*</strong></em> 两种：</p><p><strong>链式存储</strong></p><p>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。</p><p>每个节点包括三个属性：</p><p>· 数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</p><p>· 左节点指针 left</p><p>· 右节点指针 right。</p><p><strong>顺序存储</strong></p><p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2 _ i 的位置，它的右子节点存储在下标为 2 _ i+1 的位置。</p><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>先序、中序、后续</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉查找树：为了实现快速查找而生。要求在树的任意一个节点，左子树中每个节点的值都小于这个节点的值，右子树中每个节点的值都大于这个节点。</p><h4 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树：二叉树中任意一个节点的左右子树的高度相差不能大于1.</p><p>平衡二叉查找树：（很多并没有严格符合上述定义）</p><p>****设计初衷*****：解决普通二叉查找树在频繁插入、删除等动态更新情况下，出现的复杂度退化问题。让整个树比较平衡。</p><p>平衡二叉树有哪些：</p><p>​    AVL树，高度平衡的二叉查找树</p><p>​    红黑树，根节点到各个叶子结点的最大路径可能会比最短路径大一倍。</p><p>​    Splay Tree伸展树</p><p>​    Treap树堆</p><p><em><strong>*如何保持平衡：*</strong></em></p><p>根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。</p><p>分为LL型、RR型、LR型和RL型4种类型</p><p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps25.jpg" alt="img"> </p><p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps26.jpg" alt="img"> </p><p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps27.jpg" alt="img"> </p><p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps28.jpg" alt="img"> </p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是平衡二叉查找树的一种。</p><p><em><strong>*红黑树*</strong></em></p><p>Red-Black Tree，R-B Tree，不严格的平衡二叉查找树，做到了近似平衡。</p><p>解决普通二叉查找树在频繁插入、删除等动态更新情况下，出现的复杂度退化问题。让整个树比较平衡。</p><p>红黑树的高度近似log2n，插入、删除、查找操作的时间复杂度都是O(logn)。</p><p>红黑树是一种性能非常稳定的二叉查找树。</p><p>相比于AVL，<em><strong>*红黑树优势：*</strong></em></p><p>引入RB-Tree是功能、性能、空间开销的折中结果。</p><ol><li><p>维护成本：红黑树较小，AVL更大</p></li><li><p>读取性能：红黑树略逊于AVL</p></li><li><p>空间开销：两者类似，内容极多时略优于AVL</p></li></ol><p>基本上主要的几种平衡树看来，红黑树有着良好的稳定性，综合实力强。实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p><p>定义：红黑树中的节点一类被标记为黑色，一类标记为红色，还有几个要求：</p><ol><li><p>根节点为黑色</p></li><li><p>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据</p></li><li><p>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的</p></li><li><p>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点</p></li></ol><h4 id="红黑树、B-树"><a href="#红黑树、B-树" class="headerlink" title="红黑树、B+树"></a>红黑树、B+树</h4><p>红黑树多用在内部排序，即全放在内存中的，STL的map和set的内部实现就是红黑树。</p><p>B+树多用于外存上时，B+也被成为一个磁盘友好的数据结构。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-数组&quot;&gt;&lt;a href=&quot;#1-数组&quot; class=&quot;headerlink&quot; title=&quot;1.数组&quot;&gt;&lt;/a&gt;1.&lt;em&gt;数组&lt;/em&gt;&lt;/h2&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;em&gt;概念&lt;/em&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;（Array） 是一种很常见的数据结构。它由****相同类型的元素****（element）组成，并且是使用一块连续的内存来存储。&lt;/p&gt;
&lt;p&gt;我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。&lt;/p&gt;
&lt;p&gt;数组的特点是：****提供随机访问 并且容量有限****。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="http://example.com/2021/09/10/Spring/Mybatis/"/>
    <id>http://example.com/2021/09/10/Spring/Mybatis/</id>
    <published>2021-09-10T05:00:40.000Z</published>
    <updated>2021-09-10T06:37:39.684Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.<em><strong>优点</strong></em></h3><p>MyBatis框架的优点：</p><ol><li><p>与JDBC相比，减少了50%以上的代码量</p></li><li><p>MyBatis是最简单的持久化框架，小巧并且简单易学</p></li><li><p>MyBatis灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，降低耦合度，便于统一管理和优化，可重用</p></li><li><p>提供XML标签，支持编写动态SQL语句（XML中使用if, else）</p></li><li><p>提供映射标签，支持对象与数据库的ORM字段关系映射（在XML中配置映射关系，也可以使用注解）。</p><span id="more"></span></li></ol><p>缺点：</p><ol><li><p>SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求</p></li><li><p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p></li></ol><p>MyBatis框架适用场合：</p><p>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</p><p>对性能的要求很高，或者需求变化较多的项目，如互联网项目</p><h3 id="2-Mybatis一级缓存-二级缓存"><a href="#2-Mybatis一级缓存-二级缓存" class="headerlink" title="2. Mybatis一级缓存 二级缓存"></a>2. <em><strong>Mybatis一级缓存 二级缓存</strong></em></h3><p>针对查询操作，mybatis支持通过缓存的方式来减少SQL的调用，提高查询性能。在缓存级别方面分为一级缓存和二级缓存，区别：</p><ol><li><p>一级缓存的粒度较小，是与某个SqlSession绑定的，只对该SqlSession的相关查询操作进行缓存，不同SqlSession实例之间相互不影响，缓存为使用本地内存实现</p></li><li><p>二级缓存是一种全局缓存，是由所有SqlSession实例所共享的，即不同SqlSession实例查询时产生的缓存，对其他SqlSession实例可见</p></li></ol><h3 id="3"><a href="#3" class="headerlink" title="3. #{} ${}"></a>3. <em><strong>#{}</strong></em> <em><strong>${}</strong></em></h3><p>${}是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。</p><p>#{}是 sql 的参数占位符，MyBatis 会将 sql 中的#{}替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName()。</p><h3 id="4-mybatis和jdbc区别"><a href="#4-mybatis和jdbc区别" class="headerlink" title="4. mybatis和jdbc区别"></a>4. <em><strong>mybatis和jdbc区别</strong></em></h3><p><em><strong>JDBC</strong></em>是Java提供的一个操作数据库的API；</p><p><em><strong>MyBatis</strong></em>是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p><p>MyBatis是对JDBC的封装。相对于JDBC，MyBatis有以下优点：</p><p><em><strong>*1. 优化获取和释放*</strong></em></p><p>我们一般在访问数据库时都是通过数据库连接池来操作数据库，数据库连接池有好几种，比如C3P0、DBCP，也可能采用容器本身的JNDI数据库连接池。我们可以通过DataSource进行隔离解耦，我们统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，所以我们将DataSource的具体实现通过让用户配置来应对变化。</p><p>C3P0 xml配置：</p><p><bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"><br>  <property name="driverClass" value=" oracle.jdbc.driver.OracleDriver ">   </property></bean></p>  <property name="jdbcUrl" value=" jdbc:oracle:thin:@localhost:1521:ora9i ">     <property name="user" value="admin">     <property name="password" value="1234">    <p>DBCP xml配置：</p><p><bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"><br>  <property name="driverClassName" value="com.mysql.jdbc.Driver"><br>  <property name="url" value="jdbc:mysql://localhost:3309/sampledb"><br>  <property name="username" value="root"><br>  <property name="password" value="1234"><br></property></property></property></property></bean></p><p>DURID xml配置：</p><bean name="dataSource" class="com.alibaba.druid.pool.DruidDataSource"> <p>　　<property name="driverClassName"> </property></p><p>　　　　<value>com.mysql.jdbc.Driver</value> </p><p>　　</p></bean></property> <p></p><p>　　<property name="url"> </property></p><p>　　　　<value>${jdbc_url_gx}</value> </p><p>　　</p></property> <p></p><p>　　<property name="username"> </property></p><p>　　　　<value>${jdbc_username_gx}</value> </p><p>　　</p></property> <p></p><p>　　<property name="password"> </property></p><p>　　　　<value>${jdbc_password_gx}</value> </p><p>　　 </p><p><em><strong>*2.SQL统一管理，对数据库进行存取操作*</strong></em></p><p>我们使用JDBC对数据库进行操作时，SQL查询语句分布在各个Java类中，这样可读性差，不利于维护，当我们修改Java类中的SQL语句时要重新进行编译。</p><p>Mybatis可以把SQL语句放在配置文件中统一进行管理，以后修改配置文件，也不需要重新就行编译部署。</p><p><em><strong>*3.生成动态SQL语句*</strong></em></p><p>我们在查询中可能需要根据一些属性进行组合查询，比如我们进行商品查询，我们可以根据商品名称进行查询，也可以根据发货地进行查询，或者两者组合查询。如果使用JDBC进行查询，这样就需要写多条SQL语句。</p><p>Mybatis可以在配置文件中通过使用<if test="””"></if>标签进行SQL语句的拼接，生成动态SQL语句。比如下面这个例子：</p><select id="getCountByInfo" parametertype="User" resulttype="int">     select count(*) from user     <where>       <if test="nickname!=null">         and nickname = #{nickname}       </if>       <if test="email!=null">         and email = #{email}       </if>     </where></select><p>就是通过昵称或email或者二者的组合查找用户数。</p><p><em><strong>*4.能够对结果集进行映射*</strong></em></p><p>我们在使用JDBC进行查询时，返回一个结果集ResultSet,我们要从结果集中取出结果封装为需要的类型</p><p>在Mybatis中我们可以设置将结果直接映射为自己需要的类型，比如：JavaBean对象、一个Map、一个List等等。像上个例子中就是将结果映射为int类型。</p><h3 id="5-xml映射文件常见标签"><a href="#5-xml映射文件常见标签" class="headerlink" title="5. xml映射文件常见标签"></a>5. <em><strong>xml映射文件常见标签</strong></em></h3><p>select|insert|update|delete</p><p><resultMap><parameterMap></parameterMap></resultMap></p><p><sql> sql 片段标签</sql></p><p><include> 引入 sql 片段</include></p><p><selectKey> 为不支持自增的主键生成策略标签</selectKey></p><p>动态 sql 的 9 个标签：</p><p>trim|where|set|foreach|if|choose|when|otherwise|bind</p><h3 id="6-Da-o-接口工作原理"><a href="#6-Da-o-接口工作原理" class="headerlink" title="6. Da***o***接口工作原理"></a>6. <em><strong>Da</strong>***</em>o***<em><strong>接口工作原理</strong></em></h3><p>最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</p><p>Dao 接口，就是人们常说的 Mapper接口。</p><p>接口的全限名就是xml中的 namespace 的值，接口的方法名就是xml中MappedStatement的 id 值，接口方法内的参数就是传递给 sql 的参数。</p><p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个xml中的MappedStatement。</p><p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将 sql 执行结果返回。</p><p>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在 MyBatis 中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</delete></update></insert></select></p><p>Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复。可以这样实现：（能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法）</p><p>public interface StuMapper {</p><p>  List<Student> getAllStu();</Student></p><p>  List<Student> getAllStu(@Param(“id”) Integer id);</Student></p><p>}</p>  <select id="getAllStu" resulttype="com.pojo.Student"><p>​     select * from student</p><p>​    <where></where></p><p>​      <if test="id != null"></if></p><p>​        id = #{id}</p><p>​      </p><p>​    </p>   </select><h3 id="7-动态-sql"><a href="#7-动态-sql" class="headerlink" title="7.动态 sql"></a>7.<em><strong>动态 sql</strong></em></h3><p>是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</p><p>MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。</p><p>MyBatis 提供了 9 种动态 sql 标签 trim|where|set|foreach|if|choose|when|otherwise|bind</p><p>其执行原理：使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p><h3 id="8-如何将-sql-执行结果封装为目标对象并返回"><a href="#8-如何将-sql-执行结果封装为目标对象并返回" class="headerlink" title="8. 如何将 sql 执行结果封装为目标对象并返回"></a>8. <em><strong>如何将 sql 执行结果封装为目标对象并返回</strong></em></h3><p>MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</p><p>映射形式：</p><ol><li><p>使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系</resultMap></p></li><li><p>使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p></li></ol><p>如何：有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h3 id="9-一对一、一对多的关联查询"><a href="#9-一对一、一对多的关联查询" class="headerlink" title="9. 一对一、一对多的关联查询"></a>9. <em><strong>一对一、一对多的关联查询</strong></em></h3><p>MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</p><p>能，MyBatis 不仅可以执行一对一、一对多的关联查询</p><p>还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为 selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为 selectList()即可。</p><p>关联对象查询，有两种实现方式：</p><ol><li><p>单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。</p></li><li><p>使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p></li></ol><p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据列值来完成 100 条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。</id></id></resultMap></p><p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p><h3 id="10-是否支持延迟加载"><a href="#10-是否支持延迟加载" class="headerlink" title="10. 是否支持延迟加载"></a>10. <em><strong>是否支持延迟加载</strong></em></h3><p>MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</p><p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。</p><p>association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。</p><p>原理：使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><h3 id="11-不同的-Xml-映射文件，id-是否可以重复"><a href="#11-不同的-Xml-映射文件，id-是否可以重复" class="headerlink" title="11. 不同的 Xml 映射文件，id 是否可以重复"></a>11. <em><strong>不同的 Xml 映射文件，id 是否可以重复</strong></em></h3><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p><p>原因就是 namespace+id 是作为 Map&lt;String, MappedStatement&gt;的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p><h3 id="12-如何执行批处理？"><a href="#12-如何执行批处理？" class="headerlink" title="12. 如何执行批处理？"></a>12. <em><strong>如何执行批处理？</strong></em></h3><p>使用 BatchExecutor 完成批处理。</p><h3 id="13-Executor-执行器"><a href="#13-Executor-执行器" class="headerlink" title="13. Executor 执行器"></a>13. <em><strong>Executor 执行器</strong></em></h3><p>MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？ </p><ol><li><p>SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象</p></li><li><p>ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p></li><li><p>BatchExecutor：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p></li></ol><p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p><p>在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 DefaultSqlSessionFactory 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p><h3 id="14-是否可以映射枚举类"><a href="#14-是否可以映射枚举类" class="headerlink" title="14. 是否可以映射枚举类"></a>14. <em><strong>是否可以映射枚举类</strong></em></h3><p>MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。</p><p>映射方式为自定义一个 TypeHandler，实现 TypeHandler 的 setParameter()和 getResult()接口方法。TypeHandler 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 setParameter()和 getResult()两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p><h3 id="15-引用标签后，两个标签的位置"><a href="#15-引用标签后，两个标签的位置" class="headerlink" title="15. 引用标签后，两个标签的位置"></a>15. <em><strong>引用标签后，两个标签的位置</strong></em></h3><p>MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</p><p>虽然 MyBatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。</p><p>原理是：MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p><h3 id="16-xml和内部数据结构映射关系"><a href="#16-xml和内部数据结构映射关系" class="headerlink" title="16. xml和内部数据结构映射关系"></a>16. <em><strong>xml和内部数据结构映射关系</strong></em></h3><p>简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</p><p>MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。</p><p><parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</parameterMap></p><p><resultMap>标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</resultMap></p><p>每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象。</delete></update></insert></select></p><p>标签内的 sql 会被解析为 BoundSql 对象。</p><h3 id="17-为什么说-MyBatis-是半自动-ORM-映射工具"><a href="#17-为什么说-MyBatis-是半自动-ORM-映射工具" class="headerlink" title="17. 为什么说 MyBatis 是半自动 ORM 映射工具"></a>17. <em><strong>为什么说</strong></em> <em><strong>MyBatis 是半自动 ORM 映射工具</strong></em></h3><p>为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</p><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p><p>而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p><p> 摘自：</p><p><a href="https://blog.csdn.net/qiushisoftware/article/details/98944211">https://blog.csdn.net/qiushisoftware/article/details/98944211</a></p><p> <a href="https://www.cnblogs.com/love-Stefanie/p/6838269.html">https://www.cnblogs.com/love-Stefanie/p/6838269.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-优点&quot;&gt;&lt;a href=&quot;#1-优点&quot; class=&quot;headerlink&quot; title=&quot;1.优点&quot;&gt;&lt;/a&gt;1.&lt;em&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;MyBatis框架的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;与JDBC相比，减少了50%以上的代码量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MyBatis是最简单的持久化框架，小巧并且简单易学&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MyBatis灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，降低耦合度，便于统一管理和优化，可重用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供XML标签，支持编写动态SQL语句（XML中使用if, else）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供映射标签，支持对象与数据库的ORM字段关系映射（在XML中配置映射关系，也可以使用注解）。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Mybatis" scheme="http://example.com/categories/Mybatis/"/>
    
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="http://example.com/2021/09/10/Spring/Servlet/"/>
    <id>http://example.com/2021/09/10/Spring/Servlet/</id>
    <published>2021-09-10T04:56:49.000Z</published>
    <updated>2021-09-10T06:58:19.172Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-Servlet是什么"><a href="#1-Servlet是什么" class="headerlink" title="1. Servlet是什么"></a>1. Servlet是什么</h3><p>Servlet定义：一段处理 web 请求的逻辑</p><p>在Java中，servlet是一个接口，规定请求从容器到达 web 服务端的规范，最重要的三个步骤是:</p><ol><li><p>init()：初始化请求的时候要做什么；</p></li><li><p>service()：拿到请求的时候要做什么；</p></li><li><p>destory()：处理完请求销毁的时候要做什么。</p><span id="more"></span></li></ol><p>所有实现 Servlet 的实现都是在这个规范的基础上进行开发。</p><p>package javax.servlet;</p><p>import java.io.IOException;</p><p>public interface Servlet {</p><p>public void <em><strong>*init*</strong></em>(ServletConfig config) throws ServletException;</p><pre><code>  public ServletConfig ***\*getServletConfig\****();    public void ***\*service\****(ServletRequest req, ServletResponse res)</code></pre><p>​      throws ServletException, IOException;</p><pre><code>  public String ***\*getServletInfo\****();    public void ***\*destroy\****();</code></pre><p>}</p><h3 id="2-Servlet容器"><a href="#2-Servlet容器" class="headerlink" title="2. Servlet容器"></a>2. Servlet容器</h3><p>Servlet 只是一个处理请求的应用程序，光有Servlet是无法运行起来的，需要有一个 main 方法去调用你的这段 Servlet 程序才行。这就需要servlet容器了。</p><p>Servlet容器的主要作用是：</p><ol><li><p>建立连接；</p></li><li><p>调用Servlet处理请求；</p></li><li><p>响应请求给客户端；</p></li><li><p>释放连接；</p></li></ol><p>常见的Servlet容器Tomcat的流程：</p><p>监听了客户端的请求端口,根据请求信息确定将请求交给哪个Servlet 处理，找到处理的Servlet之后，调用该Servlet的 service() 方法，处理完毕将对应的处理结果包装成ServletResponse 对象返回给客户端。</p><p>Servlet容器只有一个，而 Servlet 可以有多个。</p><h3 id="3-DispatcherServlet"><a href="#3-DispatcherServlet" class="headerlink" title="3. DispatcherServlet"></a>3. DispatcherServlet</h3><p>定义：是 Spring 中定义的一个 Servlet，实现了 Servlet 接口，本质也是一个 Servlet。</p><p>它是 HttpServlet 的继承者，主要处理 http 请求。</p><p>所以 Spring 程序本质是就是一个 Servlet。SpringMVC 帮你做了本该你去实现的逻辑。</p><p>Spring 的核心就是一个 Servlet,它拦截了所有的请求,将请求交给 DispatcherServlet 去处理</p><h3 id="4-Tomcat"><a href="#4-Tomcat" class="headerlink" title="4. Tomcat*"></a>4. Tomcat*</h3><p>Tomcat：常见的Servlet容器Tomcat，实现了对 Java Servlet 规范的支持</p><p>Tomcat 也提供了处理HTTP请求的能力，所以也可以作为一个Web服务器。</p><p>Tomcat如何设计？如下图：</p><p><img src="/2021/09/10/Spring/Servlet/wps23.jpg" alt="img"> </p><p>Java web 应用如果部署到 Tomcat 中，一个Tomcat就表示一个服务。</p><p>一个 Server 服务器可以包含多个 Service 服务，Tomcat 默认的 Service 服务是 Catalina</p><p>一个 Service 服务可以包含</p><p>① 多个连接器，因为 Tomcat 支持多种网络协议，包括 HTTP/1.1、HTTP/2、AJP 等等</p><p>② 一个容器，容器外部会有一层 Engine 引擎所包裹，负责与处理连接器的请求与响应，连接器与容器之间通过 ServletRequest 和 ServletResponse 对象进行交流。</p><p>Server 组件：管理 tomcat 实例的组件，可以监听一个端口</p><p>Service 组件：是一个逻辑组件，用于绑定 connector 和 container，有了 service 表示可以向外提供服务，就像是一般的 daemon 类服务的 service。可以认为一个 service 就启动一个JVM，更严格地说，一个 engine 组件才对应一个 JVM （定义负载均衡时，jvmRoute 就定义在 Engine 组件上用来标识这个 JVM ），只不过 connector 也工作在 JVM 中。</p><p>Connector 组件：监听组件，它有四个作用：</p><ol><li><p>开启监听套接字，监听外界请求，并和客户端建立 TCP 连接</p></li><li><p>使用 protocolHandler 解析请求中的协议和端口等信息，如 http 协议、AJP 协议；</p></li><li><p>根据解析到的信息，使用 processer 将分析后的请求转发给绑定的 Engine；</p></li><li><p>接收响应数据并返回给客户端。</p></li></ol><p>Container ：表示一类组件，在配置文件(server.xml)中没有体现出来。它包含4个容器类组件：Engine容器、Host容器、Context容器 和 wrapper容器。</p><p>Engine 容器用于从 Connector 组件处接收已建立的 TCP 连接，还用于接收客户端发送的 HTTP 请求并分析请求，然后按照分析的结果将相关参数传递给匹配出的虚拟主机。Engine 还用于指定默认的虚拟主机。</p><p>Host 容器定义虚拟主机，对应了服务器中一个网络名实体（如”<a href="http://www.baidu.com”,或ip地址”23.0.32.1”).为了使用户可以通过域名连接/">www.baidu.com”，或IP地址”23.0.32.1”）。为了使用户可以通过域名连接</a> Tomcat 服务器，这个域名应该在域名服务器已经注册过。</p><p>Context 容器主要是根据 path 和 docBase 获取一些信息，将结果交给其内的 wrapper 组件进行处理（它提供wrapper运行的环境，所以它叫上下文context）。一般来说，都采用默认的标准 wrapper 类，因此在 Context 容器中几乎不会出现 wrapper 组件。</p><p>wrapper 容器对应 Servlet 的处理过程。它开启 Servlet 的生命周期，根据 Context 给出的信息以及解析 web.xml 中的映射关系，负责装载相关的类，初始化 servlet 对象 init()、执行 servlet 代码 service() 以及服务结束时 servlet 对象的销毁 destory()。</p><p>摘自：</p><p><a href="https://www.cnblogs.com/rickiyang/p/12764615.html">https://www.cnblogs.com/rickiyang/p/12764615.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-Servlet是什么&quot;&gt;&lt;a href=&quot;#1-Servlet是什么&quot; class=&quot;headerlink&quot; title=&quot;1. Servlet是什么&quot;&gt;&lt;/a&gt;1. Servlet是什么&lt;/h3&gt;&lt;p&gt;Servlet定义：一段处理 web 请求的逻辑&lt;/p&gt;
&lt;p&gt;在Java中，servlet是一个接口，规定请求从容器到达 web 服务端的规范，最重要的三个步骤是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;init()：初始化请求的时候要做什么；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;service()：拿到请求的时候要做什么；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;destory()：处理完请求销毁的时候要做什么。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://example.com/2021/09/10/Spring/SpringBoot/"/>
    <id>http://example.com/2021/09/10/Spring/SpringBoot/</id>
    <published>2021-09-10T04:54:22.000Z</published>
    <updated>2021-09-10T06:43:15.866Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-Springboot是什么"><a href="#1-Springboot是什么" class="headerlink" title="1. Springboot是什么"></a>1. Springboot是什么</h3><p>Spring Boot 并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p>集成了大量常用的第三方库配置，Spring Boot中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p><span id="more"></span><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ol><li><p>SpringBoot继承了Spring优秀的基因，在Spring中开发更为方便快捷，帮助开发者快速的搭建Spring框架</p></li><li><p>简化依赖。比如创建一个 web 项目，在使用 Spring 的时需要在 pom 文件中添加多个依赖，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。</p></li><li><p>简化配置。Spring各种XML、Annotation配置会让人眼花缭乱，Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。比如@Configuration。另外，Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可</p></li><li><p>简化部署。Spring 项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里。Spring Boot 不需要在服务器上去部署 tomcat，内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 java -jar xxx.jar一键式启动项目。</p></li></ol><h3 id="3-自动装配原理"><a href="#3-自动装配原理" class="headerlink" title="3. 自动装配原理"></a>3. 自动装配原理</h3><p><em><strong>是什么</strong></em></p><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p><p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 spring-boot-starter-data-redis即可。</p><p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。自动装配可以简单理解为：通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</p><p><em><strong>如何实现？</strong></em></p><p>@SpringBootApplication可以看做以下3个的集合：</p><ol><li><p>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</p></li><li><p>@Configuration：允许在上下文中注册额外的 bean 或导入其他配置</p></li><li><p>@ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。</p></li></ol><p>@EnableAutoConfiguration:实现自动装配的核心注解</p><p>EnableAutoConfiguration 只是一个简单地注解，自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector类。</p><p>AutoConfigurationImportSelector:加载自动装配类，该类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。实现如下：</p><p>private static final String[] NO_IMPORTS = new String[0];</p><p>public String[] selectImports(AnnotationMetadata annotationMetadata) {</p><p>​    // &lt;1&gt;.判断自动装配开关是否打开</p><p>​    if (!this.isEnabled(annotationMetadata)) {</p><p>​      return NO_IMPORTS;</p><p>​    } else {</p><p>​     //&lt;2&gt;.获取所有需要装配的bean</p><p>​      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);</p><p>​      AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</p><p>​      return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</p><p>​    }</p><p>  }</p><p>getAutoConfigurationEntry()方法：主要负责加载自动配置类的。源码如下：</p><p>AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {</p><p>​    //&lt;1&gt;.判断自动装配开关是否打开</p><p>​    if (!this.isEnabled(annotationMetadata)) {</p><p>​      return EMPTY_ENTRY;</p><p>​    } else {</p><p>​      //&lt;2&gt;.获取exclude 和 excludeName</p><p>​      AnnotationAttributes attributes = this.getAttributes(annotationMetadata);</p><p>​      //&lt;3&gt;.读取META-INF/spring.factories</p><p>​      List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</String></p><p>​      //&lt;4&gt;.选出@ConditionalOnXXX 中的所有条件</p><p>​      configurations = this.removeDuplicates(configurations);</p><p>​      Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);</String></p><p>​      this.checkExcludedClasses(configurations, exclusions);</p><p>​      configurations.removeAll(exclusions);</p><p>​      configurations = this.filter(configurations, autoConfigurationMetadata);</p><p>​      this.fireAutoConfigurationImportEvents(configurations, exclusions);</p><p>​      return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</p><p>​    }</p><p>  }</p><ol><li><p>判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</p></li><li><p>用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName</p></li><li><p>获取需要自动装配的所有配置类，读取META-INF/spring.factories</p></li></ol><p><img src="/2021/09/10/Spring/SpringBoot/wps22.jpg" alt="img"> </p><p>不光是这个依赖下的META-INF/spring.factories被读取到，所有 Spring Boot Starter 下的META-INF/spring.factories都会被读取到。所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了META-INF/spring.factories文件。</p><ol start="4"><li><p>spring.factories中这么多配置，每次启动并不是全部加载。需要一遍筛选，@ConditionalOnXXX 中的所有条件都满足，该类才会生效。Spring Boot 提供的条件注解</p><ol><li><p>@ConditionalOnBean：当容器里有指定 Bean 的条件下</p></li><li><p>@ConditionalOnMissingBean：当容器里没有指定 Bean 的情况下</p></li><li><p>@ConditionalOnSingleCandidate：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</p></li><li><p>@ConditionalOnClass：当类路径下有指定类的条件下</p></li><li><p>@ConditionalOnMissingClass：当类路径下没有指定类的条件下</p></li><li><p>@ConditionalOnProperty：指定的属性是否有指定的值</p></li><li><p>@ConditionalOnResource：类路径是否有指定的值</p></li><li><p>等</p></li></ol></li></ol><h3 id="4-版本"><a href="#4-版本" class="headerlink" title="4. 版本"></a>4. 版本</h3><p>2.3.4</p><h3 id="5-Springboot如何启动Tomcat"><a href="#5-Springboot如何启动Tomcat" class="headerlink" title="5. Springboot如何启动Tomcat*"></a>5. Springboot如何启动Tomcat*</h3><p>SpringBoot可以把web程序打包成jar包，直接启动，这得益于SpringBoot内置了容器，可以直接启动。</p><p>Springboot从main启动</p><p>@SpringBootApplication</p><p>public class TomcatDebugApplication {</p><p>  public static void main(String[] args) {</p><p>​    SpringApplication.run(TomcatDebugApplication.class, args);</p><p>  }</p><p>}</p><p>run方法是调用ConfigurableApplicationContext 方法</p><ol><li><p>配置属性，设置系统属性『java.awt.headless』</p></li><li><p>获取监听器，发布应用开始启动事件</p></li><li><p>初始化输入参数</p></li><li><p>配置环境。创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）；并遍历调用所有的SpringApplicationRunListener的environmentPrepared()方法，广播Environment准备完毕。</p></li><li><p>输出banner</p></li><li><p>创建ApplicationContext：<em><strong>*createApplicationContext()*</strong></em></p></li><li><p>通过SpringFactoriesLoader检索META-INF/spring.factories,获取并实例化异常分析器</p></li><li><p>prepareContext: </p><ol><li><p>为ApplicationContext加载environment，之后逐个执行ApplicationContextInitializer的initialize()方法来进一步封装ApplicationContext</p></li><li><p>调用所有的SpringApplicationRunListener的contextPrepared()方法</p></li><li><p>初始化IoC容器</p></li></ol></li><li><p>刷新<em><strong>*refreshContext(context);在此启动tomcat*</strong>***</em>*容器****</p></li><li><p>发布应用已经启动事件</p></li><li><p>发布应用启动完成事件</p></li></ol><p><em><strong>*createApplicationContext()*</strong></em></p><p>根据webApplicationType属于哪种类型的Servlet，分类如下：</p><ol><li><p>SERVLET  Web类型（我们建立的是web类型）</p></li><li><p>REACTIVE响应式Web类型</p></li><li><p>default 非Web类型</p></li></ol><p>我们建立的是Web类型，实例化对应的applicationContext。</p><p>即实例化DEFAULT_SERVLET_WEB_CONTEXT_CLASS指定的类。</p><p>也就是****AnnotationConfigServletWebServerApplicationContext****类</p><p>经过各种调用..</p><p>到达createWebServer()：启动web服务，但是还没有真正启动Tomcat</p><p>​    通过工厂方法TomcatServletWebServerFactory.getWebServer()获得</p><p>​        第一件事：把Connnctor对象添加到Tomcat中</p><p>第二件事：configureEngine。Engine是容器，上层接口Container</p><p>而启动Tomcat就是在第9步的“刷新上下文”</p><p>Tomcat的启动主要是初始化2个核心组件：连接器(Connector)和容器（Container）</p><p>一个Tomcat实例就是一个Server，一个Server包含多个Service，也就是多个应用程序，每个Service包含多个连接器（Connetor）和一个容器（Container)，而容器下又有多个子容器，按照父子关系分别为：Engine、Host、Context、Wrapper，其中除了Engine外，其余的容器都是可以有多个。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-Springboot是什么&quot;&gt;&lt;a href=&quot;#1-Springboot是什么&quot; class=&quot;headerlink&quot; title=&quot;1. Springboot是什么&quot;&gt;&lt;/a&gt;1. Springboot是什么&lt;/h3&gt;&lt;p&gt;Spring Boot 并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。&lt;/p&gt;
&lt;p&gt;集成了大量常用的第三方库配置，Spring Boot中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://example.com/2021/09/10/Spring/SpringMVC/"/>
    <id>http://example.com/2021/09/10/Spring/SpringMVC/</id>
    <published>2021-09-10T04:50:31.000Z</published>
    <updated>2021-09-10T06:43:30.377Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-MVC是什么"><a href="#1-MVC是什么" class="headerlink" title="1. MVC是什么"></a>1. MVC是什么</h3><p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 **Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)**。</p><p>解决了什么问题：将前端页面和后端代码分离，实现了一个请求对应一个方法。</p><span id="more"></span><h3 id="2-工作原理（生命周期）"><a href="#2-工作原理（生命周期）" class="headerlink" title="2. 工作原理（生命周期）*"></a>2. 工作原理（生命周期）*</h3><ol><li><p>发起请求到DispatcherServlet (前端控制器)</p></li><li><p>DispatcherServlet根据请求信息调用HandlerMapping（处理器映射器）查找 Handler（处理器，也就是Controller）</p></li><li><p>HandlerMapping解析请求对应的Handler，并返回给DispatcherServlet</p></li><li><p>DispatcherServlet调用HandlerAdapter（处理器适配器）去处理Handler</p></li><li><p>Handler执行完成后返回ModelAndView给DispatcherServlet。ModelAndView是springmvc框架的一个底层对象，包括 Model和view</p></li><li><p>DispatcherServlet请求ViewResolver（视图解析器）去进行视图解析；根据逻辑视图名解析成真正的视图(jsp)</p></li><li><p>ViewResolver向DispatcherServlet返回View</p></li><li><p>DispatcherServlet进行视图渲染，即将模型数据(在ModelAndView对象中)填充到request域</p></li><li><p>DispatcherServlet向用户响应结果</p></li></ol><p><img src="/2021/09/10/Spring/SpringMVC/wps20.jpg" alt="img"> </p><h3 id="3-拦截器Interceptor"><a href="#3-拦截器Interceptor" class="headerlink" title="3. 拦截器Interceptor"></a>3. 拦截器Interceptor</h3><p>Spring MVC中的拦截器（Interceptor）主要用于<strong>拦截用户请求并作相应的处理</strong>。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。</p><p>如何使用：</p><ol><li><p>编写一个简单的拦截器处理类，实现HandlerInterceptor 接口，该接口包含三个方法：preHandle, postHandle, afterCompletion</p></li><li><p>将自定义好的拦截器处理类进行注册，并通过addPathPatterns、excludePathPatterns等属性设置需要拦截或需要排除的 URL。</p></li></ol><p>小demo：</p><p>自定义拦截器：</p><p>public class MyInterceptor implements HandlerInterceptor {</p><p>  private static final Logger logger =</p><p>  LoggerFactory.getLogger(MyInterceptor.class);</p><p>  @Override</p><p>  public boolean preHandle(HttpServletRequest request, HttpServletResponse</p><p>  response, Object handler) throws Exception {</p><p>​    HandlerMethod handlerMethod = (HandlerMethod) handler;</p><p>​    Method method = handlerMethod.getMethod();</p><p>​    String methodName = method.getName();</p><p>​    logger.info(“====拦截到了方法：{}，在该方法执行之前执行====”, methodName);</p><p>​    // 返回true才会继续执行，返回false则取消当前请求</p><p>​    return true;</p><p>  }</p><p>  @Override</p><p>  public void postHandle(HttpServletRequest request, HttpServletResponse</p><p>  response, Object handler, ModelAndView modelAndView) throws Exception {</p><p>​    logger.info(“执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染”);</p><p>  }</p><p>  @Override</p><p>  public void afterCompletion(HttpServletRequest request, HttpServletResponse</p><p>  response, Object handler, Exception ex) throws Exception {</p><p>​    logger.info(“整个请求都处理完，DispatcherServlet也渲染了对应的视图，此时可以做一些清理的工作”);</p><p>  }</p><p>}</p><p>配置拦截器：</p><p>@Configuration</p><p>public class MyInterceptorConfig extends WebMvcConfigurationSupport {</p><p>  @Override</p><p>  protected void addInterceptors(InterceptorRegistry registry) {</p><p>​    // 将上面自定义好的拦截器添加进去。</p><p>​    registry.addInterceptor(new MyInterceptor()).addPathPatterns(“/**”);</p><p>​    super.addInterceptors(registry);</p><p>  }</p><p>}</p><h3 id="4-过滤器Filter"><a href="#4-过滤器Filter" class="headerlink" title="4. 过滤器Filter"></a>4. 过滤器Filter</h3><p>过滤器的配置比较简单，直接实现Filter 接口即可，也可以通过@WebFilter注解实现对特定URL拦截，看到Filter 接口中定义了三个方法。</p><p>init() ：在容器启动初始化过滤器时被调用，它在 Filter 的整个生命周期只会被调用一次。注意：这个方法必须执行成功，否则过滤器会不起作用。</p><p>doFilter() ：容器中的每一次请求都会调用该方法， FilterChain 用来调用下一个过滤器 Filter。</p><p>destroy()： 当容器销毁过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器 Filter 的整个生命周期也只会被调用一次</p><p>@Component</p><p>public class MyFilter implements Filter { </p><p>  @Override</p><p>  public void init(FilterConfig filterConfig) throws ServletException {</p><p>​    System.out.println(“Filter 前置”);</p><p>  }</p><p>  @Override</p><p>  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {</p><p>​    System.out.println(“Filter 处理中”);</p><p>​    filterChain.doFilter(servletRequest, servletResponse);</p><p>  }</p><p>  @Override</p><p>  public void destroy() {</p><p>​    System.out.println(“Filter 后置”);</p><p>  }</p><p>}</p><h3 id="5-AOP-拦截器-过滤器"><a href="#5-AOP-拦截器-过滤器" class="headerlink" title="5. AOP 拦截器  过滤器"></a>5. AOP 拦截器  过滤器</h3><ol><li><p>访问控制功能的粒度： </p><p>AOP：可以配置每个 Controller 的访问权限，访问控制功能要精确到每个请求</p><p>Filter和 Interceptor的粒度会粗一些，控制 HttpRequest、HttpResponse 的访问</p></li><li><p>Spring是否支持：Filter不能够使用 Spring 容器资源；而Interceptor是 Spring 提供的组件，由 Spring 来管理，因此它能使用 Spring 里的任何资源、对象，例如 Service 对象，通过 IoC 注入到 拦截器 中即可。</p></li><li><p>实现原理：Interceptor则是基于动态代理实现的，Filter是基于函数回调的</p></li><li><p>使用范围：Interceptor它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，也可以用于Application、Swing等程序中。Filter实现的是 javax.servlet.Filter 接口， 说明Filter 的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。</p></li><li><p>触发时机不同：Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。</p></li><li><p>拦截的请求范围不同：Filter几乎可以对所有进入容器的请求起作用，而Interceptor只会对Controller中请求或访问static目录下的资源请求起作用</p></li></ol><p><img src="/2021/09/10/Spring/SpringMVC/wps21.jpg" alt="img"> </p><h3 id="6-MVC优点"><a href="#6-MVC优点" class="headerlink" title="6. MVC优点"></a>6. MVC优点</h3><ol><li><p>清晰的角色划分：controller、model、DispatcherServlet、handler mapping、view  resolver等，每一个角色都可以由一个专门的对象来实现</p></li><li><p>强大而直接的配置方式：将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在controller中对业务对象的引用</p></li><li><p>灵活的model转换：在Springweb框架中，使用基于Map的键/值对来达到轻易的与各种视图技术集成</p></li><li><p>Spring Bean的生命周期：可以被限制在当前的HTTP Request或者HTTP Session。准确的说，这并非Spring MVC框架本身特性，而应归属于Spring MVC使用的WebApplicationContext容器。</p></li></ol><h3 id="7-Restful编程风格"><a href="#7-Restful编程风格" class="headerlink" title="7. Restful编程风格"></a>7. Restful编程风格</h3><p>****Restful 风格*<em><strong>的 API 是一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。<br>在 Restful 风格中，</strong></em>*用户请求的 url 使用同一个 url 而用请求方式：get，post，delete，put…等方式对请求的处理方法进行区分****，这样可以在前后台分离式的开发中使得前端开发人员不会对请求的资源地址产生混淆和大量的检查方法名的麻烦，形成一个统一的接口。</p><p>SpringMVC Restful 风格 url 配置实现的方式<br>SpringMVC 的 resturl 是通过 <a href="https://tieba.baidu.com/home/main?un=RequestMapping&fr=pb&ie=utf-8&id=tb.1.af5ecb0a.Sjn8utRjosObEHsEEHuqlQ">@RequestMapping</a> 及 @PathVariable annotation 提供的，通过如 @RequestMapping(value=”/blog /{id}”,method=RequestMethod.DELETE) 即可处理 /blog/1 的 delete 请求。</p><p>GET（SELECT）：从服务器查询，可以在服务器通过请求的参数区分查询的 方式。<br>POST（CREATE）：在服务器端新建一个资源，调用 insert 操作。<br>PUT（UPDATE）：在服务器端更新资源，调用 update 操作。<br>PATCH（UPDATE）：在服务器端更新资源（客户端提供改变的属性）。(目前 jdk7 未实现，tomcat7 不支持)。<br>DELETE（DELETE）：从服务器端删除资源，调用 delete 语句。</p><p>摘自：</p><p><a href="https://blog.csdn.net/l_blackeagle/article/details/61926695">https://blog.csdn.net/l_blackeagle/article/details/61926695</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-MVC是什么&quot;&gt;&lt;a href=&quot;#1-MVC是什么&quot; class=&quot;headerlink&quot; title=&quot;1. MVC是什么&quot;&gt;&lt;/a&gt;1. MVC是什么&lt;/h3&gt;&lt;p&gt;MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 **Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)**。&lt;/p&gt;
&lt;p&gt;解决了什么问题：将前端页面和后端代码分离，实现了一个请求对应一个方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>常用注解</title>
    <link href="http://example.com/2021/09/10/Spring/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>http://example.com/2021/09/10/Spring/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-09-10T04:48:06.000Z</published>
    <updated>2021-09-10T06:37:15.083Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-常用"><a href="#1-常用" class="headerlink" title="1.常用"></a>1.常用</h3><ol><li><p>Spring bean依赖注入</p><ol><li><p>@Autowired：按照类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false</p></li><li><p>@Qualifier：按照名称来装配，搭配Autowired使用</p></li><li><p>@Resource：按照名称装配</p></li><li><p>@Component,@Repository,@Service, @Controller @RestController</p></li><li><p>@Configuration注解声明配置类更加语义化，可用@Component代替</p></li><li><p>@Scope声明 Spring Bean 的作用域：@Scope(“singleton”)</p></li></ol><span id="more"></span></li><li><p>请求</p><ol><li><p>@RequestMapping：用来处理请求地址映射的注解</p></li><li><p>@GetMapping请求从服务器获取特定资源</p></li><li><p>@PostMapping在服务器上创建一个新的资源</p></li><li><p>@PutMapping更新服务器上的资源（更新整个资源，比如编号12的学生信息）</p></li><li><p>@DeleteMapping从服务器删除特定的资源</p></li></ol></li><li><p>前后端传值</p><ol><li><p>@PathVariable：用于将请求URL中的模板变量映射到参数上</p></li><li><p>@RequestParam用于获取查询参数</p></li><li><p>@RequestBody用于读取请求的 body 部分并且Content-Type 为 application/json 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去</p></li><li><p>@ResponseBody：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用</p></li></ol></li><li><p>事务 </p><ol><li>@Transactional</li></ol></li><li><p>读取配置信息</p><ol><li><p>@Value(“${property}”) 读取比较简单的配置信息</p></li><li><p>@ConfigurationProperties读取配置信息并与 bean 绑定</p></li><li><p>@PropertySource读取指定 properties 文件</p></li></ol></li><li><p>全局处理Controller异常</p><ol><li><p>@ControllerAdvice :注解定义全局异常处理类</p></li><li><p>@ExceptionHandler :注解声明异常处理方法</p></li></ol></li><li><p>json数据处理</p><ol><li><p>@JsonIgnoreProperties 作用在类上用于过滤掉特定字段不返回或者不解析</p></li><li><p>@JsonIgnore一般用于类的属性上，作用和上面的@JsonIgnoreProperties 一样。</p></li><li><p>@JsonFormat一般用来格式化 json 数据</p></li><li><p>@JsonUnwrapped 扁平对象</p></li></ol></li><li><p>测试</p><ol><li><p>@ActiveProfiles一般作用于测试类上， 用于声明生效的 Spring 配置文件</p></li><li><p>@Test声明一个方法为测试方法</p></li><li><p>@Transactional被声明的测试方法的数据会回滚，避免污染测试数据</p></li></ol></li></ol><h3 id="2-Autowired-Resource-区别"><a href="#2-Autowired-Resource-区别" class="headerlink" title="2.@Autowired  @Resource 区别*"></a>2.@Autowired  @Resource 区别*</h3><p>@Autowired注解由Spring提供，只按照byType注入</p><p>@resource注解由J2EE提供，默认按照byName自动注入</p><h3 id="3-Controller-ResponseBody-RestController"><a href="#3-Controller-ResponseBody-RestController" class="headerlink" title="3.@Controller+@ResponseBody=@RestController"></a>3.@Controller+@ResponseBody=@RestController</h3><p>@Controller使用它标记的类就是一个SpringMVC Controller 对象，HandlerMapping会扫描使用了该注解的类的方法</p><p>单独使用：返回一个视图，属于比较传统的Spring MVC 的应用，前后端不分离</p><p>@ResponseBody ：将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p><p>@RestController只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p><p>@Controller +@ResponseBody= @RestController</p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>修饰类或方法，用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>常用请求注解：</p><p>GetMapping PostMapping PutMapping DeleteMapping</p><ol><li><p>get 请求从服务器获取特定资源</p></li><li><p>post 在服务器上创建一个新的资源</p></li><li><p>put 更新服务器上的资源（更新整个资源，比如编号12的学生信息）</p></li><li><p>delete 从服务器删除特定的资源</p></li></ol><p>常用的参数是什么？</p><ol><li><p>value：指定请求的实际地址</p></li><li><p>method：指定请求的method类型， GET、POST、PUT、DELETE等</p></li><li><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html</p></li><li><p>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p></li><li><p>params： 指定request中必须包含某些参数值时，才让该方法处理；适用情况：进一步帮助我们缩小请求映射的定位范围，可以让多个处理方法处理到同一个URL 的请求, 而这些请求的参数是不一样的。</p></li></ol><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-常用&quot;&gt;&lt;a href=&quot;#1-常用&quot; class=&quot;headerlink&quot; title=&quot;1.常用&quot;&gt;&lt;/a&gt;1.常用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Spring bean依赖注入&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;@Autowired：按照类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@Qualifier：按照名称来装配，搭配Autowired使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@Resource：按照名称装配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@Component,@Repository,@Service, @Controller @RestController&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@Configuration注解声明配置类更加语义化，可用@Component代替&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@Scope声明 Spring Bean 的作用域：@Scope(“singleton”)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring事务</title>
    <link href="http://example.com/2021/09/10/Spring/Spring%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2021/09/10/Spring/Spring%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-09-10T04:39:16.000Z</published>
    <updated>2021-09-10T06:43:02.976Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-Spring-管理事务的方式"><a href="#1-Spring-管理事务的方式" class="headerlink" title="1. Spring 管理事务的方式"></a>1. Spring 管理事务的方式</h3><p>两种方式：</p><ol><li><p>编程式事务：在代码中硬编码。(不推荐使用) 通过 TransactionTemplate或者TransactionManager手动管理事务，实际应用中很少使用</p></li><li><p>声明式事务：在配置文件中配置（推荐使用），又分为两种。代码侵入性最小，实际是通过 AOP 实现（基于@Transactional 的注解方式使用最多）</p><ol><li>基于XML的声明式事务</li><li>基于注解的声明式事务</li></ol><span id="more"></span> </li></ol><h3 id="2-Spring事务管理的3个重要接口"><a href="#2-Spring事务管理的3个重要接口" class="headerlink" title="2. Spring事务管理的3个重要接口*"></a>2. Spring事务管理的3个重要接口*</h3><p>源码如何实现的*</p><ol><li><p><strong>PlatformTransactionManager</strong>：事务管理器，Spring 事务策略的核心</p><ol><li><p>Spring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是：PlatformTransactionManager 。通过这个接口，Spring 为各个平台如 JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p></li><li><p>接口中定义了三个方法：</p></li></ol><p>① 获得事务TransactionStatus getTransaction(TransactionDefinition var1)</p><p>② 提交事务commit</p><p>③ 回滚事务rollback</p></li><li><p><strong>TransactionDefinition</strong>：事务属性(事务隔离级别、传播行为、超时、只读、回滚规则)</p><ol><li><p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上</p></li><li><p>事务属性包含了 5 个方面：</p></li></ol><p>① 隔离级别</p><p>② 传播行为</p><p>③ 回滚规则</p><p>④ 是否只读</p><p>⑤ 事务超时</p></li><li><p><strong>TransactionStatus</strong>：事务状态</p><ol><li><p>该接口定义了一组方法,用来获取或判断事务的相应状态信息</p></li><li><p>接口中的方法：</p></li></ol><p>① isNewTransaction(); // 是否是新的事物</p><p>② setRollbackOnly();  // 设置为只回滚</p><p>③ isRollbackOnly(); // 是否为只回滚</p><p>④ isCompleted; // 是否已完成</p><p>⑤ hasSavepoint(); // 是否有恢复点</p></li></ol><p><strong>总结：</strong></p><p>我们可以把 <strong>PlatformTransactionManager 接口可以被看作是事务上层的管理者，而 TransactionDefinition 和 TransactionStatus 这两个接口可以看作是事物的描述。</strong></p><p>PlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p><h3 id="3-5种事务隔离级别"><a href="#3-5种事务隔离级别" class="headerlink" title="3. 5种事务隔离级别"></a>3. 5种事务隔离级别</h3><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ol><li><p>ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，mysql默认采用的 REPEATABLE_READ 隔离级别， Oracle 默认采用的 READ_COMMITTED 隔离级别</p></li><li><p>ISOLATION_READ_UNCOMMITTED ：导致脏读、幻读、不可重复读</p></li><li><p>ISOLATION_READ_COMMITTED：导致幻读、不可重复读</p></li><li><p>ISOLATION_REPEATABLE_READ：导致幻读</p></li><li><p>ISOLATION_SERIALIZABLE</p></li></ol><h3 id="4-7种事务传播行为"><a href="#4-7种事务传播行为" class="headerlink" title="4. 7种事务传播行为"></a>4. 7种事务传播行为</h3><p><strong>什么是事务传播行为？</strong></p><p>事务传播行为是为了解决<strong>业务层方法之间互相调用的事务问题。</strong></p><p>事务传播行为用来描述一个事务方法被另一个事务方法调用时，事务如何传播。（内部方法如何传播）</p><p>Spring 在 TransactionDefinition 接口中规定了 7 种类型的事务传播行为。</p><ol><li><p>PROPAGATION_REQUIRED  (<strong>required</strong>)</p><ol><li><p>如果外部方法没有开启事务的话，required修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p></li><li><p>如果外部方法开启事务，并且被required修饰的话，内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。</p></li></ol></li><li><p>PROPAGATION_REQUIRES_NEW  <strong>(requires_new)</strong> </p><ol><li>不管外部方法是否开启事务，requires_new修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li></ol></li><li><p>PROPAGATION_NESTED <strong>(nested)</strong> </p><ol><li><p>在外部方法未开启事务的情况下，nested修饰的内部方法都会新开启自己的事务 </p></li><li><p>如果外部方法开启事务的话，nested修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。</p></li></ol></li><li><p>PROPAGATION_MANDATORY  <strong>(mandatory)</strong></p><ol><li>如果当前存在事务，加入该事务；如果当前没有事务，则抛出异常</li></ol></li><li><p>PROPAGATION_SUPPORTS <strong>(supports)</strong> </p><ol><li>如果当前存在事务，加入该事务；如果当前没有事务，则以非事务的方式继续运行</li></ol></li><li><p>PROPAGATION_NOT_SUPPORTED <strong>(not_supported)</strong> </p><ol><li>以非事务方式运行，如果当前存在事务，则把当前事务挂起</li></ol></li><li><p>PROPAGATION_NEVER <strong>(never)</strong> </p><ol><li>以非事务方式运行，如果当前存在事务，则抛出异常</li></ol></li></ol><h3 id="5-事务超时"><a href="#5-事务超时" class="headerlink" title="5. 事务超时"></a>5. 事务超时</h3><p>就是指<strong>一个事务所允许执行的最长时间</strong>，如果超过该时间限制但事务还没有完成，则自动回滚事务。在TransactionDefinition中以 int 的值来表示超时时间，其单位是秒，默认值为-1.</p><h3 id="6-事务只读属性"><a href="#6-事务只读属性" class="headerlink" title="6. 事务只读属性"></a>6. 事务只读属性</h3><p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p><h3 id="7-事务回滚"><a href="#7-事务回滚" class="headerlink" title="7. 事务回滚"></a>7. 事务回滚</h3><p>事务回滚规则定义了<strong>哪些异常会导致事务回滚而哪些不会。</strong></p><p>默认情况下，事务只有遇到运行期异常和Error 会导致事务回滚，但是，在遇到检查型异常时不会回滚。</p><p>如果你想要回滚你定义的特定的异常类型的话，可以这样：</p><p>@Transactional(rollbackFor=MyException.class)</p><h3 id="8-Transactional"><a href="#8-Transactional" class="headerlink" title="8. @Transactional*"></a>8. @Transactional*</h3><p><strong>作用范围</strong></p><ol><li><p>方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。</p></li><li><p>类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</p></li><li><p>接口 ：不推荐在接口上使用。</p></li></ol><p><em><strong>常用配置参数</strong></em></p><p>@Transactional 的常用配置参数总结（只列5 个我平时比较常用的）：</p><ol><li><p>propagation：事务的传播行为，默认值为 REQUIRED</p></li><li><p>isolation    事务的隔离级别，默认值采用 DEFAULT</p></li><li><p>timeout    事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p></li><li><p>readOnly     指定事务是否为只读事务，默认值为 false。</p></li><li><p>rollbackFor用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</p></li></ol><p><em><strong>原理</strong>***</em>（基于AOP）***</p><p>@Transactional 的工作机制是基于 AOP 实现的。</p><p>如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p><h3 id="9-Transactional自调用问题"><a href="#9-Transactional自调用问题" class="headerlink" title="9. @Transactional自调用问题"></a>9. @Transactional自调用问题</h3><p>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有@Transactional 注解的方法的事务会失效。</p><p>这是由于Spring AOP代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p><p>解决办法：避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</p><h3 id="10-为什么数据查询操作还要启用事务支持"><a href="#10-为什么数据查询操作还要启用事务支持" class="headerlink" title="10. 为什么数据查询操作还要启用事务支持"></a>10. 为什么数据查询操作还要启用事务支持</h3><p>一次执行多条查询，需要开启事务；只执行一条，不需要开启。</p><p>MySQL 默认对每一个新建立的连接都启用了autocommit模式。在该模式下，每一个发送到 MySQL 服务器的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。也就是说：如果你给方法加上了Transactional注解的话，这个方法执行的所有sql会被放在一个事务中；如果不加Transactional，每条sql会开启一个单独的事务。</p><p>因此对于数据查询来说，事务是否启用是分场景分情况来考虑的：</p><p>① 如果一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</p><p>② 如果一次执行多条查询语句，例如统计查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-Spring-管理事务的方式&quot;&gt;&lt;a href=&quot;#1-Spring-管理事务的方式&quot; class=&quot;headerlink&quot; title=&quot;1. Spring 管理事务的方式&quot;&gt;&lt;/a&gt;1. Spring 管理事务的方式&lt;/h3&gt;&lt;p&gt;两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编程式事务：在代码中硬编码。(不推荐使用) 通过 TransactionTemplate或者TransactionManager手动管理事务，实际应用中很少使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声明式事务：在配置文件中配置（推荐使用），又分为两种。代码侵入性最小，实际是通过 AOP 实现（基于@Transactional 的注解方式使用最多）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于XML的声明式事务&lt;/li&gt;
&lt;li&gt;基于注解的声明式事务&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring中的设计模式</title>
    <link href="http://example.com/2021/09/10/Spring/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/09/10/Spring/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-09-10T04:29:47.000Z</published>
    <updated>2021-09-10T06:43:10.460Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>以下几种：</p><ol><li><p>简单工厂：BeanFactory</p></li><li><p>工厂方法：FactoryBean</p></li><li><p>单例模式：单例注册表</p></li><li><p>代理模式：AOP</p></li><li><p>模板模式</p></li></ol>  <span id="more"></span><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><em><strong>简单工厂</strong></em></h3><p>简单工厂定义：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类</p><p>实现： <em><strong>*BeanFactory 接口*</strong></em></p><p>是一个管理bean的工厂，有多个实现类。</p><p>在<em><strong>*g*</strong>***</em>*etBean(beanName)****方法中，根据传入的参数beanName，动态决定创建哪一个Bean对象。</p><p>举例：在ClassPathXmlApplicationContext启动Spring中，使用DefaultListableBeanFactory。</p><p>在初始化该BeanFactory时，会加载配置文件，并解析为BeanDefinition，最后将这个beanDefinition注册到BeanFactory中，即将beanName-BeanDefinition放到beanDefinitionMap中。</p><p>在初始化单例 bean阶段，会调用getBean(beanName)，先从beanDefinitionMap中获取对应的BeanDefinition，然后进行后面的创建操作。</p><p>作用：</p><ol><li><p>封装创建过程，对调用者透明；适用于创建逻辑比较复杂的，将对象的创建和使用相分离。</p></li><li><p>代码复用：创建对象的代码可复用</p></li><li><p>隔离复杂性：调用者无需了解复杂的创建逻辑</p></li><li><p>职责单一：将创建代码抽离，使原来的函数或类职责更加单一，代码简洁</p></li></ol><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><em><strong>工厂方法</strong></em></h3><p>工厂方法定义：定义一个创建对象的接口，让其子类决定实例化哪一个工厂类，使对象的创建过程延迟到子类进行。</p><p>实现方式：<em><strong>*FactoryBean接口*</strong></em></p><p>实现原理：实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是spring会在使用getBean()调用获得该bean时，自动调用该bean的****getObject()****方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p><p>例子：典型的例子有spring与mybatis的结合。</p><p><img src="/2021/09/10/Spring/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/wps19.png" alt="img"> </p><p>sqlSessionFactory因为实现了FactoryBean接口，所以返回的不是 SqlSessionFactoryBean 的实例，而是它的 SqlSessionFactoryBean.getObject() 的返回值。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><em><strong>单例模式</strong></em></h3><p><a href="https://www.cnblogs.com/twoheads/p/9723543.html">https://www.cnblogs.com/twoheads/p/9723543.html</a></p><p>单例模式定义： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>Spring框架对单例的支持是采用****单例注册表****的方式实现。原因：一般的将单例类构造方法定义为private是不可继承的。</p><p>singletonCache：Bean实例的缓存，作为单例注册表</p><ol><li><p>先singletonCache.get(beanName)，如果已经注册过，直接返回，否则下一步</p></li><li><p>加锁synchronized(this.singletonCache)</p></li><li><p>再次判断如果singletonCache.get(beanName)=null，创建bean，并将这个bean加入map中</p></li></ol><p>public abstract class AbstractBeanFactory implements ConfigurableBeanFactory{   </p><p>  private final Map <em><strong>*singletonCache*</strong></em>=new HashMap();   </p><p>  public Object getBean(String name)throws BeansException{   </p><p>​    return getBean(name,null,null);   </p><p>  }   </p><p>…   </p><p>  public Object getBean(String name,Class requiredType,Object[] args)</p><p>throws BeansException{   </p><p>   //处理传入的name  </p><p>   String beanName=transformedBeanName(name);   </p><p>   Object bean=null;   </p><p>   //手工检测单例注册表   </p><p>   Object sharedInstance=null;   </p><p>   //使用了代码锁定同步块，原理和同步方法相似，但是这种写法效率更高   </p><p>   <em><strong>*synchronized(this.singletonCache)*</strong></em>{   </p><p>​     sharedInstance=this.singletonCache.get(beanName);   </p><p>​    }   </p><p>   if(sharedInstance!=null){   </p><p>​     …   </p><p>​     //返回已缓存Bean实例   </p><p>​     bean=getObjectForSharedInstance(name,sharedInstance);   </p><p>   }else{   </p><p>​    …   </p><p>​    //取得Bean的定义   </p><p>​    RootBeanDefinition mergedBeanDefinition=getMergedBeanDefinition(beanName,false);   </p><p>​     …   </p><p>​    //根据Bean定义判断，如果是单例  </p><p>​    if(mergedBeanDefinition.isSingleton()){   </p><p>​      <em><strong>*synchronized(this.singletonCache)*</strong></em>{   </p><p>​      //再次检测单例注册表   </p><p>​       sharedInstance=this.singletonCache.get(beanName);   </p><p>​       if(sharedInstance==null){   </p><p>​        …   </p><p>​        try {   </p><p>​         //真正创建Bean实例   </p><p>​         sharedInstance=createBean(beanName,mergedBeanDefinition,args);   </p><p>​         //向单例注册表注册Bean实例   </p><p>​          <em><strong>*addSingleton(beanName,sharedInstance);*</strong></em>   </p><p>​        }catch (Exception ex) {   </p><p>​         …   </p><p>​        }finally{   </p><p>​         …   </p><p>​       }   </p><p>​       }   </p><p>​      }   </p><p>​     bean=getObjectForSharedInstance(name,sharedInstance);   </p><p>​    }   </p><p>​    //如果是非单例</p><p>​    else{   </p><p>​     bean=createBean(beanName,mergedBeanDefinition,args);   </p><p>​    }   </p><p>}   </p><p>…   </p><p>  return bean;   </p><p>}   </p><p>}</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><em><strong>代理模式</strong></em></h3><p>定义：在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p><p>动态代理：不事先为每个原始类编写代理类，而是在运行时，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p>作用：与大业务代码解耦；保证业务类职责单一</p><p>实现方式：AOP底层，就是****动态代理****模式的实现。</p><h3 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a><em><strong>模版方法</strong></em></h3><p>定义：在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p><p>Spring模板方法模式实质：是****模板方法模式和回调模式的结合****，Spring几乎所有的外接扩展都采用这种模式。</p><p>JDBC：</p><p>具体实现：JDBC的抽象和对Hibernate的集成，都采用了一种理念或者处理方式，那就是模板方法模式与相应的Callback接口相结合。</p><p>解决问题：</p><ol><li><p>复用。把算法中不变的流程抽象到父类的模板方法中，将可变部分留给子类来实现。所有子类复用父类模板方法中定义的流程代码。</p></li><li><p>扩展。不是指代码的扩展性，而是功能扩展，使框架用户可以不修改框架源码的情况下，定制化框架的功能。</p></li></ol><p>引入回调原因：</p><p>JdbcTemplate是抽象类，不能够独立使用，我们每次进行数据访问的时候都要给出一个相应的子类实现,这样肯定不方便，所以就引入了回调。</p><p>回调代码</p><p>Public interface StatementCallback{</p><p>  Object doWithStatement（Statement stmt）;</p><p>}</p><p>JdbcTemplate方法：</p><p>Public class JdbcTemplate {</p><p>  Public final Object execute（StatementCallback callback）{</p><p>​    Connection con=null;</p><p>​    Statement stmt=null;</p><p>​    try{</p><p>​      con=getConnection（）;</p><p>​      stmt=con.createStatement（）;</p><p>​      Object retValue=callback.doWithStatement（stmt）;</p><p>​      return retValue;</p><p>​    }catch（SQLException e）{</p><p>​      …</p><p>​    }finally{</p><p>​      closeStatement（stmt）;</p><p>​      releaseConnection（con）;</p><p>​    }</p><p>  }</p><p>  …//其它方法定义</p><p>}</p><p>Jdbc使用方法如下：</p><p>  JdbcTemplate jdbcTemplate=…;</p><p>  final String sql=…;</p><p>  StatementCallback callback=new StatementCallback(){</p><p>  public Object=doWithStatement(Statement stmt){</p><p>​    return …;</p><pre><code>    &#125;</code></pre><p>  }</p><p>jdbcTemplate.execute(callback);</p><p>模板模式：基于继承实现，子类重写父类方法，是一种类之间的关系。</p><p>回调：基于组合关系实现，把一个对象传递给另一个对象，是一种对象之间的关系。组合优于继承。更加灵活。优势如下：</p><ol><li><p>类只能单继承</p></li><li><p>回调可以使用匿名类创建回调函数</p></li><li><p>某个类中有多个模板方法，每个方法都有对应的抽象方法，如果我们只用到一个模板方法，子类必须实现所有的抽象方法。回调更加灵活，只需要将需要的模板方法注入回调对象即可。</p></li></ol><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><em><strong>观察者模式</strong></em></h3><p>发布订阅模式</p><p>定义：在对象之间定义一个一对多的依赖，当一个对象（被观察者）状态改变时，所有依赖的对象（观察者）都会自动收到通知。</p><p>将观察者和被观察者的代码解耦。</p><p>事件的发布者（ApplicationEventPublisher）</p><p>事件类型（ApplicationEvent）</p><p>事件广播器（ApplicationEventMulticaster）：该类是整个观察者的核心，接收发布者的事件推送并选择适当的事件监听器进行事件的准确分发。</p><p>事件监听器（ApplicationListener）：该组件为观察者对象，由用户自行实现其void onApplicationEvent(E event)方法，定制业务逻辑。</p><p>导出项目中基于spring观察者模式的应用：</p><p>需求：在application初始化完成后，将事件类型和事件处理器映射存储到map中。方便Consumer中根据EventType调用不同的EventHandler，比如导出事件调用ExportHandler。</p><p>这样设计的作用：可扩展。</p><p>事件处理器接口EventHandler</p><p>导出事件实现EventHandler，定义为：ExportHandler</p><p>导入事件实现EventHandler，定义为：ImportHandler</p><p>具体设计：</p><ol><li><p>在Consumer类实现ApplicationListener<ApplicationReadyEvent>接口，并实现其onApplicationEvent方法，在完成ApplicationReadyEvent后，触发onApplicationEvent方法中的自定义的逻辑</ApplicationReadyEvent></p></li><li><p>Consumer类实现ApplicationContextAware，用来得到applicationContext，从中可获得EventHandler的所有bean</p></li><li><p>在onApplicationEvent中，从applicationContext中获取所有EventHandler的bean，将type和bean的映射存储到map中</p></li></ol><p>代码：</p><p>@Component</p><p>public class EventConsumer implements ApplicationContextAware, ApplicationListener<ApplicationReadyEvent> {</ApplicationReadyEvent></p><p>  private ApplicationContext applicationContext;</p><p>  private static final Map&lt;EventType, List<EventHandler>&gt; config = new HashMap&lt;&gt;();</EventHandler></p><p>  @Override</p><p>  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {</p><p>​    this.applicationContext = applicationContext;</p><p>  }</p><p>  @Override</p><p>  public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) {</p><p>​    //初始化所有的事件</p><p>​    //获取所有EventHandler的实现类</p><p>​    Map&lt;String, EventHandler&gt; beans = applicationContext.getBeansOfType(EventHandler.class);</p><p>​    for (Map.Entry&lt;String, EventHandler&gt; entry : beans.entrySet()) {</p><p>​      List<EventType> types = entry.getValue().getSupportEventTypes();</EventType></p><p>​      for (EventType type : types) {</p><p>​        if(!config.containsKey(type)){</p><p>​          config.put(type, new ArrayList&lt;&gt;());</p><p>​        }</p><p>​        //一种事件类型对应多个处理类</p><p>​        config.get(type).add(entry.getValue());</p><p>​      }</p><p>​    }</p><p>}</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><em><strong>适配器模式</strong></em></h3><p>实现方式：SpringMVC中的适配器HandlerAdatper</p><p>实现原理：HandlerAdatper根据Handler规则找到对应的Handler，并让其执行。Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样再扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</p><p>实现意义：HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a><em><strong>装饰器模式</strong></em></h3><p>定义：</p><ol><li><p>使用组合代替继承</p></li><li><p>装饰器类是对原始类功能相关的增强</p></li><li><p>装饰器类和原始类继承同样的父亲，这样可以对原始类嵌套多个装饰器类。</p></li></ol><p>实现方式：Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p><p>实质：动态地给一个对象添加一些额外的职责。</p><p>摘自：</p><p><a href="https://zhuanlan.zhihu.com/p/114244039">https://zhuanlan.zhihu.com/p/114244039</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;简单工厂：BeanFactory&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工厂方法：FactoryBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单例模式：单例注册表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代理模式：AOP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;模板模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring容器的启动流程</title>
    <link href="http://example.com/2021/09/10/Spring/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2021/09/10/Spring/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2021-09-10T04:24:34.000Z</published>
    <updated>2021-09-10T06:42:59.238Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="S-pring-容器的启动流程"><a href="#S-pring-容器的启动流程" class="headerlink" title="S***pring***容器的启动流程"></a><em><strong>S</strong>***</em>pring***<em><strong>容器的启动流程</strong></em></h3><p>spring容器的启动方式有很多种： </p><ol><li><p>xml的方式，入口为ClassPathXmlApplicationContext（从类路径中加载xml文件）或FileSystemXmlApplicationContext（从指定文件地址加载xml文件）</p></li><li><p>Java Config，基于注解中的方式，入口为AnnotationConfigApplicationContext</p></li></ol> <span id="more"></span><h3 id="xml方式（源码分析）"><a href="#xml方式（源码分析）" class="headerlink" title="xml方式（源码分析）"></a>xml方式（源码分析）</h3><p><a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p><p>整个流程的大致过程：初始化BeanFactory；加载xml配置文件；将beanDefinition注册到beanFactory；创建bean（创建bean实例；属性填充；各种回调）</p><p>启动Spring容器，入口：</p><p>public static void main(String[] args) {</p><p>  ApplicationContext context </p><p>= new <em><strong>*ClassPathXmlApplicationContext*</strong></em>(“classpath:applicationfile.xml”);</p><p>}</p><p>maven中添加spring-context依赖，spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p><p>从ClassPathXmlApplicationContext构造方法开始：</p><ol><li><p>处理文件路径</p></li><li><p>refresh()</p></li></ol><p>refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作</p><ol><li><p>prepareRefresh() 做一些准备工作，比如记录下容器的启动时间、标记“已启动”状态、检验xml配置文件</p></li><li><p>初始化BeanFactory，加载配置文件，并解析为BeanDefinition，最后将这个beanDefinition注册到BeanFactory中，这一步并不会生成Bean实例。ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</p><p><strong>1)</strong> <em><strong>初始化</strong>***</em>BeanFactory***，DefaultListableBeanFactory，这基本上是最厉害的BeanFactory</p><ol start="2"><li>设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用customizeBeanFactory();</li></ol><p><strong>3)</strong> <strong>加载</strong>loadBeanDefinitions();通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean</p><p><strong>4)</strong> <em><strong>解析</strong></em>parseBeanDefinitions(root, this.delegate)核心解析方法</p><p><strong>5)</strong> <em><strong>注册</strong></em>registerBeanDefinition(String beanName, BeanDefinition beanDefinition)注册Bean，将beanName-BeanDefinition放到beanDefinitionMap中；把beanName添加到ArrayList&lt;&gt; beanDefinitionNames中</p><ol start="6"><li>发送注册事件</li></ol></li><li><p>准备Bean容器prepareBeanFactory(beanFactory); </p><ol><li><p>设置 BeanFactory 的类加载器</p></li><li><p>添加****ApplicationContextAwareProcessor*<em><strong>，如果bean在初始化时实现了</strong></em>*Aware接口****，这个processor负责回调，回调ApplicationContextAware、EnvironmentAware、ResourceLoaderAware 等（导出项目中，EventConsumer实现了ApplicationContextAware接口，来获取ApplicationContext，从中获取EventHandler中的所有bean）</p></li><li><p>添加ApplicationListenerDetector，用来注册监听事件，如果bean实例化后，是ApplicationListener 的子类，那么将其添加到 listener 列表中</p></li><li><p>注册几个有用的bean：environment、systemProperties、systemEnvironment</p></li></ol></li><li><p>postProcessBeanFactory(beanFactory); 提供给子类的扩展点，此时所有的 Bean 都加载、注册完成了，但是都还没有初始化，子类可以在这里定义自己的BeanFactoryPostProcessor实现类</p></li><li><p>调用 <em><strong>*BeanFactoryPostProcessor*</strong></em> 各个实现类的 postProcessBeanFactory() 方法invokeBeanFactoryPostProcessors(beanFactory); </p></li><li><p>注册自定义的<em><strong>*BeanPostProcessor*</strong></em> ，registerBeanPostProcessors(beanFactory);，这个接口包含两个方法，分别在Bean初始化前、后执行</p></li><li><p>初始化国际化initMessageSource();初始化当前 ApplicationContext 的 MessageSource </p></li><li><p>初始化当前 ApplicationContext 的事件广播器initApplicationEventMulticaster();</p></li><li><p>onRefresh();典型的模板方法(钩子方法)，具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</p></li><li><p>registerListeners();注册事件监听器，监听器需要实现 ApplicationListener 接口</p></li></ol><p><strong>11.</strong> <em><strong>*初始化所有的*</strong></em> <em><strong>*singleton bean*</strong></em> ：finishBeanFactoryInitialization(beanFactory); </p><p>​    </p><ol start="12"><li>finishRefresh();广播事件，ApplicationContext 初始化完成</li></ol><p><em><strong>*createBeanInstance*</strong></em>(beanName, mbd, args)</p><p>作用：实例化指定的类</p><ol><li><p>确保已经加载了此 class</p></li><li><p>校验一下这个类的访问权限</p></li><li><p>如果是FactoryBean，则采用工厂方法实例化；否则继续</p></li><li><p>根据args，调用无参构造函数、或者有参构造函数创建实例</p></li></ol><p><em><strong>*initializeBean*</strong></em>(beanName, exposedObject, mbd);</p><p>处理各种回调；init方法</p><ol><li><p>如果 bean 实现了 <em><strong>BeanNameAware</strong></em>、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</p></li><li><p>**** <em><strong>BeanPostProcessor</strong></em> 的 postProcessBeforeInitialization 回调</p></li><li><p>处理 bean 中定义的 ****init-method****，或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</p></li></ol><p><strong>4.</strong> <em><strong>BeanPostProcessor</strong></em> 的 postProcessAfterInitialization 回调</p><h3 id="Java-Config方式"><a href="#Java-Config方式" class="headerlink" title="Java Config方式"></a>Java Config方式</h3><p><a href="https://blog.csdn.net/qq_35190492/article/details/110383213">https://blog.csdn.net/qq_35190492/article/details/110383213</a></p><p>如何设计一个IOC容器：</p><ol><li><p>提供入口AnnotationConfigApplicationContext，供用户使用，然后初始化一些工具组件，如下：</p></li><li><p>bean工厂（DefaultListableBeanFactory），用来生成bean对象</p></li><li><p>注解配置读取器（AnnotatedBeanDefinitionReader），对加了特定注解比如@Service、@Repository的类读取转化为BeanDefinition对象</p></li><li><p>路径扫描器（ClassPathBeanDefinitionScanner），对用户指定的包目录进行扫描查找 bean 对象</p></li><li></li></ol><p><img src="/2021/09/10/Spring/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/wps18.png" alt="img"> </p><p>第一步：new AnnotationConfigApplicationContext() 创建Spring容器，有参的构造方法如下，分为三步：</p><ol><li><p>通过this()调用无参构造方法，分为三步</p><ol><li><p>先执行父类GenericApplicationContext的初始化方法，实例化一个DefaultListableBeanFactory</p></li><li><p>实例化AnnotatedBeanDefinitionReader，registerAnnotationConfigProcessors()</p></li></ol><p>① 向容器中添加2个beanFactory后置处理器</p><ol><li><p>ConfigurationClassPostProcessor: 一个 beanFactory 后置处理器，用来完成 bean 的扫描与注入工作</p></li><li><p>EventListenerMethodProcessor</p></li></ol><p>② 向容器中添加2个bean后置处理器</p><ol><li><p>AutowiredAnnotationBeanPostProcessor：一个 bean 后置处理器，用来完成 @AutoWired 自动注入</p></li><li><p>CommonAnnotationBeanPostProcessor</p></li></ol><p>③ 向容器中添加普通组件：DefaultEventListenerFactory</p><ol start="3"><li>实例化ClassPathBeanDefinitionScanner</li></ol></li><li><p>调用register(componentClasses); 注册传入的配置类，可以是多个类。最终调用doRegisterBean()，用来解析用户传入的 Spring 配置类，解析成一个 BeanDefinition 然后注册到容器中。</p></li></ol><p>\3. 调用refresh() 容器刷新，这是spring的核心方法</p><p>刷新流程</p><ol><li><p>prepareRefresh() 刷新前预处理</p></li><li><p>obtainFreashBeanFactory（）获取beanFactory，前面已经初始化过</p></li><li><p>prepareBeanFactory() 预处理beanFactory，向容器中添加一些组件</p></li><li><p>postProcessBeanFactory() 子类重写这个方法，可以在beanFactor</p></li><li><p>执行BeanFactoryPostProcessor方法</p></li><li><p>向容器中注册bean后置处理器</p></li><li><p>初始化MessageSource组件：国际化、消息绑定与解析</p></li><li><p>初始化事件派发器，在注册监听时会用到</p></li><li><p>onRefresh() 留给子类重写，在容器刷新时，可以自定义逻辑，web场景下会用到</p></li><li><p>registerListeners() 注册监听器，派发之前产生的一些事件</p></li><li><p>初始化所有bean</p></li><li><p>finishRefresh() 刷新完成，发布容器</p></li></ol><p>public AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses) {</p><p>​        this();</p><p>​        register(componentClasses);</p><p>​        refresh();</p><p>​    }</p><h3 id="测试demo"><a href="#测试demo" class="headerlink" title="测试demo"></a>测试demo</h3><p><a href="https://www.jianshu.com/p/52b988e02c37">https://www.jianshu.com/p/52b988e02c37</a></p><p><em><strong>*配置*</strong></em></p><p><em><strong>*XML方式：*</strong></em></p><p>&lt;context:component-scan base-package=”com.me.xml”/&gt;</p><p>@Component</p><p>public class OneBean {</p><p>}</p><p>public static void main(String[] args) {</p><p>  ApplicationContext context </p><p>= new ClassPathXmlApplicationContext(“applicationContext.xml”);</p><p>  OneBean bean = context.getBean(“oneBean”,OneBean.class);</p><p>  System.out.println(bean);</p><p>}</p><p><em><strong>*Java*</strong></em> <em><strong>*Config*</strong></em></p><p>@Configuration：标注了该注解的类是一个Spring的配置类,等价于原先的applicationContext.xml</p><p>@ComponentScan ：启动该注解，表明开启Spring的注解自动扫描 , 默认情况下,扫描当前类所在包及其子包</p><p>代码如下：</p><p>@Configuration </p><p>@ComponentScan </p><p>public class Config {</p><p>}</p><p>public static void main(String[] args) {</p><p>  ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);</p><p>  OneBean oneBean = context.getBean(OneBean.class);</p><p>  System.out.println(oneBean);</p><p>}</p><p>创建bean</p><bean id="oneBena" class="com.me.xml.OneBean"><p>@Configuration</p><p>public class Config {</p><p>  @Bean // 表明这是一个Spring 管理的bean</p><p>  public OneBean oneBean() {</p><p>​    // 显然,这个Bean的CLass 是OneBean.class</p><p>​    // 在spring 中,bean的 id 是不能重复的,而现在使用java config来代替xml配置</p><p>​    // 在java config 方法名就是这个bean的id</p><p>​    return new OneBean();</p><p>  }</p><p>}</p></bean>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;S-pring-容器的启动流程&quot;&gt;&lt;a href=&quot;#S-pring-容器的启动流程&quot; class=&quot;headerlink&quot; title=&quot;S***pring***容器的启动流程&quot;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;S&lt;/strong&gt;***&lt;/em&gt;pring***&lt;em&gt;&lt;strong&gt;容器的启动流程&lt;/strong&gt;&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;spring容器的启动方式有很多种： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;xml的方式，入口为ClassPathXmlApplicationContext（从类路径中加载xml文件）或FileSystemXmlApplicationContext（从指定文件地址加载xml文件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java Config，基于注解中的方式，入口为AnnotationConfigApplicationContext&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Bean的生命周期</title>
    <link href="http://example.com/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-09-10T04:20:53.000Z</published>
    <updated>2021-09-10T06:59:56.092Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-Spring创建bean的流程图"><a href="#1-Spring创建bean的流程图" class="headerlink" title="1. Spring创建bean的流程图"></a>1. <em>Spring创建bean的流程图</em></h3><p>![img](Spring Bean的生命周期/wps15.png) </p><span id="more"></span><h3 id="2-Spring-Bean的生命周期"><a href="#2-Spring-Bean的生命周期" class="headerlink" title="2. Spring Bean的生命周期"></a>2. Spring Bean的生命周期</h3><p>四个阶段（在核心方法doCreateBean中）：</p><ol><li><p>实例化Instantiation，创建bean实例</p></li><li><p>属性赋值Populate</p></li><li><p>初始化Initialization，执行init方法</p></li><li><p>销毁Destruction</p></li></ol><p>初始化和销毁是用户能自定义扩展的两个阶段。</p><p>加入扩展点的流程图：</p><p>![img]Spring Bean的生命周期/wps16.jpg) </p><p>扩展点：</p><ol><li><p>Bean自身的方法，比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，对应这四个阶段</p></li><li><p>容器级的方法。主要是后处理器方法，比如下图的 InstantiationAwareBeanPostProcessor、BeanPostProcessor 接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用</p></li><li><p>Bean 级生命周期方法。比如 BeanNameAware、BeanFactoryAware、ApplicationContextAware、InitializingBean、DisposableBean 等方法，这些方法只对当前 Bean 生效。</p></li></ol><p>![img](Spring Bean的生命周期/wps17.jpg) </p><p>摘自：</p><p><a href="https://blog.csdn.net/riemann_/article/details/118500805">https://blog.csdn.net/riemann_/article/details/118500805</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-Spring创建bean的流程图&quot;&gt;&lt;a href=&quot;#1-Spring创建bean的流程图&quot; class=&quot;headerlink&quot; title=&quot;1. Spring创建bean的流程图&quot;&gt;&lt;/a&gt;1. &lt;em&gt;Spring创建bean的流程图&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;![img](Spring Bean的生命周期/wps15.png) &lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Bean相关接口</title>
    <link href="http://example.com/2021/09/10/Spring/Bean%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/2021/09/10/Spring/Bean%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-09-10T04:17:53.000Z</published>
    <updated>2021-09-10T06:37:22.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-BeanFactoryPostProcessor"><a href="#1-BeanFactoryPostProcessor" class="headerlink" title="1. BeanFactoryPostProcessor"></a>1. <em><strong>BeanFactoryPostProcessor</strong></em></h3><p>接口，只有一个方法postProcessBeanFactory</p><p>如果实现了此接口，那么会在所有的 Bean 都加载、注册到BeanFactory，但是都还没有初始化时，Spring 会负责调用里面的 postProcessBeanFactory 方法</p> <span id="more"></span><p>@FunctionalInterface</p><p>public interface BeanFactoryPostProcessor {</p><p>  void <em><strong>*postProcessBeanFactory*</strong></em>(ConfigurableListableBeanFactory var1) </p><p>throws BeansException;</p><p>}</p><h3 id="2-BeanPostProcessor"><a href="#2-BeanPostProcessor" class="headerlink" title="2. BeanPostProcessor"></a>2. <em><strong>BeanPostProcessor</strong></em></h3><p>此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</p><p>分别在 Bean 初始化之前和初始化之后得到执行</p><p>public interface BeanPostProcessor {</p><p>  @Nullable</p><p>  default Object <em><strong>*postProcessBeforeInitialization*</strong></em>(Object bean, String beanName) throws BeansException {</p><p>​    return bean;</p><p>  }</p><p>  @Nullable</p><p>  default Object <em><strong>*postProcessAfterInitialization*</strong></em>(Object bean, String beanName) throws BeansException {</p><p>​    return bean;</p><p>  }</p><p>}</p><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a><em><strong>BeanDefinition</strong></em></h3><p>自己定义的各个 Bean 会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p><p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p><p>Bean是什么？Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p><p>public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {</p><p>  // 我们可以看到，默认只提供 sington 和 prototype 两种，</p><p>  // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</p><p>  // 不过，它们属于基于 web 的扩展。</p><p>  String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</p><p>  String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</p><p>  // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</p><p>  // 一句话就是：继承父 Bean 的配置信息而已</p><p>  void setParentName(String parentName);</p><p>  // 获取父 Bean</p><p>  String getParentName();</p><p>  // 设置 Bean 的类名称，将来是要通过反射来生成实例的</p><p>  void setBeanClassName(String beanClassName);</p><p>  // 获取 Bean 的类名称</p><p>  String getBeanClassName();</p><p>  // 设置 bean 的 scope</p><p>  void setScope(String scope);</p><p>  // 设置是否懒加载</p><p>  void setLazyInit(boolean lazyInit);</p><p>  // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</p><p>  // 是 depends-on=”” 属性设置的值。</p><p>  void setDependsOn(String… dependsOn);</p><p>  // 返回该 Bean 的所有依赖</p><p>  String[] getDependsOn();</p><p>  // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</p><p>  // 如果根据名称注入，即使这边设置了 false，也是可以的</p><p>  void setAutowireCandidate(boolean autowireCandidate);</p><p>  // 该 Bean 是否可以注入到其他 Bean 中</p><p>  boolean isAutowireCandidate();</p><p>  // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</p><p>  void setPrimary(boolean primary);</p><p>  // 是否是 primary 的</p><p>  boolean isPrimary();</p><p>  // 如果该 Bean 采用工厂方法生成，指定工厂名称。即有些实例不是用反射生成的，而是用工厂模式生成的</p><p>  void setFactoryBeanName(String factoryBeanName);</p><p>  // 获取工厂名称</p><p>  String getFactoryBeanName();</p><p>  // 指定工厂类中的 工厂方法名称</p><p>  void setFactoryMethodName(String factoryMethodName);</p><p>  // 获取工厂类中的 工厂方法名称</p><p>  String getFactoryMethodName();</p><p>  // 构造器参数</p><p>  ConstructorArgumentValues getConstructorArgumentValues();</p><p>  // Bean 中的属性值，后面给 bean 注入属性值的时候会说到</p><p>  MutablePropertyValues getPropertyValues();</p><p>  // 是否 singleton</p><p>  boolean isSingleton();</p><p>  // 是否 prototype</p><p>  boolean isPrototype();</p><p>  // 如果这个 Bean 是被设置为 abstract，那么不能实例化，</p><p>  // 常用于作为 父bean 用于继承，其实也很少用……</p><p>  boolean isAbstract();</p><p>  int getRole();</p><p>  String getDescription();</p><p>  String getResourceDescription();</p><p>  BeanDefinition getOriginatingBeanDefinition();</p><p>}</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-BeanFactoryPostProcessor&quot;&gt;&lt;a href=&quot;#1-BeanFactoryPostProcessor&quot; class=&quot;headerlink&quot; title=&quot;1. BeanFactoryPostProcessor&quot;&gt;&lt;/a&gt;1. &lt;em&gt;&lt;strong&gt;BeanFactoryPostProcessor&lt;/strong&gt;&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;接口，只有一个方法postProcessBeanFactory&lt;/p&gt;
&lt;p&gt;如果实现了此接口，那么会在所有的 Bean 都加载、注册到BeanFactory，但是都还没有初始化时，Spring 会负责调用里面的 postProcessBeanFactory 方法&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
  </entry>
  
</feed>
