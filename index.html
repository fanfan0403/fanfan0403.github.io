<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Fanfan</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="Fanfan" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Fanfan</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="true"
          class="cover-logo"
          alt="Fanfan"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-计算机网络/其它知识点"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/"
    >其它知识点</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2021-09-10T05:57:16.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h2 id="应用层常见协议"><a href="#应用层常见协议" class="headerlink" title="应用层常见协议"></a>应用层常见协议</h2><p>\1. HTTP：超文本传输协议，端口号：80</p>
<p>\2. FTP：文件传输协议，端口号：21</p>
<p>\3. DNS：域名系统 (Domain Name System)，端口号：53</p>
<p>\4. SMTP（SimpleMailTransferProtocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，端口号：25</p>
<p>\5. Telnet协议：是Internet远程登陆服务的标准协议和主要方式，端口号：23</p>
<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a><em><strong>ARP</strong></em> <em><strong>协议</strong></em></h2><p>通过 IP 地址向 MAC 地址的转换，网络层协议</p>
<p>工作过程：</p>
<p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p>
<p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p>
<p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p>
<p>\1. A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址</p>
<p>\2. 如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址。将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</p>
<p>\3. 主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p>
<p>\4. 主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</p>
<p>\5. 当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p>
<h2 id="NAT-协议"><a href="#NAT-协议" class="headerlink" title="NAT 协议"></a><em><strong>NAT</strong></em> <em><strong>协议</strong></em></h2><p>NAT协议（Network Address Translation），网络地址转换协议。</p>
<p>作用：将局域网中的IP地址(私有地址)映射到公网的IP（全局地址）。</p>
<p>NAT功能通常运行在网关设备上，NAT路由器会维护一张NAT转化表。</p>
<p>工作过程：</p>
<p>\1. 主机H想访问Web服务器，首先会发送数据包到NAT路由器；</p>
<p>\2. NAT路由器在NAT转换表上记录主机H的内网地址和端口，并为它分配一个全局地址和全局端口与之映射，按照目的地址发送给服务器。</p>
<p>\3. 服务器回应给NAT路由器后，路由器查询NAT转换表，将对应关系转换回去发送给主机H。</p>
<h2 id="公网私网地址"><a href="#公网私网地址" class="headerlink" title="公网私网地址"></a><em><strong>公网私网地址</strong></em></h2><p>在IPv4地址协议中预留了3个IP地址段，作为私有地址，供组织机构内部使用。</p>
<p>这三个地址段分别位于A、B、C三类地址内：</p>
<p>A类地址：10.0.0.0–10.255.255.255</p>
<p>B类地址：172.16.0.0–172.31.255.255 </p>
<p>C类地址：192.168.0.0–192.168.255.255</p>
<h2 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI URL"></a><em><strong>URI</strong></em> <em><strong>URL</strong></em></h2><p>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</p>
<p>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="socket可以TCP和UDP共用吗"><a href="#socket可以TCP和UDP共用吗" class="headerlink" title="*socket可以TCP和UDP共用吗*"></a><em><strong>*socket可以TCP和UDP共用吗*</strong></em></h2><p>可以</p>
<p>linux是以协议、ip、端口来绑定端口的，所以不同协议相同的ip和端口也是可以绑定成功的</p>
<h2 id="为什么DNS即使用TCP又使用UDP"><a href="#为什么DNS即使用TCP又使用UDP" class="headerlink" title="*为什么DNS即使用TCP又使用UDP**"></a><em><strong>*为什么DNS即使用TCP又使用UDP**</strong></em></h2><p>大多数情况下，DNS解析请求和响应都很小，使用UDP协议更加高效，虽然没有TCP可靠，但是速度快，消耗的系统资源更少，非常适合少量数据包的传输。</p>
<p>一些DNS事务，比如区域传输或其他附加查询，可能会产生大于512字节的数据包，因此使用TCP更加可靠，使用TCP会减少丢包和重新发包的情况，因此更加可靠与高效。</p>
<p>DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；</p>
<p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。</p>
<p>区域传输是DNS的事务，对准确性要求比较高，而且会产生大于512字节的数据包，因此使用TCP协议。</p>
<p>为什么既使用TCP又使用UDP？</p>
<p>UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。</p>
<p>区域传送时使用TCP，原因如下：</p>
<p>\1. 数据同步传送的数据量比一个请求和应答的数据量要多得多，比如区域传送</p>
<p>\2. TCP是一种可靠的连接，保证了数据的准确性</p>
<p>域名解析时使用UDP协议</p>
<p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p>
<h2 id="进程可以共用多个端口号吗"><a href="#进程可以共用多个端口号吗" class="headerlink" title="*进程可以共用多个端口号吗**"></a><em><strong>*进程可以共用多个端口号吗**</strong></em></h2><p>可以</p>
<p>数据接收时时根据五元组{传输协议，源IP，目的IP，源端口，目的端口}判断接受者的。</p>
<p>TCP、UDP可以同时绑定一个端口8888，但是一个端口在同一时刻不可以被TCP或者UDP绑定2次。</p>
<p>TCP和UDP传输协议监听同一个端口后，接收数据互不影响，不冲突。因为数据接收时时根据五元组{传输协议，源IP，目的IP，源端口，目的端口}判断接受者的。</p>
<p>端口号可以用来标识同一个主机上通信的不同应用程序，端口号+IP地址就可以组成一个套接字，用来标识一个进程。</p>
<h2 id="MAC-IP-TCP-UDP-头＊"><a href="#MAC-IP-TCP-UDP-头＊" class="headerlink" title="*MAC* *IP*　*TCP* *UDP*****头＊****"></a><em><strong>*MAC*</strong></em> <em><strong>*IP*</strong></em>　<em><strong>*TCP*</strong></em> <em><strong>*UDP*</strong>***</em>*头＊****</h2><p><em><strong>*MAC：1*</strong>***</em>*4B****</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps48.jpg" alt="img"> </p>
<p><em><strong>*IP*</strong>***</em>*：2*<strong><strong><strong>*0B+*</strong></strong></strong>*可选字段****</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps49.jpg" alt="img"> </p>
<p><em><strong>*TCP：2*</strong>***</em>*0*<strong><strong><strong>*B*</strong></strong></strong>*+****<em><strong>*可变长度*</strong></em></p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps50.jpg" alt="img"> </p>
<p><em><strong>*UDP头：*</strong>***</em>*8****<em><strong>*B*</strong></em></p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps51.jpg" alt="img"> </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计算机网络/cookie、session、token"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/"
    >cookie、session、token</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/" class="article-date">
  <time datetime="2021-09-10T05:56:16.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>存储在浏览器中</p>
<p>浏览器实现的一种数据存储功能</p>
<p>工作过程：cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到本地，下一次请求同一网站时会把该cookie发送给服务器，服务器可以通过cookie中携带的数据区分不同的用户。</p>
<p>cookie存在客户端上的，浏览器：</p>
<p>加入了一些限制确保cookie不会被恶意使用</p>
<p>每个域的cookie数量是有限的，保证cookie不会占据太多磁盘空间</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>存储在服务器上</p>
<p>作用：服务器用来区分请求来自谁</p>
<p>server给每个client分配不同的“身份标识”， client每次向server发请求的时候，都带上这个“身份标识”，server就知道这个请求来自于谁了。</p>
<p>对于浏览器客户端，一般采用 cookie 的方式存储session</p>
<p>缺点：服务器端保存占用内存</p>
<p>工作过程：</p>
<p>\1. 浏览器端第一次发送请求到server，server创建一个Session，同时会创建一个特殊的****Cookie*<em><strong>（name为</strong></em>*JSESSIONID****的固定值，value为session对象的ID），然后将该Cookie发送至client</p>
<p>\2. client再发送请求到server时，浏览器端就会携带该JSESSIONID的Cookie对象</p>
<p>\3. server端根据JSESSIONID这个Cookie的value(sessionId),去查询Session对象，从而区分不同用户</p>
<h3 id="cookie-session-区别"><a href="#cookie-session-区别" class="headerlink" title="cookie session 区别**"></a>cookie session 区别**</h3><p>cookie：浏览器实现的一种数据存储功能</p>
<p>session：服务器用来区分请求来自谁。有很多种实现方法，浏览器客户端一般用cookie来实现。</p>
<p>具体区别：</p>
<p><strong>1.</strong> ****存放位置****：cookie在客户的浏览器上，session在服务器上</p>
<p><strong>2.</strong> ****安全性****：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗； session安全</p>
<p><strong>3.</strong> ****服务器内存占用****：session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能； cookie存在在客户端，不存在这个问题</p>
<p><strong>4.</strong> ****大小限制****：一个站点在客户端存放的cookie不能超过3K</p>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token令牌</p>
<p>存储在客户端</p>
<p>应用：在Web领域基于Token的身份验证</p>
<p>解决的问题：session保存在服务器端，会有很大的压力。token的目的就是让客户端保存数据，并且客户端不能伪造数据信息。</p>
<p><em><strong>*特点：*</strong></em></p>
<p>\1. 无状态、可扩展</p>
<p>\2. 支持移动设备</p>
<p>\3. 跨程序调用</p>
<p>\4. 安全</p>
<p>****缺点：****Token 中的数据是明文保存的（虽然会用Base64做下编码， 但那不是加密），不能在其中保存像密码这样的敏感信息</p>
<p>****优点：****server不保存session对象， 只是生成token ，然后验证token，即用CPU计算时间获取了session 存储空间</p>
<p><em><strong>*工作流程：*</strong></em></p>
<p>\1. 用户A登录系统后， 服务器给他发一个令牌(token)， 里边包含了A的用户数据</p>
<p>\2. 为了保证安全，对数据做了签名。比如使用HMAC-SHA256 算法，加上一个server才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。这个token保存在客户端，server不保存。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/wps46.jpg" alt="img"> </p>
<p>\3. 下一次A再次通过Http 请求访问服务器时，在HTTP请求头中带上这个token </p>
<p>\4. server收到token后，再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/wps47.jpg" alt="img"> </p>
<h3 id="token如何使用"><a href="#token如何使用" class="headerlink" title="token如何使用"></a>token如何使用</h3><p>将登陆信息等重要信息存放为session</p>
<p>其他信息如果需要保留，可以放在cookie中</p>
<h3 id="多个服务器如何共享session"><a href="#多个服务器如何共享session" class="headerlink" title="多个服务器如何共享session"></a>多个服务器如何共享session</h3><p>通过redis共享session，把session放在内存中，并可以实现持久化和主从同步。</p>
<p>其他方案的问题：</p>
<p>\1. 使用专门的mysql服务器存储所有的session信息，用户的请求会先在这个数据库中check一下session的情况</p>
<ol>
<li>缺点：依赖性太强，当mysql出问题时会影响整个系统</li>
</ol>
<p>\2. 把session信息写在客户端cookie中。当访问服务器A时，登录成功后，将产生的session信息存放在cookie当中，发给客户端。当请求分发到服务器B时，B先判断自己是否存储了这个session的信息，如果没有，再去客户端的cookie中获取这个session信息，并把这个信息存储到B</p>
<ol>
<li>缺点：cookie安全性不高，容易伪造；如果客户端禁止使用cookie可能造成无法共享session</li>
</ol>
<p>\3. 通过服务器之间的数据同步session，使用一台服务器作为登录服务器，当用户成功后，会将session写到当前服务器上，通过脚本或守护进程将session信息同步到其他服务器</p>
<ol>
<li>缺点：速度慢，同步session有延迟；单向同步时，整个系统不能正常运行</li>
</ol>
<p>\4. 通过memcache同步session，把web服务器的内存组合起来，成为一个内存池，所有服务器产生的session都存放在这个内存池中</p>
<ol>
<li><p>优点：不会加大数据库的负担，安全性也比cookie方式高，并且把session存在内存中，比文件中读取快</p>
</li>
<li><p>缺点：memcache把内存分成存储块，这样memcache可能会产生内存碎片；如果内存块不足，可能产生内存溢出</p>
</li>
</ol>
<p>实际中，使用memcache和redis。</p>
<h3 id="session如何创建"><a href="#session如何创建" class="headerlink" title="session如何创建"></a>session如何创建</h3><p>sessionid第一次产生是在某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建。</p>
<p>tomcat的ManagerBase类提供创建sessionid的方法：随机数+时间+jvmid；</p>
<h3 id="session攻击与防御"><a href="#session攻击与防御" class="headerlink" title="session攻击与防御"></a>session攻击与防御</h3><p>基于session的攻击有很多种方式。大部分的手段都是首先通过捕获合法用户的session, 然后冒充该用户来访问系统。攻击者至少可以通过以下三种方式来获取一个有效的session标识符：预测、捕获（劫持）、固定。</p>
<p>防御方法：</p>
<p>\1. 在登录后重置sessionID。在登录验证成功后，通过重置session，是之前的匿名sessionId失效，这样可以避免使用伪造的sessionId进行攻击。</p>
<p>\2. 关闭透明化Session ID。透明化Session ID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。</p>
<p>\3. 设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击</p>
<p>\4. 验证HTTP头部信息，确保User-Agent头部信息一致的确是有效的</p>
<h3 id="除了session和cookies还有什么缓存"><a href="#除了session和cookies还有什么缓存" class="headerlink" title="除了session和cookies还有什么缓存"></a>除了session和cookies还有什么缓存</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30481087/article/details/102073804">https://blog.csdn.net/weixin_30481087/article/details/102073804</a></p>
<p>\1. localStorage： 是一种你不主动清除它，它会一直将存储数据存储在客户端的存储方式，即使你关闭了客户端（浏览器)，属于本地持久层储存 </p>
<p>\2. sessionStorage： 用于本地存储一个会话（session）中的数据，一旦会话关闭，那么数据会消失，比如刷新。</p>
<p>有时候，我们需要将数据存储到sessionStorage和localStorage中，这样做的好处有：</p>
<p>\1. 缓存数据</p>
<p>\2. 减少对内存的占用</p>
<p>但是，storage只能存储字符串的数据，对于JS中常用的数组或对象却不能直接存储。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计算机网络/TCP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/"
    >TCP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/" class="article-date">
  <time datetime="2021-09-10T05:50:16.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><em>TCP</em></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<h3 id="TCP-如何保证可靠传输"><a href="#TCP-如何保证可靠传输" class="headerlink" title="TCP 如何保证可靠传输"></a>TCP 如何保证可靠传输</h3><p><em><strong>*TCP如何保证数据的完整性*</strong>***</em>*？*****包编号；校验和</p>
<p>应用数据被分割成 TCP 认为最适合发送的数据块。</p>
<p>\1. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传给应用层</p>
<p>\2. 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
<p>\3. TCP 的接收端会丢弃重复的数据</p>
<p>\4. 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段</p>
<p>\5. 流量控制：利用滑动窗口实现</p>
<p>\6. 停止等待ARQ和连续ARQ协议：确认和超时</p>
<p>\7. 拥塞控制</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 利用滑动窗口实现流量控制。</p>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p>TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p>
<h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议*"></a>ARQ 协议*</h3><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是数据链路层和传输层的错误纠正协议之一。它通过使用****确认*<em><strong>和</strong></em>*超时****这两个机制。</p>
<p>目的：在不可靠服务的基础上实现可靠的信息传输。</p>
<p>如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<p><em><strong>*停止等待*</strong>***</em>*ARQ协议****</p>
<p>基本原理：每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p>优点： 简单</p>
<p>缺点： 信道利用率低，等待时间长</p>
<p>运行机制：</p>
<p>\1. 无差错情况:发送方发送分组,接收方在规定时间内收到并回复确认.发送方发送新的分组。</p>
<p>\2. 出现差错情况（超时重传）:只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。</p>
<p>\3. 确认丢失：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</p>
<p>\4. 确认迟到：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</p>
<p><em><strong>*连续*</strong>***</em>*ARQ协议****</p>
<p>目的：提高信道利用率。</p>
<p>基本原理：发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</p>
<p>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传</p>
<p>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制***"></a>拥塞控制***</h3><p>拥塞定义：网络中的数据太多，导致某个路由器处理不过来或处理地太慢。</p>
<p>具体： 当发送的数据到达网络中的一个节点时（假设是路由器），它会根据数据包含的地址进行转发。但这些节点需要先将接收到的数据放入自己的内存（可能还要做一些处理），再从中取出进行转发。但路由器的内存是有限的，若同一时间到达某个路由器的数据太多，这个路由器将无法接收所有的数据，只能将一部分丢弃；或者要等待较长的时间才会被转发。</p>
<p>拥塞控制定义：在网络中发生拥塞时，减少向网络中发送数据的速度，防止造成恶性循环；同时在网络空闲时，提高发送数据的速度，最大限度地利用网络资源。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。</p>
<p>TCP的拥塞控制使用四种算法：</p>
<ol>
<li><p><strong>慢开始和拥塞避免</strong></p>
<p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p>
<p>慢开始算法：由小到大、乘法增长，逐渐增加拥塞窗口的大小。即1,2,4,8…目的：不要一开始就发送大量的数据，先探测一下网络的拥塞程度</p>
<p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh：</p>
<p>当cwnd&lt;ssthresh时，使用慢开始算法。</p>
<p>当cwnd&gt;ssthresh时，改用拥塞避免算法。</p>
<p>当cwnd=ssthresh时，慢开始与拥塞避免算法任意。</p>
<p>拥塞避免算法让拥塞窗口缓慢增长，拥塞窗口cwnd加1，而不是加倍。</p>
<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（没有收到确认、分组丢失），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。</p>
</li>
<li><p>快重传和快恢复</p>
<p>目的：快速恢复丢失的数据包</p>
<p>快重传：接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p>快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半。发送方将cwnd设置为ssthresh的大小，然后执行拥塞避免算法，加法增大。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞，所以不用慢开始。</p>
</li>
</ol>
<h3 id="TCP最大连接数"><a href="#TCP最大连接数" class="headerlink" title="TCP最大连接数*"></a>TCP最大连接数*</h3><p>client：内核开放了50000个端口可以供TCP连接使用，最大理论范围是0-65535。</p>
<p>client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大tcp连接数为65535。</p>
<p>用命令查看：</p>
<p>$ sysctl -a | grep ip_local_port_range</p>
<p>net.ipv4.ip_local_port_range = 15000   65000</p>
<p>当Linux作为客户端建立连接的时候，最大连接数量是受内核参数</p>
<p>net.ipv4.ip_local_port_range限制，而ip_local_port_range是可配置的，最大理论范围是0-65535。</p>
<p>对于有一个IP的客户端来说，受限于ip_local_port_range参数，也受限于65535。但单Linux可以配置多个ip，有几个ip，最大理论值就翻几倍。</p>
<p>server：</p>
<p>server通常固定在某个本地端口上监听，等待client的连接请求，本地监听端口是独占的。</p>
<p>一条TCP连接是由一个四元组组成的。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，对于我们这台Nginx Server来说，它的IP和端口是固定的。4元组中只有client ip和client port是可变的。因此最大的连接数是2的32次方（ip数）×2的16次方（port数）。</p>
<p>Linux上除了监听80以外，还可以监听其它的端口，例如Mysql的3306, Redis的6339，当然所有65535个端口你都可以用来监听一遍。这样理论上线就到了2的32次方（ip数）×2的16次方（port数）×2的16次方（服务器port数）个。</p>
<p>一条TCP连接如果不发送数据的话，消耗内存是3.3K左右。假设你只保持连接不发送数据，那么你服务器可以建立的连接最大数量 = 你的内存/3.3K。假如是4GB的内存，那么大约可接受的TCP连接数量是100万左右。</p>
<p>总结：</p>
<p>TCP连接的客户端机：每一个ip可建立的TCP连接理论受限于ip_local_port_range参数，也受限于65535。但可以通过配置多ip的方式来加大自己的建立连接的能力。</p>
<p>TCP连接的服务器机：每一个监听的端口虽然理论值很大，但这个数字没有实际意义。最大并发数取决你的内存大小，每一条静止状态的TCP连接大约需要吃3</p>
<p>.3K的内存。</p>
<h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式*"></a>TCP报文格式*</h3><p>固定首部长度为20字节,可变部分0~40字节</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps43.png" alt="img"> </p>
<p>\1. 源端口，16bits，范围0~65525。</p>
<p>\2. 目的端口，16bits，范围同上。</p>
<p>\3. sequence number： 数据序号，32bits，TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</p>
<p>\4. acknoledgement number： 确认号，32bits，期望收到对方的下一个报文段的数据的第一个字节的序号。</p>
<p>\5. 数据偏移，4bits，单位为4字节，它指出报文数据距TCP报头的起始处有多远(TCP报文头长度)。</p>
<p>\6. 保留字段 6bits，保留今后使用，目前置0处理。</p>
<p>\7. URG：紧急比特，1bit，当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</p>
<p>\8. ACK：确认比特，1bit，只有当 ACK=1时确认号字段才有效。当 ACK=0 时，确认号无效</p>
<p>\9. PSH：推送比特，1bit，接收方 TCP 收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付</p>
<p>\10. RST：复位比特，1bit，当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接</p>
<p>\11. SYN：同步比特，1bit，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文</p>
<p>\12. FIN：终止比特，1bit，用来释放一个连接。当FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</p>
<p>\13. 窗口大小，16bits，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</p>
<p>\14. 检验和，16bits，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p>
<p>\15. 紧急指针字段，16bits，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。</p>
<p>\16. 选项字段，长度可变，这部分最多包含40字节。TCP首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。，因为TCP头部最长是60字节</p>
<ol>
<li><p>选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。</p>
</li>
<li><p>第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。</p>
</li>
<li><p>第三个字段info（如果有的话）是选项的具体信息. kind=0是选项表结束选项kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍kind=2是最大报文段长度选项</p>
</li>
</ol>
<p>TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。</p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps39.jpg" alt="img"> </p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) ：建立连接</p>
<p>ACK：表示响应，告诉对方你发的信息我收到了</p>
<ol>
<li><p>主机A：发送syn=1，随机产生seq number=x的数据包 -&gt; 主机B，收到syn=1，知道A要建立连接（B确认了自己接收正常，对方发送正常）</p>
</li>
<li><p>主机B：确认连接信息，向A发送ack=1，ack number=x+1，syn=1，随机产生seq=y的数据包 -&gt; 主机A（A确认了自己发送、接收正常，对方发送、接收正常）</p>
</li>
<li><p>主机A：检查ack number是否正确，发送ack number=y+1，ack=1 -&gt; 主机B（B确认了自己发送正常，对方接收正常）</p>
</li>
</ol>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手*"></a>为什么要三次握手*</h3><p>三次握手的目的是建立可靠的通信信道，即双方确认自己与对方的发送与接收是正常的。</p>
<p>A和B进行三次握手：A先向B发送</p>
<ol>
<li><p>B确认了对方发送正常，自己接收正常</p>
</li>
<li><p>A确认了自己发送、接收正常，对方发送、接收正常</p>
</li>
<li><p>B确认了：自己发送正常，对方接收正常</p>
</li>
</ol>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p>“三次握手”的目的：“为了防止****已失效的连接请求报文段****突然又传送到了服务端，因而产生错误”</p>
<p>为了解决“网络中存在延迟的重复分组”的问题</p>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<p><em><strong>*为什么是三次，不是四次？*</strong></em></p>
<p>这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的.</p>
<h3 id="第2次握手传回了ACK，为什么还要传回SYN"><a href="#第2次握手传回了ACK，为什么还要传回SYN" class="headerlink" title="第2次握手传回了ACK，为什么还要传回SYN"></a>第2次握手传回了ACK，为什么还要传回SYN</h3><p>SYN 同步序列编号(Synchronize Sequence Numbers) ：建立连接</p>
<p>ACK：表示响应，告诉对方你发的信息我收到了</p>
<p>B给A所发送的ACK是为了告诉A，我接收到的信息确实就是你所发送的信号了，这表明从A到B的通信是正常的。而回传SYN则是为了建立从B到A的通信。</p>
<h3 id="如果第一次、第二次失败"><a href="#如果第一次、第二次失败" class="headerlink" title="如果第一次、第二次失败*"></a>如果第一次、第二次失败*</h3><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps40.jpg" alt="img"> </p>
<p>第一次失败（client向server发送SYN失败）：</p>
<p>两端都不会申请资源。如果一段时间后之前的SYN发送成功了，这时客户端只会接收他最后发送的SYN的SYN+ACK回应，其他的一概忽略，服务端也是如此，会将之前多申请的资源释放了。</p>
<p>第二次握手失败（server向client发送SYN+ACK失败）：</p>
<p>client由于没有收到这条响应，不会申请资源，虽然服务端申请了资源，但是迟迟收不到来自客户端的ACK，也会将该资源释放。</p>
<p>第三次握手失败（client向server发送ACK失败）：</p>
<p>server迟迟没有收到ACK，就会释放资源</p>
<p>但client认为自己已经连接好了，就会给server发送数据</p>
<p>server由于没有收到第三次握手，就会以RST包对客户端响应，重新建立链接</p>
<p>另外，server会因为没有收到客户端的ACK多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到客户端的ACK，则释放资源。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps41.jpg" alt="img"> </p>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>A 主动关闭         B被动关闭</p>
<ol>
<li><p>主机A：发送fin=1, seq=x 报文，用来关闭A到B的数据传送 -&gt; 主机B</p>
</li>
<li><p>主机B：发送 ack=1, seq=x+1 报文，确认收到关闭连接的信息 -&gt; 主机A</p>
</li>
<li><p>主机B：发送 fin=1, seq=y 报文，用来关闭B到A的数据传送 -&gt; 主机A</p>
</li>
<li><p>主机A：发送 ack=1, seq=y+1 报文，确认收到关闭连接的信息 -&gt; 主机B</p>
</li>
</ol>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps42.png" alt="img"> </p>
<h3 id="为什么三次握手，而关闭却是四次"><a href="#为什么三次握手，而关闭却是四次" class="headerlink" title="为什么三次握手，而关闭却是四次*"></a>为什么三次握手，而关闭却是四次*</h3><p>这是因为服务端收到SYN报文的连接请求后，它可以把ACK和SYN放在一个报文里来发送。</p>
<p>关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭。可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了。</p>
<p>所以关闭时ACK报文和FIN报文多数情况下都是分开发送的。</p>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT*"></a>TIME_WAIT*</h3><p>A主动关闭连接结束后，收到来自B的FIN，在A发送最后一个ack后，A会进入TIME_WAIT状态，再停留2个MSL时间，进入CLOSED状态。</p>
<p>用途：</p>
<p>\1. 可靠地实现TCP全双工连接的终止。避免对方收不到自己的ACK，等对方重发FIN。</p>
<p>\2. 保证旧连接的重复分组在网络中消逝。避免服务器重启（或者其他服务器绑定同样端口）接收到了上一次的数据。（TCP分组可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分组在路由器修复后也会被送到最终目的地，这个迟到的迷途分组到达时可能会引起问题。）</p>
<h3 id="TIME-WAIT状态后为什么需要等2MSL"><a href="#TIME-WAIT状态后为什么需要等2MSL" class="headerlink" title="TIME_WAIT状态后为什么需要等2MSL*"></a>TIME_WAIT状态后为什么需要等2MSL*</h3><p>****MSL****：maximum segment lifetime(最大报文生存时间），指报文能在互联网上生存的最长时间，超过这个时间报文将在网络中消失 。MSL在RFC 1122上建议是2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p>
<p>MSL多长？一般是60s.</p>
<p>cat /proc/sys/net/ipv4/tcp_fin_timeout</p>
<p>等待2MSL时间主要目的是怕四次握手的最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p>
<h3 id="TIME-WAIT状态过多原因与解决"><a href="#TIME-WAIT状态过多原因与解决" class="headerlink" title="TIME_WAIT状态过多原因与解决*"></a>TIME_WAIT状态过多原因与解决*</h3><p>查看当前系统下所有连接状态的数：</p>
<p>[root@vps ~]#netstat -n|awk ‘/^tcp/{++S[$NF]}END{for (key in S) print key,S[key]}’</p>
<p>TIME_WAIT 286</p>
<p>FIN_WAIT1 5</p>
<p>FIN_WAIT2 6</p>
<p>ESTABLISHED 269</p>
<p>SYN_RECV 5</p>
<p>CLOSING 1</p>
<p>原因：短时间内（比如1s）进行大量的短连接，可能出现time wait状态过多。</p>
<p>一般情况下，持续2MSL，不会有太大影响；但如果短时间内过多，会创建大量fd，导致fd被用尽，系统无法再发起新连接。</p>
<p>解决办法：<em><strong>*修改TIME_*</strong>***</em>*WAIT****<em><strong>*时间的Linux内核参数**</strong></em></p>
<p>在****/etc/sysctl.conf****文件中，加入：</p>
<p>net.ipv4.tcp_tw_reuse = 1（默认为0，表示关闭）</p>
<p># 表示开启重用。允许将TIME-WAIT的socket重新用于新的TCP连接</p>
<p>由于两端都使用了时间戳，所以能够避免序列号重复。</p>
<p>net.ipv4.tcp_tw_recycle = 1（默认为0，表示关闭）</p>
<p>#表示开启TCP连接中TIME-WAIT sockets的快速回收</p>
<p><em><strong>*内核如何回收socket**</strong></em></p>
<p>TCP有一种行为，可以缓存每个连接最新的时间戳，后续请求中如果时间戳小于缓存的时间戳，即视为无效，相应的数据包会被丢弃。</p>
<p>Linux是否启用这种行为取决于tcp_timestamps和tcp_tw_recycle，其中tcp_timestamps缺省就是开启的，所以当tcp_tw_recycle被开启后，实际上这种行为就被激活了。</p>
<p>在NAT系统中会共享套接字和时间戳，因此会出现时间戳错乱的情况，后面的数据包就被丢弃了，具体的表现通常是客户端明明发送的SYN，但服务端就是不响应ACK。</p>
<p>net.ipv4.tcp_max_tw_buckets = 5000    </p>
<p>#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。</p>
<p>建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置。</p>
<p>修改 linux kernel 的 tcp time wait的时间。</p>
<p>在 $KERNEL/include/net/tcp.h里面，有下面的行：</p>
<p>#define <em><strong>*TCP_TIMEWAIT_LEN*</strong></em> (60*HZ)</p>
<p>而这个宏是真正控制 TCP TIME_WAIT 状态的超时时间的。根据我们的测试，设置为 10 秒比较合适，即：  　　</p>
<p>#define TCP_TIMEWAIT_LEN (10*HZ)</p>
<p>然后重新编译内核，重启系统即可发现短连接造成的TIME_WAIT状态大大减少。一般情况都可以至少减少2/3。也能相应提高系统应对短连接的速度。</p>
<p>net.ipv4.tcp_fin_timeout = 5    </p>
<p># 修改系统默认的 TIMEOUT 时间（输出用，不用真正起作用）</p>
<p>net.ipv4.tcp_syncookies = 1    （默认为0，表示关闭）</p>
<p>#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击</p>
<p>最后输入下面的命令，让内核参数生效：sudo sysctl -p</p>
<p>net.ipv4.tcp_keepalive_time = 1200 （缺省是2小时，改为20分钟）</p>
<p>#表示当keepalive启用的时候，TCP发送keepalive消息的频度</p>
<p>net.ipv4.ip_local_port_range = 10000 65000    </p>
<p>#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。</p>
<p>net.ipv4.tcp_max_syn_backlog = 8192    </p>
<p>#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数</p>
<h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT*"></a>CLOSE_WAIT*</h3><p>CLOSE_WAIT，借用某位大牛的话来说应该倒过来叫做 WAIT_CLOSE，也就是说「等待关闭」</p>
<p>A发出 FIN 包，B响应 ACK 包，此时，B就进入了 CLOSE_WAIT 状态。如果一切正常，稍后B会发出 FIN 包，然后进入 LAST_ACK 状态。</p>
<p>如果出现大量的 CLOSE_WAIT 状态，那么就意味着B没有及时发出 FIN 包，一般有如下几种可能：</p>
<ol>
<li><p>程序问题：代码层面忘记关闭相应的 socket 连接导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到</p>
</li>
<li><p>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。</p>
</li>
<li><p>BACKLOG 太大：此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在队列里就被对方关闭了。</p>
</li>
</ol>
<p>服务器中存在大量close wait的危害：</p>
<p>大量close wait会占用服务器的fd，而一个机器能打开的fd数量是有限的，超过后就无法分配fd，无法建立新连接。</p>
<h3 id="CLOSE-WAIT-TIME-WAIT哪个危害大"><a href="#CLOSE-WAIT-TIME-WAIT哪个危害大" class="headerlink" title="CLOSE_WAIT TIME_WAIT哪个危害大*"></a>CLOSE_WAIT TIME_WAIT哪个危害大*</h3><p>通常情况下，time wait对服务器影响有限，而大量的close wait风险较高，一般正确编码可以避免。</p>
<h2 id="TCP粘包拆包"><a href="#TCP粘包拆包" class="headerlink" title="TCP粘包拆包"></a>TCP粘包拆包</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p>
<p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为一个进行发送，这就形成了粘包问题。</p>
<p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p>
<h3 id="具体出现场景"><a href="#具体出现场景" class="headerlink" title="具体出现场景"></a>具体出现场景</h3><p>假设client向服sever连续发送了两个数据包，packet1和packet2，server收到的数据可分为三种：</p>
<ol>
<li><p>正常收到两个数据包，没有发生拆包和粘包</p>
</li>
<li><p>只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包</p>
</li>
</ol>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps44.jpg" alt="img"> </p>
<ol start="3">
<li>接收端收到了两个数据包，但是这两个数据包是不完整的、或者是多出来一块，这种情况即发生了拆包和粘包（Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理）</li>
</ol>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps45.jpg" alt="img"> </p>
<h3 id="为什么TCP有拆包粘包-UDP没有"><a href="#为什么TCP有拆包粘包-UDP没有" class="headerlink" title="为什么TCP有拆包粘包  UDP没有"></a>为什么TCP有拆包粘包  UDP没有</h3><p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生，日常的网络应用开发大都在传输层进行。</p>
<p>UDP有消息保护边界，不会发生粘包拆包问题。</p>
<p>因此粘包拆包问题只发生在TCP中。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组。</p>
<p>常用方案：</p>
<ol>
<li><p>消息定长，比如每个报文的大小为固定长度200字节，如果不够，空位补空格</p>
</li>
<li><p>在包尾增加回车换行符进行分割，例如FTP协议</p>
</li>
<li><p>将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，只有读取到足够长度的消息之后才算是读到了一个完整的消息</p>
</li>
<li><p>通过自定义协议进行粘包和拆包的处理。</p>
</li>
</ol>
<h3 id="TCP粘包拆包-发生的原因"><a href="#TCP粘包拆包-发生的原因" class="headerlink" title="TCP粘包拆包 发生的原因"></a>TCP粘包拆包 发生的原因</h3><ol>
<li><p>应用程序写入的数据大于套接字的缓冲区大小，发生拆包</p>
</li>
<li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，发生粘包</p>
</li>
<li><p>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</p>
</li>
<li><p>接收方法不及时读取套接字缓冲区数据，这将发生粘包</p>
</li>
</ol>
<p>摘自：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/azraelly/archive/2012/12/25/2832393.html">https://www.cnblogs.com/azraelly/archive/2012/12/25/2832393.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4cd3de320f7">https://www.jianshu.com/p/e4cd3de320f7</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.huoding.com/2016/01/19/488">https://blog.huoding.com/2016/01/19/488</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/298214130">https://www.zhihu.com/question/298214130</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计算机网络/Websocket"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Websocket/"
    >Websocket</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Websocket/" class="article-date">
  <time datetime="2021-09-10T05:49:02.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>WebSocket 是一种网络通信协议，应用层协议。</p>
<p>已经有了 HTTP 协议，为什么还需要另一个协议：因为 HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p>
<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p>
<p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>特点：</p>
<ol>
<li><p>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</p>
</li>
<li><p>建立在 TCP 协议之上，服务器端的实现比较容易</p>
</li>
<li><p>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</p>
</li>
<li><p>数据格式比较轻量，性能开销小，通信高效</p>
</li>
<li><p>可以发送文本，也可以发送二进制数据</p>
</li>
<li><p>没有同源限制，客户端可以与任意服务器通信</p>
</li>
<li><p>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。比如ws://example.com:80/some/path</p>
</li>
</ol>
<p>WebSocket依赖于HTTP连接，那么它如何从连接的HTTP协议转化为WebSocket协议？</p>
<p>每个WebSocket连接都始于一个HTTP请求。具体来说，WebSocket协议在第一次握手连接时，通过HTTP协议在传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端：</p>
<p>GET /chat HTTP/1.1</p>
<p>Host: server.example.com</p>
<p>Upgrade: websocket</p>
<p>Connection: Upgrade</p>
<p>Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==</p>
<p>Origin: <a href="http://example.com/">http://example.com</a></p>
<p>Sec-WebSocket-Version: 13</p>
<p>Upgrade首部，用来把当前的HTTP请求升级到WebSocket协议。</p>
<p>WebSocket为什么要依赖于HTTP协议的连接？</p>
<ol>
<li><p>WebSocket设计上就是天生为HTTP增强通信（全双工通信等），所以在HTTP协议连接的基础上是很自然的一件事，并因此而能获得HTTP的诸多便利</p>
</li>
<li><p>兼容支持，比如即使服务器不支持WebSocket也能建立HTTP通信，只不过返回的是onerror而已，这显然比服务器无响应要好的多。</p>
</li>
</ol>
<h3 id="HTTP-长连接-WebSocket-长连接"><a href="#HTTP-长连接-WebSocket-长连接" class="headerlink" title="HTTP 长连接  WebSocket 长连接*"></a>HTTP 长连接  WebSocket 长连接*</h3><p>在http1.1中，Connection默认为Keep-alive参数，可以用这个来作为长连接。</p>
<p>缺点：没法做到服务端主动发送通知给客户端的。</p>
<p>在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。WebSocket是一种双向通信协议。</p>
<p>摘自：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/86a550a521c5">https://www.jianshu.com/p/86a550a521c5</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计算机网络/HTTPS"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/"
    >HTTPS</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/" class="article-date">
  <time datetime="2021-09-10T05:45:40.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>[TOC]</p>
<h3 id="1-HTTPS是什么"><a href="#1-HTTPS是什么" class="headerlink" title="1. HTTPS是什么"></a>1. HTTPS是什么</h3><p>定义：HTTPS（全称： Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。HTTPS由两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体来说，HTTPS是HTTP报文直接将报文信息传输给SSL套接字进行加密，SSL加密后将加密后的报文发送给TCP套接字，然后TCP套接字再将加密后的报文发送给目的主机，目的主机将通过TCP套接字获取加密后的报文给SSL套接字，SSL解密后交给对应进程。</p>
<p>HTTP： 直接通过明文在浏览器和服务器之间传递信息。</p>
<p>HTTPS： 采用 对称加密算法加密数据+非对称加密算法交换密钥+数字证书验证身份 结合的方式来保护浏览器和服务端之间的通信安全。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/wps37.jpg" alt="img"> </p>
<h3 id="2-HTTPS-请求-加密过程"><a href="#2-HTTPS-请求-加密过程" class="headerlink" title="2. HTTPS 请求/加密过程"></a>2. HTTPS 请求/加密过程</h3><p><em><strong>*HTTPS是对称加密还是非对称加密**</strong></em></p>
<p>随机值：非对称加密</p>
<p>数据传输：对称加密</p>
<p>\1. client用户在浏览器里输入一个HTTPS网址，然后连接到服务端的443端口。以明文传输请求信息，包含版本信息，加密-套件候选列表，压缩算法候选列表，随机数，扩展字段等信息</p>
<p>\2. 服务端配置。采用HTTPS协议的服务器必须要有一套数字证书，这个证书中包含私钥和公钥。可以自己制作和向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。</p>
<p>\3. server返回证书，以及包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S</p>
<p>\4. client验证证书的合法性，包括可信性，是否吊销，过期时间和域名(这部分工作是由客户端的SSL/TLS来完成的)。首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题<em><strong>*（*</strong>***</em>*如何验证合法性*********）****。</p>
<p>\5. 如果证书没有问题，client就生成一个随机值。然后用证书的公钥对这个随机值进行加密，发送给server</p>
<p>\6. server用证书的私钥解密，得到这个随机值。将这个随机值作为对称加密的密匙，对要传输的数据进行加密，并传输给client。</p>
<p>\7. client使用随机值解密信息，获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p>
<p><img src="file:///C:\Users\FYR\AppData\Local\Temp\ksohtml21792\wps38.jpg" alt="img"> </p>
<p>公钥和私钥：</p>
<p>公钥：锁；私钥：钥匙。</p>
<p>锁可以给别人，别人可以用这个锁把重要的东西锁起来，发给你。</p>
<p>钥匙只有一把，也就是只有你能看到被锁起来的数据。</p>
<h3 id="3-为什么不直接用非对称加密传输数据"><a href="#3-为什么不直接用非对称加密传输数据" class="headerlink" title="3. 为什么不直接用非对称加密传输数据*"></a>3. 为什么不直接用非对称加密传输数据*</h3><p>\1. 只有server有私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密</p>
<p>\2. 非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的</p>
<h3 id="4-对称加密-非对称加密"><a href="#4-对称加密-非对称加密" class="headerlink" title="4. 对称加密  非对称加密"></a>4. 对称加密  非对称加密</h3><p>对称加密：采用的是使用相同密钥对报文进行加密解密</p>
<p>encrypt(明文，秘钥) = 密文</p>
<p>decrypt(密文，秘钥) = 明文</p>
<p>典型的对称加密算法有DES、AES等；</p>
<p>非对称加密：加密和解密是需要不同的秘钥的。</p>
<p>encrypt(明文，公钥) = 密文</p>
<p>decrypt(密文，私钥) = 明文</p>
<p>典型的非对称加密算法有RSA、DSA等。</p>
<h3 id="5-为什么非对称加密慢"><a href="#5-为什么非对称加密慢" class="headerlink" title="5. 为什么非对称加密慢"></a>5. 为什么非对称加密慢</h3><p>对称加密主要的运算是****位运算****，速度非常快，如果使用硬件计算，速度会更快。以 AES 算法为例，如下图所示，其运算本质上来说就是位移和替换。另外还有一个原因是，AES 中的许多中间计算过程是可以事先计算好的。加密数据时许多中间过程可以直接查表，而不需要实时地计算。</p>
<p>但是非对称加密计算****一般都比较复杂****，比如 RSA，它里面涉及到大数乘法、大数模等等运算。</p>
<h3 id="6-HTTPS用到了哪些加密技术"><a href="#6-HTTPS用到了哪些加密技术" class="headerlink" title="6. HTTPS用到了哪些加密技术*"></a>6. HTTPS用到了哪些加密技术*</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xdyixia/p/9237742.html">https://www.cnblogs.com/xdyixia/p/9237742.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/WoTrusCA/article/details/100105031">https://blog.csdn.net/WoTrusCA/article/details/100105031</a></p>
<p>非对称加密技术：</p>
<h3 id="7-TLS-SSL-HTTP-HTTPS的关系"><a href="#7-TLS-SSL-HTTP-HTTPS的关系" class="headerlink" title="7.TLS/SSL, HTTP, HTTPS的关系"></a>7.TLS/SSL, HTTP, HTTPS的关系</h3><p>SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协 议，均用于在传输层为数据通讯提供安全支持。 </p>
<p>可以将HTTPS协议简单理解为HTTP协议＋TLS/SSL </p>
<p>引用</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e30a8c4fa329">https://www.jianshu.com/p/e30a8c4fa329</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计算机网络/HTTP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"
    >HTTP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/" class="article-date">
  <time datetime="2021-09-10T05:35:17.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h3 id="1-HTTP是什么"><a href="#1-HTTP是什么" class="headerlink" title="1. HTTP是什么"></a>1. HTTP是什么</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
<h3 id="2-状态码"><a href="#2-状态码" class="headerlink" title="2. 状态码"></a>2. 状态码</h3><p><strong>1XX：Informational信息性状态码，接收的请求正在处理</strong></p>
<p><strong>2XX：Success成功状态码，请求正常处理完毕</strong></p>
<p>​    200：ok 请求成功</p>
<p>​    204：no content请求成功，但没有结果返回</p>
<p>​    206：partial content客户端请求一部分资源，服务端成功响应，返回一部分资源</p>
<p><strong>3XX：Redirection重定向状态码</strong></p>
<p>代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请    求地址（重定向目标）在本次响应的Location域中指明。</p>
<p>​    300 Multiple Choices</p>
<p>​    被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议    信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p>
<p>​    301：move permanently永久性重定向</p>
<p>​    被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。</p>
<p>​    302：found临时性重定向</p>
<p>​    要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。</p>
<p>​    注意：很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。[20]因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p>
<p>​    303：see other</p>
<p>​    对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</p>
<p>​    304：not modified </p>
<p>​    表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</p>
<p>​    307 temporary redirect </p>
<p>​    在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求。</p>
<p><strong>4XX：Client Error客户端错误状态码，服务器无法处理的请求</strong></p>
<p>​    400：bad request</p>
<p>​    由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗    性路由请求），服务器不能或不会处理该请求。</p>
<p>​    401：unauthorized</p>
<p>​    该状态码表示当前请求需要用户验证。</p>
<p>​    第一次请求后，响应包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户    信息。客户端第二次请求，重复提交一个包含恰当的Authorization头信息的请求，如果再次    返回401响应代表着服务器验证已经拒绝了那些证书，认证失败。</p>
<p>​    403：forbidden</p>
<p>​    服务器已经理解请求，但是拒绝执行它。</p>
<p>​    404：not found</p>
<p>​    服务器上无法找到请求的资源</p>
<p>​    405：method not allow请求所针对的资源不支持对应的请求方法</p>
<p><strong>5XX：Server Error服务器错误状态码，服务器处理请求出错</strong></p>
<p>​    500：internal server error服务端执行请求时发生了错误</p>
<p>​    502：bad Gateway网关错误</p>
<p>​    503：service unavailable服务器正在超负载或停机维护，无法处理请求</p>
<h3 id="3-HTTP-请求头字段"><a href="#3-HTTP-请求头字段" class="headerlink" title="3. HTTP 请求头字段"></a>3. HTTP 请求头字段</h3><ol>
<li><p>Accept : 浏览器可以接收的内容类型，例如 Accept: text/plain</p>
</li>
<li><p>Accept-Charset：浏览器能识别的字符集，例如 Accept-Charset: utf-8</p>
</li>
<li><p>Accept-Encoding：浏览器可以处理的编码方式，注意这里的编码方式有别于字符集，这里的编码方式通常指gzip,deflate等。例如 Accept-Encoding: gzip, deflate</p>
</li>
<li><p>Accept-Language：浏览器接收的语言，其实也就是用户在什么语言地区，例如简体中文的就是 Accept-Language: zh-CN</p>
</li>
<li><p>Accept-Datetime：设置接受的版本时间，例如Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</p>
</li>
<li><p>Via：用来记录一个请求经过了哪些代理或网关才被送到目标服务器上</p>
</li>
<li><p>Referer：指当前请求的URL是在什么地址引用的</p>
</li>
<li><p>User-Agent： 通常就是用户的浏览器相关信息。例如：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0</p>
</li>
<li><p>Cache-Control：这个指令在request和response中都有，用来指示缓存系统（服务器上的，或者浏览器上的）应该怎样处理缓存。eg：Cache-Control: no-cache</p>
</li>
<li><p>Connection：告诉服务器这个浏览器想要使用怎样的连接方式。值有keep-alive和close</p>
</li>
</ol>
<p>等等。</p>
<h3 id="4-HTTP-长连接-短连接"><a href="#4-HTTP-长连接-短连接" class="headerlink" title="4. HTTP  长连接 短连接*"></a>4. HTTP  长连接 短连接*</h3><p><em><strong>如何保证长连接</strong></em></p>
<p>短连接：客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。在HTTP/1.0中默认使用。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在请求头中设置：<em><strong>Connection:keep-alive</strong></em></p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>开启Keep-Alive的优缺点：</p>
<p>优点：Keep-Alive模式更加高效，因为避免了连接建立和释放的开销。</p>
<p>缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</p>
<h3 id="5-HTTP-无状态，如何保存用户状态"><a href="#5-HTTP-无状态，如何保存用户状态" class="headerlink" title="5. HTTP 无状态，如何保存用户状态"></a>5. HTTP 无状态，如何保存用户状态</h3><p>HTTP 是一种无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p>
<p>那么我们保存用户状态呢？Session 机制。</p>
<p>主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p>Cookie 被禁用怎么办?</p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<h3 id="6-HTTP-八种请求方式"><a href="#6-HTTP-八种请求方式" class="headerlink" title="6. HTTP 八种请求方式*"></a>6. HTTP 八种请求方式*</h3><p><em><strong>*get*</strong></em> 请求从服务器获取特定资源</p>
<p><em><strong>*post*</strong></em> 在服务器上创建一个新的资源</p>
<p>put 更新服务器上的资源（更新整个资源，比如编号12的学生信息）</p>
<p>delete 从服务器删除特定的资源</p>
<p>head 类似于get，只不过返回的响应中没有具体内容，用于获取报头</p>
<p>options 返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</p>
<p>connect 预留给能够将连接改为管道方式的代理服务器</p>
<p>trace 回显服务器收到的请求，主要用于测试或诊断</p>
<h3 id="7-HTTP-1-0-HTTP-1-1"><a href="#7-HTTP-1-0-HTTP-1-1" class="headerlink" title="7. HTTP 1.0 HTTP 1.1"></a>7. HTTP 1.0 HTTP 1.1</h3><p>主要区别主要体现在：</p>
<ol>
<li><p>长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求</p>
</li>
<li><p>错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除</p>
</li>
<li><p>缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略</p>
</li>
<li><p>带宽优化及网络连接的使用 :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。、</p>
</li>
</ol>
<h4 id="9-http-1-0、1-1、2-0"><a href="#9-http-1-0、1-1、2-0" class="headerlink" title="9. http***1.0、1.1、2.0***"></a>9. <em><strong>http</strong>***</em>1.0、1.1、2.0***</h4><p><em><strong>HTTP1.0版本的特性：</strong></em></p>
<p>①　早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。</p>
<p>②　HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p>
<p> <strong>HTTP1.1版本新特性</strong></p>
<p>①　默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</p>
<p>②　管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</p>
<p>③　断点续传原理</p>
<p><strong>HTTP2.0版本的特性</strong></p>
<p>①　二进制分帧（采用二进制格式的编码将其封装）</p>
<p>②　首部压缩（设置了专门的首部压缩设计的HPACK算法。）</p>
<p>③　流量控制（设置了接收某个数据流的多少字节一些流量控制）</p>
<p>④　多路复用（可以在共享TCP链接的基础上同时发送请求和响应）</p>
<p>⑤　请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）</p>
<p>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。</p>
<h3 id="10-HTTP断点重传"><a href="#10-HTTP断点重传" class="headerlink" title="10. HTTP断点重传"></a>10. HTTP断点重传</h3><p>定义：HTTP/FTP 服务器或下载软件具有断点续传能力，允许用户从上传/下载断线的地方继续传送。 </p>
<p>HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。它通过在 Header 里两个参数实现的，客户端发请求时对应的是 <em><strong>*Range*</strong></em> ，服务器端响应时对应的是 ****Content-Range****。</p>
<p>Range：用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：</p>
<p>Range:(unit=first byte pos)-[last byte pos]</p>
<p>Range 头部的格式有以下几种情况：</p>
<p>Range: bytes=0-499 表示第 0-499 字节范围的内容 </p>
<p>Range: bytes=500-999 表示第 500-999 字节范围的内容 </p>
<p>Range: bytes=-500 表示最后 500 字节的内容 </p>
<p>Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容 </p>
<p>Range: bytes=0-0,-1 表示第一个和最后一个字节 </p>
<p>Range: bytes=500-600,601-999 同时指定几个范围</p>
<p>Content-Range：用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。一般格式：</p>
<p>Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth]</p>
<p>例如：</p>
<p>Content-Range: bytes 0-499/22400</p>
<p>0－499 是指当前发送的数据的范围，而 22400 则是文件的总大小。</p>
<p>而在响应完成后，返回的响应头状态码也不同：</p>
<p>HTTP/1.1 <em><strong>*200*</strong></em> Ok（不使用断点续传方式） </p>
<p>HTTP/1.1 <em><strong>*206*</strong></em> Partial Content（使用断点续传方式）表示客户端请求一部分资源，服务端成功响应，返回一部分资源</p>
<p>增强校验</p>
<p>在实际场景中，会出现一种情况，即在终端发起续传请求时，URL 对应的文件内容在服务器端已经发生变化，此时续传的数据肯定是错误的。解决办法：</p>
<ol>
<li><p>Last-Modified 来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动。</p>
</li>
<li><p>使用 ETag 头来放置文件的唯一标识</p>
</li>
</ol>
<p>检测服务器是否支持断点续传</p>
<p>[root@localhost ~]# curl <em><strong>*-i –range 0-9*</strong></em> <a target="_blank" rel="noopener" href="http://www.baidu.com/img/bdlogo.gif">http://www.baidu.com/img/bdlogo.gif</a></p>
<p>HTTP/1.1 206 Partial Content</p>
<p>Date: Mon, 21 Nov 2016 05:26:29 GMT</p>
<p>Server: Apache</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM “</p>
<p>Set-Cookie: BAIDUID=0CD0E23B4D4F739954DFEDB92BE6CE03:FG=1; expires=Tue, 21-Nov-17 05:26:29 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Last-Modified: Fri, 22 Feb 2013 03:45:02 GMT</p>
<p>ETag: “627-4d648041f6b80”</p>
<p>Accept-Ranges: bytes</p>
<p>Content-Length: 10</p>
<p>Cache-Control: max-age=315360000</p>
<p>Expires: Thu, 19 Nov 2026 05:26:29 GMT</p>
<p>Content-Range: bytes 0-9/1575</p>
<p>Connection: Keep-Alive</p>
<p>Content-Type: image/gif</p>
<p>能够找到 Content-Range，则表明服务器支持断点续传。有些服务器还会返回 Accept-Ranges，输出结果 Accept-Ranges: bytes ，说明服务器支持按字节下载。</p>
<p><em><strong>*Last-Modified*</strong></em>    服务器发给客户</p>
<p>If-Modified-Since    客户发给服务器</p>
<p>都是用于记录页面最后修改时间的 HTTP 头信息。再次请求本地存在的 cache 页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的 Last-Modified 最后修改时间戳发送回去，这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担。</p>
<p>（304：not modified 服务端已经执行了GET，但文件未变化）</p>
<p><em><strong>*Etag*</strong></em></p>
<p>为了解决 Last-Modified 无法解决的一些问题。</p>
<p>一些文件也许会周期性的更改，但是内容并不改变（仅改变修改时间），这时候我们并不希望客户端认为这个文件被修改了，而重新 GET。</p>
<p>某些文件修改非常频繁，例如：在秒以下的时间内进行修改（1s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）。</p>
<p>某些服务器不能精确的得到文件的最后修改时间。</p>
<p>为此，HTTP/1.1 引入了 Etag。Etag 仅仅是一个和文件相关的标记，可以是一个版本标记，例如：v1.0.0；或者说 “627-4d648041f6b80” 这么一串看起来很神秘的编码。但是 HTTP/1.1 标准并没有规定 Etag 的内容是什么或者说要怎么实现，唯一规定的是 Etag 需要放在 “” 内。</p>
<p>If-Range</p>
<p>用于判断实体是否发生改变，如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。一般格式：If-Range: Etag | HTTP-Date</p>
<p>也就是说，If-Range 可以使用 Etag 或者 Last-Modified 返回的值。当没有 ETage 却有 Last-modified 时，可以把 Last-modified 作为 If-Range 字段的值。</p>
<p>例如：</p>
<p>If-Range: “627-4d648041f6b80” </p>
<p>If-Range: Fri, 22 Feb 2013 03:45:02 GMT</p>
<p>If-Range 必须与 Range 配套使用。如果请求报文中没有 Range，那么 If-Range 就会被忽略。如果服务器不支持 If-Range，那么 Range 也会被忽略。</p>
<p>如果请求报文中的 Etag 与服务器目标内容的 Etag 相等，即没有发生变化，那么应答报文的状态码为 206。如果服务器目标内容发生了变化，那么应答报文的状态码为 200。</p>
<p>用于校验的其他 HTTP 头信息：If-Match/If-None-Match、If-Modified-Since/If-Unmodified-Since。</p>
<h3 id="11-HTTP-HTTPS"><a href="#11-HTTP-HTTPS" class="headerlink" title="11. HTTP  HTTPS*"></a>11. HTTP  HTTPS*</h3><p>区别：</p>
<ol>
<li><p>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>
</li>
<li><p>安全性： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在****SSL/TLS****之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以，HTTP 安全性没有 HTTPS高。</p>
</li>
<li><p>资源消耗：HTTPS 比HTTP耗费更多服务器资源</p>
</li>
<li></li>
</ol>
<h3 id="12-HTTP-Request-Response格式"><a href="#12-HTTP-Request-Response格式" class="headerlink" title="12. HTTP Request Response格式*"></a>12. HTTP Request Response格式*</h3><p>HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息︰ </p>
<p>请求（requests）–由客户端发送用来触发一个服务器上的动作</p>
<p>​    起始行</p>
<p>​    Headers</p>
<p>​    Body</p>
<p>响应（responses）–来自服务器的应答。</p>
<p>​    状态行</p>
<p>​    Headers</p>
<p>​    Body</p>
<p><em><strong>*Request*</strong>***</em>*- 起始行****</p>
<p>包含三个元素：</p>
<p>\1. HTTP 方法，GET, PUT 或者 POST等</p>
<p>\2. 请求目标 ，通常是一个 URL，或者是协议、端口和域名的绝对路径，通常以请求的环境为特征。</p>
<p>\3. HTTP 版本 </p>
<p><em><strong>*Request*</strong>***</em>*- Headers****</p>
<p>整个 header（包括值）由一行组成，这一行可以相当长。</p>
<p>有许多请求头可用，它们可以分为几组：</p>
<p>\1. General headers，例如 Via，适用于整个报文。</p>
<p>\2. Request headers，例如 User-Agent，Accept-Type，通过进一步的定义(例如 Accept-Language)，或者给定上下文(例如 Referer)，或者进行有条件的限制 (例如 If-None) 来修改请求。</p>
<p>\3. Entity headers，例如 Content-Length，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/wps35-1631252167679.jpg" alt="img"> </p>
<p><em><strong>*Request*</strong>***</em>*- Body****</p>
<p>请求的最后一部分是它的 body。不是所有的请求都有一个 body：例如获取资源的请求，GET，HEAD，DELETE 和 OPTIONS，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 POST 请求（包含 HTML 表单数据）。</p>
<p>Body 大致可分为两类：</p>
<p>\1. Single-resource bodies，由一个单文件组成。该类型 body 由两个 header 定义： Content-Type 和 Content-Length.</p>
<p>\2. Multiple-resource bodies，由多部分 body 组成，每一部分包含不同的信息位。通常是和  HTML Forms 连系在一起。</p>
<p><em><strong>*Response*</strong>***</em>*-状态行****</p>
<p>HTTP 响应的起始行被称作 状态行 (status line)，包含以下信息：</p>
<p>\1. 协议版本，通常为 HTTP/1.1</p>
<p>\2. 状态码 (status code)，表明请求是成功或失败。常见的状态码是 200，404，或 302。</p>
<p>\3. 状态文本 (status text)。一个简短的，纯粹的信息，通过状态码的文本描述，帮助人们理解该 HTTP 消息。</p>
<p>一个典型的状态行看起来像这样：HTTP/1.1 404 Not Found。</p>
<p><em><strong>*Response*</strong>***</em>*-Headers****</p>
<p>有许多响应头可用，这些响应头可以分为几组：</p>
<p>\1. General headers，例如 Via，适用于整个报文</p>
<p>\2. Response headers，例如 Vary 和 Accept-Ranges，提供其它不符合状态行的关于服务器的信息</p>
<p>\3. Entity headers，例如 Content-Length，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/wps36-1631252167678.jpg" alt="img"> </p>
<p><em><strong>*Response*</strong>***</em>*-Body****</p>
<p>响应的最后一部分是 body。不是所有的响应都有 body：具有状态码 (如 201 或 204) 的响应，通常不会有 body。</p>
<p>Body 大致可分为三类：</p>
<ol>
<li><p>Single-resource bodies，由已知长度的单个文件组成。该类型 body 由两个 header 定义：Content-Type 和 Content-Length。</p>
</li>
<li><p>Single-resource bodies，由未知长度的单个文件组成，通过将 Transfer-Encoding 设置为 chunked 来使用 chunks 编码</p>
</li>
<li><p>Multiple-resource bodies，由多部分 body 组成，每部分包含不同的信息段。但这是比较少见的。</p>
</li>
</ol>
<p>引用：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/findumars/p/5745345.html">https://www.cnblogs.com/findumars/p/5745345.html</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计算机网络/DNS"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/"
    >DNS</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/" class="article-date">
  <time datetime="2021-09-10T05:31:16.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h2 id="1-DNS"><a href="#1-DNS" class="headerlink" title="1. DNS"></a>1. <strong>DNS</strong></h2><p>域名系统(Domain Name System：将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>DNS域名解析过程：</p>
<p>在主机中输入<a target="_blank" rel="noopener" href="http://www.bytedancom/">www.bytedancom</a></p>
<ol>
<li><p>浏览器缓存中查询</p>
</li>
<li><p>系统缓存中查询，本地的hosts文件</p>
</li>
<li><p>路由器缓存</p>
</li>
<li><p>主机开始****递归查询****本地域名服务器。</p>
<ol>
<li><p>先查本地域名服务器的缓存。如果没有，继续下一步</p>
</li>
<li><p>本地域名服务器代替主机，以DNS client的身份，进行下一步查询，这个查询过程称为<em><strong>*迭代查询*</strong></em></p>
</li>
</ol>
<p>​    ① 请求根域名服务器，返回com服务器地址</p>
<p>​    ② 请求com服务器，返回bytedance.com服务器地址</p>
<p>​    ③ 请求bytedance.com服务器，返回<a target="_blank" rel="noopener" href="http://www.bytedance.com/">www.bytedance.com</a>服务器地址</p>
<ol start="3">
<li>把这个地址返回给主机</li>
</ol>
</li>
</ol>
<p>本地DNS服务器一般是网络服务商提供的DNS，也可以自己修改为常用的公共DNS。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps31.jpg" alt="img"> </p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps32.jpg" alt="img"> </p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps33.jpg" alt="img"> </p>
<h2 id="2-域名解析记录"><a href="#2-域名解析记录" class="headerlink" title="2. 域名解析记录"></a>2. <em><strong>域名解析记录</strong></em></h2><p>域名注册完成后首先需要做域名解析，即把域名指向网站所在服务器的IP。</p>
<p>域名解析时会添加解析记录，这些记录有：A记录、AAAA记录、CNAME记录、MX记录、NS记录、TXT记录、SRV记录、URL转发。</p>
<p><em><strong>*A记录*</strong>***</em>******： 将域名指向一个IPv4地址</p>
<p>****CNAME记录****： 将域名指向另一个域名，实现与被指向域名相同的访问效果</p>
<p>****NS记录****：将子域名指定某个域名服务器来解析</p>
<p>****SOA记录****：起始授权机构记录，用于在众多NS记录中标记哪一台是主服务器</p>
<p>****AAAA记录****： 将域名指向一个IPv6地址</p>
<p>****MX记录****： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录</p>
<p>****TXT记录****： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录</p>
<p>****SRV记录****：记录哪台计算机提供哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）</p>
<p>****PTR记录****： A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名</p>
<p><em><strong>*显性*</strong>***</em>*URL转发记录****： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址。例如：将<a href="http://www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。">www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。</a></p>
<p><em><strong>*隐性*</strong>***</em>*UR转发记录L****： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将<a href="http://www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn。">www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn。</a></p>
<h2 id="3-我的域名如何实现"><a href="#3-我的域名如何实现" class="headerlink" title="3. 我的域名如何实现"></a>3. <em><strong>我的域名如何实现</strong></em></h2><p>购买域名<a target="_blank" rel="noopener" href="https://www.namesilo.com/">https://www.namesilo.com/</a></p>
<p>配置自己域名的CNAME Record：</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps34.jpg" alt="img"> </p>
<p>设置github自定义域名：</p>
<p>本地博客public目录下新建CNAME文件(无后缀名,纯文件),在其中填入新的域名</p>
<p>juliajiang.top</p>
<h2 id="4-在浏览器中输入-url地址直到显示页面的过程"><a href="#4-在浏览器中输入-url地址直到显示页面的过程" class="headerlink" title="4. 在浏览器中输入***url地址直到显示页面的过程*******"></a>4. <em><strong>在浏览器中输入</strong>***</em>url地址<strong><strong><strong>直到</strong></strong></strong>显示<strong><strong><strong>页面</strong></strong></strong>的过程*******</h2><ol>
<li><p>浏览器输入url后，DNS解析</p>
<p>① DNS，查找过程：浏览器缓存、路由器缓存、DNS缓存</p>
</li>
<li><p>建立TCP连接</p>
<p>① TCP：与服务器建立TCP连接（传输层）</p>
<p>② IP：建立TCP连接时，需要发送数据，发送数据在网络层使用IP协议（网络层）</p>
<p>③ OSPF：open shortest path first开放最短路径优先，IP数据包在路由器之间进行选择时使用（网络层）</p>
<p>④ ARP：路由器在与服务器通信时，将IP地址转为MAC地址（数据链路层）</p>
</li>
<li><p>浏览器向web服务器发送http请求</p>
<p>① HTTP：使用http协议访问网页（应用层）</p>
</li>
<li><p>服务器处理请求，并返回http报文</p>
</li>
<li><p>浏览器解析渲染页面</p>
</li>
<li><p>连接结束</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计算机网络/计算机体系结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"
    >计算机体系结构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2021-09-10T05:28:07.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/wps30.jpg" alt="img"> </p>
<h3 id="1-对比"><a href="#1-对比" class="headerlink" title="1. 对比"></a>1. <em><strong>对比</strong></em></h3><p>OSI模型：是一个完整的、完善的宏观理论模型</p>
<p>TCP/IP：更加侧重的是围绕TCP/IP协议展开的一系列通信协议的分层</p>
<h3 id="2-OSI每一层的作用"><a href="#2-OSI每一层的作用" class="headerlink" title="2. OSI每一层的作用"></a>2. <em><strong>OSI每一层的作用</strong></em></h3><table>
<thead>
<tr>
<th><em><strong>*OSI七层模型*</strong></em></th>
<th><em><strong>*功能*</strong></em></th>
<th><em><strong>*对应的网络协议*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*应用层*</strong></em></td>
<td>应用层是网络体系中最高的一层，也是唯一面向用户的一层，也可视为****为用户提供常用的应用程序****，每个网络应用都对应着不同的协议</td>
<td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>
</tr>
<tr>
<td><em><strong>*表示层*</strong></em></td>
<td>主要负责****数据格式的转换****，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密，同时也对应用层的协议进行翻译</td>
<td>Telnet, Rlogin, SNMP, Gopher</td>
</tr>
<tr>
<td><em><strong>*会话层*</strong></em></td>
<td>负责网络中两节点的建立，在数据传输中****维护计算机网络中两台计算机之间的通信连接****，并决定何时终止通信</td>
<td>SMTP, DNS</td>
</tr>
<tr>
<td><em><strong>*传输层*</strong></em></td>
<td>是整个网络关键的部分，是实现****两个用户进程间端到端的可靠通信，****处理数据包的错误等传输问题。是向下通信服务最高层，向上用户功能最底层。即向网络层提供服务，向会话层提供独立于网络层的传送服务和可靠的透明数据传输。</td>
<td>TCP, UDP</td>
</tr>
<tr>
<td><em><strong>*网络层*</strong></em></td>
<td>进行逻辑地址寻址，实现不同****网络之间的路径选择****，IP就在网络层</td>
<td>IP, ICMP, ARP, RARP, AKP, UUCP</td>
</tr>
<tr>
<td><em><strong>*数据链路层*</strong></em></td>
<td>物理地址（MAC地址），网络设备的唯一身份标识。****建立逻辑连接、进行硬件地址寻址****，相邻的两个设备间的互相通信</td>
<td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继</td>
</tr>
<tr>
<td><em><strong>*物理层*</strong></em></td>
<td>七层模型中的最底层，主要是****物理介质传输媒介*<em><strong>（网线或者是无线），</strong></em>*在不同设备中传输比特****，将0/1信号与电信号或者光信号互相转化</td>
<td>IEEE 802.1A, IEEE 802.2到IEEE 802</td>
</tr>
</tbody></table>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="3-五层-每一层作用"><a href="#3-五层-每一层作用" class="headerlink" title="3. 五层 每一层作用"></a>3. <em><strong>五层</strong></em> <em><strong>每一层作用</strong></em></h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><em><strong>应用层</strong></em></h4><ol>
<li><p>任务：应用进程间的通信和交互。</p>
</li>
<li><p>应用层协议：域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP</p>
</li>
<li><p>交互的数据单元称为报文</p>
</li>
</ol>
<h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a><em><strong>运输层</strong></em></h4><ol>
<li><p>任务：负责向两台主机进程之间的通信提供的数据传输服务。应用进程利用该服务传送应用层报文。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
</li>
<li><p>两种协议</p>
<ol>
<li><p>传输控制协议 TCP（Transmission Control Protocol），提供面向连接的，可靠的数据传输服务</p>
</li>
<li><p>用户数据协议 UDP（User Datagram Protocol），提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</p>
</li>
</ol>
</li>
</ol>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><em><strong>网络层</strong></em></h4><ol>
<li><p>任务：选择合适的网间路由和交换结点，确保数据及时传送。</p>
</li>
<li><p>数据单元：IP数据报。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。</p>
</li>
<li><p>协议：无连接的网际协议IP（Internet Protocol）和许多路由选择协议ARP RARP OSPF</p>
</li>
<li><p>注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
</li>
</ol>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ol>
<li><p>任务：两台主机之间的链路上的数据传输 </p>
</li>
<li><p>数据单元：帧。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
</li>
</ol>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><em><strong>物理层</strong></em></h4><ol>
<li><p>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
</li>
<li><p>数据单位：比特。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据结构/排序算法总结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"
    >排序算法总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2021-09-10T05:25:12.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h4 id="复杂度总结"><a href="#复杂度总结" class="headerlink" title="复杂度总结"></a><em><strong>复杂度总结</strong></em></h4><p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/wps29.jpg" alt="img"> </p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a><em><strong>思路</strong></em></h4><h5 id="（1）直接插入"><a href="#（1）直接插入" class="headerlink" title="*（1）直接插入*"></a><em><strong>*（1）直接插入*</strong></em></h5><p>每次将一个待排序的数据，插入到前面已经排好序的序列之中，直到全部数据插入完成。</p>
<h5 id="（2）-二分法插入排序"><a href="#（2）-二分法插入排序" class="headerlink" title="*（2） 二分法插入排序*"></a><em><strong>*（2） 二分法插入排序*</strong></em></h5><p>首先取出原有序中间数与新插的数比较，然后插入新数大小包含于其中的一半数组，再次取该数组中间数,如此重复下去，直至最后得到数组个数为一，将最后得到的数之后的数后移，然后将新插入的数放在该索引处。</p>
<h5 id="（3）希尔排序"><a href="#（3）希尔排序" class="headerlink" title="*（3）希尔排序*"></a><em><strong>*（3）希尔排序*</strong></em></h5><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称希尔排序为“跳着插”</p>
<h5 id="（4）简单选择排序"><a href="#（4）简单选择排序" class="headerlink" title="*（4）简单选择排序*"></a><em><strong>*（4）简单选择排序*</strong></em></h5><p>数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，直到整个数组变有序区。</p>
<h5 id="（5）堆排序"><a href="#（5）堆排序" class="headerlink" title="*（5）堆排序*"></a><em><strong>*（5）堆排序*</strong></em></h5><p>堆排序的难点就在于堆的的插入和删除。</p>
<p>堆的插入就是——每次插入都是将新数据放在数组最后，而从这个新数据的父结点到根结点必定是一个有序的数列，因此只要将这个新数据插入到这个有序数列中即可。</p>
<p>堆的删除就是——堆的删除就是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点开始将一个数据在有序数列中进行“下沉”。</p>
<p>因此，堆的插入和删除非常类似直接插入排序，只不是在二叉树上进行插入过程。所以可以将堆排序形容为“树上插”</p>
<h5 id="（6）冒泡排序"><a href="#（6）冒泡排序" class="headerlink" title="*（6）冒泡排序*"></a><em><strong>*（6）冒泡排序*</strong></em></h5><p>通过交换使相邻的两个数变成小数在前大数在后，这样每次遍历后，最大的数就“沉”到最后面了。重复N次即可以使数组有序。</p>
<p>冒泡排序改进1：在某次遍历中如果没有数据交换，说明整个数组已经有序。因此通过设置标志位来记录此次遍历有无数据交换就可以判断是否要继续循环。</p>
<p>冒泡排序改进2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</p>
<h5 id="（7）快速排序"><a href="#（7）快速排序" class="headerlink" title="*（7）快速排序*"></a><em><strong>*（7）快速排序*</strong></em></h5><p>“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。因此将数组分成二部分再分别重复上述步骤就完成了排序。</p>
<h5 id="（8）归并排序"><a href="#（8）归并排序" class="headerlink" title="*（8）归并排序*"></a><em><strong>*（8）归并排序*</strong></em></h5><p>当一个数组左边有序，右边也有序，那合并这两个有序数组就完成了排序。如何让左右两边有序了？用递归！这样递归下去，合并上来就是归并排序。</p>
<h5 id="（9）基数排序"><a href="#（9）基数排序" class="headerlink" title="*（9）基数排序*"></a><em><strong>*（9）基数排序*</strong></em></h5><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据结构/常用数据结构总结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"
    >常用数据结构总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2021-09-10T05:08:03.000Z" itemprop="datePublished">2021-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.<em>数组</em></h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><em>概念</em></h4><p><strong>数组</strong>（Array） 是一种很常见的数据结构。它由****相同类型的元素****（element）组成，并且是使用一块连续的内存来存储。</p>
<p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
<p>数组的特点是：****提供随机访问 并且容量有限****。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong><strong>使用场景</strong></strong></h4><p>1）数据量较小。</p>
<p>2）数据规模已知。</p>
<p>3）随机访问，修改元素值。</p>
<p>如果插入速度很重要，选择无序数组。如果查找速度很重要，选择有序数组，并使用二分查找。</p>
<h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. <em>链表</em></h2><p>****链表*<em><strong>（LinkedList） 虽然是一种</strong></em>*线性表****，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p>
<p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在<em><strong>*查找一个节点或者访问特定位置的节点的时候复杂度为 O(n)*</strong></em> 。</p>
<p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p>
<h4 id="链表分类"><a href="#链表分类" class="headerlink" title="链表分类"></a>链表分类</h4><ol>
<li><p>单链表</p>
</li>
<li><p>双向链表</p>
</li>
<li><p>循环链表</p>
</li>
<li><p>双向循环链表</p>
</li>
</ol>
<p><strong>单链表</strong></p>
<p>单链表 单向链表****只有一个方向，结点只有一个后继指针 next 指向后面的节点****。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p>
<p><strong>循环链表</strong></p>
<p>循环链表 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p>
<p><strong>双向链表</strong></p>
<p>双向链表 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>
<p><strong>双向循环链表</strong></p>
<p>双向循环链表 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>如果需要支持随机访问的话，链表没办法做到。</p>
<p>如果需要****存储的数据元素的个数不确定*<em><strong>，并且需要</strong></em>*经常添加和删除数据****的话，使用链表比较合适。</p>
<p>如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。</p>
<h4 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h4><p>· 数组支持随机访问，而链表不支持。</p>
<p>· 数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</p>
<p>· 数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</p>
<h2 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>****栈 (stack)*<em><strong>只允许在</strong></em>*有序的线性数据集合的一端（称为栈顶 top）进行加入数据****（push）和移除数据（pop）。因而按照 <em><strong>*后进先出*<em><strong>（LIFO, Last In First Out） 的原理运作。在栈中，</strong></em>*push 和 pop 的操作都发生在栈顶。*</strong></em></p>
<p>栈常用一维****数组或链表****来实现，用数组实现的栈叫作 顺序栈 ，用链表实现的栈叫作 链式栈 。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 后进先出（LIFO, Last In First Out） 的特性时，我们就可以使用栈这个数据结构。</p>
<p><strong>1.实现浏览器的回退和前进功能</strong></p>
<p>我们只需要使用<em><strong>*两个栈*</strong></em>(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 ****1,2,3,4 这四个页面压入 Stack1 中****。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 ****4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中****。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。</p>
<p>2.<strong>检查符号是否成对出现</strong></p>
<p>括号匹配问题：</p>
<ol>
<li><p>首先我们将括号间的对应规则存放在 Map 中，这一点应该毋容置疑；</p>
</li>
<li><p>创建一个栈。遍历字符串，如果字符是****左括号就直接加入stack中****，否则将stack 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果stack为空，返回 true。</p>
</li>
</ol>
<p>3.<strong>反转字符串</strong></p>
<p>将字符串中的每个字符先入栈再出栈就可以了。</p>
<p>4.<strong>维护函数调用</strong></p>
<p>最后一个被调用的函数必须先完成执行，符合栈的 后进先出（LIFO, Last In First Out） 特性。</p>
<h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h2><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>队列 是 <em><strong>*先进先出*</strong></em>( FIFO，First In, First Out) 的线性表。在具体应用中通常用****链表或者数组*<em><strong>来实现，用数组实现的队列叫作 顺序队列 ，用链表实现的队列叫作 链式队列 。队列只允许在</strong></em>*后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除****操作也就是出队 dequeue</p>
<p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>
<h4 id="队列分类"><a href="#队列分类" class="headerlink" title="队列分类"></a>队列分类</h4><p><strong>单队列</strong></p>
<p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <em><strong>*顺序队列（数组实现）*</strong></em> 和 ****链式队列（链表实现）****。</p>
<p><em><strong>*顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。*</strong></em></p>
<p><strong>循环队列</strong></p>
<p>****循环队列*<em><strong>可以解决顺序队列的</strong></em>*假溢出和越界问题****。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p>
<p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p>
<p><strong>·</strong> <em><strong>阻塞队列：</strong></em> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</p>
<p><strong>·</strong> <em><strong>线程池中的请求/任务队列：</strong></em> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：FixedThreadPool 使用无界队列 LinkedBlockingQueue。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出java.util.concurrent.RejectedExecutionException 异常。</p>
<p>· Linux 内核进程队列（按优先级排队）</p>
<p>· 现实生活中的派对，播放器上的播放列表;</p>
<p>· 消息队列</p>
<h2 id="5-图"><a href="#5-图" class="headerlink" title="5. 图"></a>5. 图</h2><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>图就是由****顶点*<em><strong>的有穷非空集合和</strong></em>*顶点之间的边**<strong>组成的集合。通常表示为：</strong>G(V,E)**，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>无向图和有向图</strong></p>
<p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就<em><strong>不用关注方向，用不带箭头的边表示，这样的图就是无向图。</strong></em></p>
<p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是<strong>有向图</strong>。</p>
<p><strong>无权图和带权图</strong></p>
<p>对于一个关系，如果我们只****关心关系的有无，而不关心关系有多强*<em><strong>，那么就可以用</strong></em>*无权图****表示二者的关系。</p>
<p>对于一个关系，如果我们****既关心关系的有无，也关心关系的强度*<em><strong>，比如描述地图上两个城市的关系，需要用到距离，那么就用</strong></em>*带权图****来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。</p>
<h4 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h4><p><strong>邻接矩阵存储</strong></p>
<p>邻接矩阵将图用****二维矩阵存储****，是一种较为直观的表示方式。</p>
<p>如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 A[i][j]=n 。</p>
<p>在****无向图****中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，A[i][j]=1，当顶点i和顶点j没有关系时，A[i][j]=0。</p>
<p><strong>邻接表存储</strong></p>
<p>针对上面<em><strong>*邻接矩阵比较浪费内存空间*<em><strong>的问题，诞生了图的另外一种存储方法—</strong></em>*邻接表*</strong></em> 。</p>
<p>邻接链表使用****一个链表来存储某个顶点的所有后继相邻顶点****。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 邻接表。</p>
<h4 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h4><p><strong>广度优先搜索-队列</strong></p>
<p>广度优先搜索就像水面上的波纹一样一层一层向外扩展。</p>
<p><strong>深度优先搜索-栈</strong></p>
<p>深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”。</p>
<h2 id="6-堆"><a href="#6-堆" class="headerlink" title="6. 堆"></a>6. 堆</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>堆是一种满足以下条件的树：</p>
<p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p>
<p><strong>·</strong> <em><strong>堆不一定是完全二叉树</strong></em>，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。</p>
<p>· （<em><strong>二叉</strong></em>）堆是一个数组，它可以被看成是一个 ****近似的完全二叉树****。——《算法导论》第三版</p>
<h4 id="堆的用途"><a href="#堆的用途" class="headerlink" title="堆的用途"></a>堆的用途</h4><p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p>
<p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 O(nlog(n))，查找最大值或者最小值时间复杂度都是 O(1)，但是，涉及到更新（插入或删除）数据时，时间复杂度为 O(n)，即使是使用复杂度为 O(log(n)) 的二分法找到要插入或者删除的数据，在移动数据时也需要 O(n) 的时间复杂度。</p>
<p><em><strong>*相对于有序数组而言，堆的主要优势在于更新数据效率较高。*</strong></em> 堆的初始化时间复杂度为 O(nlog(n))，堆可以做到O(1)时间复杂度取出最大值或者最小值，O(log(n))时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。</p>
<h4 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h4><p>堆分为 <em><strong>*最大堆*</strong></em> 和 ****最小堆****。二者的区别在于节点的排序方式。</p>
<p><strong>·</strong> <em><strong>*最大堆*</strong></em> ：堆中的每一个节点的值都大于等于子树中所有节点的值</p>
<p><strong>·</strong> <em><strong>*最小堆*</strong></em> ：堆中的每一个节点的值都小于等于子树中所有节点的值</p>
<h4 id="堆的操作总结"><a href="#堆的操作总结" class="headerlink" title="堆的操作总结"></a>堆的操作总结</h4><p><strong>·</strong> <em><strong>*插入元素*</strong></em> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</p>
<p><strong>·</strong> <em><strong>*删除堆顶元素*</strong></em> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</p>
<h2 id="7-树"><a href="#7-树" class="headerlink" title="7. 树"></a>7. 树</h2><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a><em>概念</em></h4><p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。</p>
<p>一棵树具有以下特点：</p>
<ol>
<li><p>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</p>
</li>
<li><p>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</p>
</li>
<li><p>一棵树不包含回路。</p>
</li>
</ol>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>①　二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p>
<p>②　二叉树 的分支通常被称作“左子树”或“右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒。</p>
<p>③　二叉树 的第 i 层至多拥有 2^(i-1) 个节点，深度为 k 的二叉树至多总共有 2^k-1 个节点</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 ****满二叉树****。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 ****满二叉树****。如下图所示：</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 <em><strong>*完全二叉树*</strong></em> 。</p>
<p>大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><em><strong>平衡二叉树</strong></em> 是一棵二叉排序树，且具有以下性质：</p>
<ol>
<li><p>可以是一棵空树</p>
</li>
<li><p>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p>
</li>
</ol>
<p>平衡二叉树的常用实现方法有 <em><strong>红黑树</strong></em>、<em><strong>AVL 树</strong></em>、<em><strong>替罪羊树</strong></em>、<em><strong>加权平衡树</strong></em>、<em><strong>伸展树</strong></em> 等。</p>
<h4 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h4><p>二叉树的存储主要分为 <em><strong>*链式存储*</strong></em> 和 <em><strong>*顺序存储*</strong></em> 两种：</p>
<p><strong>链式存储</strong></p>
<p>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。</p>
<p>每个节点包括三个属性：</p>
<p>· 数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</p>
<p>· 左节点指针 left</p>
<p>· 右节点指针 right。</p>
<p><strong>顺序存储</strong></p>
<p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2 _ i 的位置，它的右子节点存储在下标为 2 _ i+1 的位置。</p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>先序、中序、后续</p>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉查找树：为了实现快速查找而生。要求在树的任意一个节点，左子树中每个节点的值都小于这个节点的值，右子树中每个节点的值都大于这个节点。</p>
<h4 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树：二叉树中任意一个节点的左右子树的高度相差不能大于1.</p>
<p>平衡二叉查找树：（很多并没有严格符合上述定义）</p>
<p>****设计初衷*****：解决普通二叉查找树在频繁插入、删除等动态更新情况下，出现的复杂度退化问题。让整个树比较平衡。</p>
<p>平衡二叉树有哪些：</p>
<p>​    AVL树，高度平衡的二叉查找树</p>
<p>​    红黑树，根节点到各个叶子结点的最大路径可能会比最短路径大一倍。</p>
<p>​    Splay Tree伸展树</p>
<p>​    Treap树堆</p>
<p><em><strong>*如何保持平衡：*</strong></em></p>
<p>根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。</p>
<p>分为LL型、RR型、LR型和RL型4种类型</p>
<p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps25.jpg" alt="img"> </p>
<p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps26.jpg" alt="img"> </p>
<p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps27.jpg" alt="img"> </p>
<p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps28.jpg" alt="img"> </p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是平衡二叉查找树的一种。</p>
<p><em><strong>*红黑树*</strong></em></p>
<p>Red-Black Tree，R-B Tree，不严格的平衡二叉查找树，做到了近似平衡。</p>
<p>解决普通二叉查找树在频繁插入、删除等动态更新情况下，出现的复杂度退化问题。让整个树比较平衡。</p>
<p>红黑树的高度近似log2n，插入、删除、查找操作的时间复杂度都是O(logn)。</p>
<p>红黑树是一种性能非常稳定的二叉查找树。</p>
<p>相比于AVL，<em><strong>*红黑树优势：*</strong></em></p>
<p>引入RB-Tree是功能、性能、空间开销的折中结果。</p>
<ol>
<li><p>维护成本：红黑树较小，AVL更大</p>
</li>
<li><p>读取性能：红黑树略逊于AVL</p>
</li>
<li><p>空间开销：两者类似，内容极多时略优于AVL</p>
</li>
</ol>
<p>基本上主要的几种平衡树看来，红黑树有着良好的稳定性，综合实力强。实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<p>定义：红黑树中的节点一类被标记为黑色，一类标记为红色，还有几个要求：</p>
<ol>
<li><p>根节点为黑色</p>
</li>
<li><p>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据</p>
</li>
<li><p>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的</p>
</li>
<li><p>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点</p>
</li>
</ol>
<h4 id="红黑树、B-树"><a href="#红黑树、B-树" class="headerlink" title="红黑树、B+树"></a>红黑树、B+树</h4><p>红黑树多用在内部排序，即全放在内存中的，STL的map和set的内部实现就是红黑树。</p>
<p>B+树多用于外存上时，B+也被成为一个磁盘友好的数据结构。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> fyr
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/my.jpg" alt="Fanfan"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/life">生活</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>