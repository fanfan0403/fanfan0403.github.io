<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>其它知识点</title>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="应用层常见协议"><a href="#应用层常见协议" class="headerlink" title="应用层常见协议"></a>应用层常见协议</h2><p>\1. HTTP：超文本传输协议，端口号：80</p>
<p>\2. FTP：文件传输协议，端口号：21</p>
<p>\3. DNS：域名系统 (Domain Name System)，端口号：53</p>
<p>\4. SMTP（SimpleMailTransferProtocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，端口号：25</p>
<p>\5. Telnet协议：是Internet远程登陆服务的标准协议和主要方式，端口号：23</p>
<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a><em><strong>ARP</strong></em> <em><strong>协议</strong></em></h2><p>通过 IP 地址向 MAC 地址的转换，网络层协议</p>
<p>工作过程：</p>
<p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p>
<p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p>
<p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p>
<p>\1. A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址</p>
<p>\2. 如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址。将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</p>
<p>\3. 主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p>
<p>\4. 主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</p>
<p>\5. 当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p>
<h2 id="NAT-协议"><a href="#NAT-协议" class="headerlink" title="NAT 协议"></a><em><strong>NAT</strong></em> <em><strong>协议</strong></em></h2><p>NAT协议（Network Address Translation），网络地址转换协议。</p>
<p>作用：将局域网中的IP地址(私有地址)映射到公网的IP（全局地址）。</p>
<p>NAT功能通常运行在网关设备上，NAT路由器会维护一张NAT转化表。</p>
<p>工作过程：</p>
<p>\1. 主机H想访问Web服务器，首先会发送数据包到NAT路由器；</p>
<p>\2. NAT路由器在NAT转换表上记录主机H的内网地址和端口，并为它分配一个全局地址和全局端口与之映射，按照目的地址发送给服务器。</p>
<p>\3. 服务器回应给NAT路由器后，路由器查询NAT转换表，将对应关系转换回去发送给主机H。</p>
<h2 id="公网私网地址"><a href="#公网私网地址" class="headerlink" title="公网私网地址"></a><em><strong>公网私网地址</strong></em></h2><p>在IPv4地址协议中预留了3个IP地址段，作为私有地址，供组织机构内部使用。</p>
<p>这三个地址段分别位于A、B、C三类地址内：</p>
<p>A类地址：10.0.0.0–10.255.255.255</p>
<p>B类地址：172.16.0.0–172.31.255.255 </p>
<p>C类地址：192.168.0.0–192.168.255.255</p>
<h2 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI URL"></a><em><strong>URI</strong></em> <em><strong>URL</strong></em></h2><p>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</p>
<p>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="socket可以TCP和UDP共用吗"><a href="#socket可以TCP和UDP共用吗" class="headerlink" title="*socket可以TCP和UDP共用吗*"></a><em><strong>*socket可以TCP和UDP共用吗*</strong></em></h2><p>可以</p>
<p>linux是以协议、ip、端口来绑定端口的，所以不同协议相同的ip和端口也是可以绑定成功的</p>
<h2 id="为什么DNS即使用TCP又使用UDP"><a href="#为什么DNS即使用TCP又使用UDP" class="headerlink" title="*为什么DNS即使用TCP又使用UDP**"></a><em><strong>*为什么DNS即使用TCP又使用UDP**</strong></em></h2><p>大多数情况下，DNS解析请求和响应都很小，使用UDP协议更加高效，虽然没有TCP可靠，但是速度快，消耗的系统资源更少，非常适合少量数据包的传输。</p>
<p>一些DNS事务，比如区域传输或其他附加查询，可能会产生大于512字节的数据包，因此使用TCP更加可靠，使用TCP会减少丢包和重新发包的情况，因此更加可靠与高效。</p>
<p>DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；</p>
<p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。</p>
<p>区域传输是DNS的事务，对准确性要求比较高，而且会产生大于512字节的数据包，因此使用TCP协议。</p>
<p>为什么既使用TCP又使用UDP？</p>
<p>UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。</p>
<p>区域传送时使用TCP，原因如下：</p>
<p>\1. 数据同步传送的数据量比一个请求和应答的数据量要多得多，比如区域传送</p>
<p>\2. TCP是一种可靠的连接，保证了数据的准确性</p>
<p>域名解析时使用UDP协议</p>
<p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p>
<h2 id="进程可以共用多个端口号吗"><a href="#进程可以共用多个端口号吗" class="headerlink" title="*进程可以共用多个端口号吗**"></a><em><strong>*进程可以共用多个端口号吗**</strong></em></h2><p>可以</p>
<p>数据接收时时根据五元组{传输协议，源IP，目的IP，源端口，目的端口}判断接受者的。</p>
<p>TCP、UDP可以同时绑定一个端口8888，但是一个端口在同一时刻不可以被TCP或者UDP绑定2次。</p>
<p>TCP和UDP传输协议监听同一个端口后，接收数据互不影响，不冲突。因为数据接收时时根据五元组{传输协议，源IP，目的IP，源端口，目的端口}判断接受者的。</p>
<p>端口号可以用来标识同一个主机上通信的不同应用程序，端口号+IP地址就可以组成一个套接字，用来标识一个进程。</p>
<h2 id="MAC-IP-TCP-UDP-头＊"><a href="#MAC-IP-TCP-UDP-头＊" class="headerlink" title="*MAC* *IP*　*TCP* *UDP*****头＊****"></a><em><strong>*MAC*</strong></em> <em><strong>*IP*</strong></em>　<em><strong>*TCP*</strong></em> <em><strong>*UDP*</strong>***</em>*头＊****</h2><p><em><strong>*MAC：1*</strong>***</em>*4B****</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps48.jpg" alt="img"> </p>
<p><em><strong>*IP*</strong>***</em>*：2*<strong><strong><strong>*0B+*</strong></strong></strong>*可选字段****</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps49.jpg" alt="img"> </p>
<p><em><strong>*TCP：2*</strong>***</em>*0*<strong><strong><strong>*B*</strong></strong></strong>*+****<em><strong>*可变长度*</strong></em></p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps50.jpg" alt="img"> </p>
<p><em><strong>*UDP头：*</strong>***</em>*8****<em><strong>*B*</strong></em></p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/wps51.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>cookie、session、token</title>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>存储在浏览器中</p>
<p>浏览器实现的一种数据存储功能</p>
<p>工作过程：cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到本地，下一次请求同一网站时会把该cookie发送给服务器，服务器可以通过cookie中携带的数据区分不同的用户。</p>
<p>cookie存在客户端上的，浏览器：</p>
<p>加入了一些限制确保cookie不会被恶意使用</p>
<p>每个域的cookie数量是有限的，保证cookie不会占据太多磁盘空间</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>存储在服务器上</p>
<p>作用：服务器用来区分请求来自谁</p>
<p>server给每个client分配不同的“身份标识”， client每次向server发请求的时候，都带上这个“身份标识”，server就知道这个请求来自于谁了。</p>
<p>对于浏览器客户端，一般采用 cookie 的方式存储session</p>
<p>缺点：服务器端保存占用内存</p>
<p>工作过程：</p>
<p>\1. 浏览器端第一次发送请求到server，server创建一个Session，同时会创建一个特殊的****Cookie*<em><strong>（name为</strong></em>*JSESSIONID****的固定值，value为session对象的ID），然后将该Cookie发送至client</p>
<p>\2. client再发送请求到server时，浏览器端就会携带该JSESSIONID的Cookie对象</p>
<p>\3. server端根据JSESSIONID这个Cookie的value(sessionId),去查询Session对象，从而区分不同用户</p>
<h3 id="cookie-session-区别"><a href="#cookie-session-区别" class="headerlink" title="cookie session 区别**"></a>cookie session 区别**</h3><p>cookie：浏览器实现的一种数据存储功能</p>
<p>session：服务器用来区分请求来自谁。有很多种实现方法，浏览器客户端一般用cookie来实现。</p>
<p>具体区别：</p>
<p><strong>1.</strong> ****存放位置****：cookie在客户的浏览器上，session在服务器上</p>
<p><strong>2.</strong> ****安全性****：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗； session安全</p>
<p><strong>3.</strong> ****服务器内存占用****：session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能； cookie存在在客户端，不存在这个问题</p>
<p><strong>4.</strong> ****大小限制****：一个站点在客户端存放的cookie不能超过3K</p>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token令牌</p>
<p>存储在客户端</p>
<p>应用：在Web领域基于Token的身份验证</p>
<p>解决的问题：session保存在服务器端，会有很大的压力。token的目的就是让客户端保存数据，并且客户端不能伪造数据信息。</p>
<p><em><strong>*特点：*</strong></em></p>
<p>\1. 无状态、可扩展</p>
<p>\2. 支持移动设备</p>
<p>\3. 跨程序调用</p>
<p>\4. 安全</p>
<p>****缺点：****Token 中的数据是明文保存的（虽然会用Base64做下编码， 但那不是加密），不能在其中保存像密码这样的敏感信息</p>
<p>****优点：****server不保存session对象， 只是生成token ，然后验证token，即用CPU计算时间获取了session 存储空间</p>
<p><em><strong>*工作流程：*</strong></em></p>
<p>\1. 用户A登录系统后， 服务器给他发一个令牌(token)， 里边包含了A的用户数据</p>
<p>\2. 为了保证安全，对数据做了签名。比如使用HMAC-SHA256 算法，加上一个server才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。这个token保存在客户端，server不保存。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/wps46.jpg" alt="img"> </p>
<p>\3. 下一次A再次通过Http 请求访问服务器时，在HTTP请求头中带上这个token </p>
<p>\4. server收到token后，再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E3%80%81session%E3%80%81token/wps47.jpg" alt="img"> </p>
<h3 id="token如何使用"><a href="#token如何使用" class="headerlink" title="token如何使用"></a>token如何使用</h3><p>将登陆信息等重要信息存放为session</p>
<p>其他信息如果需要保留，可以放在cookie中</p>
<h3 id="多个服务器如何共享session"><a href="#多个服务器如何共享session" class="headerlink" title="多个服务器如何共享session"></a>多个服务器如何共享session</h3><p>通过redis共享session，把session放在内存中，并可以实现持久化和主从同步。</p>
<p>其他方案的问题：</p>
<p>\1. 使用专门的mysql服务器存储所有的session信息，用户的请求会先在这个数据库中check一下session的情况</p>
<ol>
<li>缺点：依赖性太强，当mysql出问题时会影响整个系统</li>
</ol>
<p>\2. 把session信息写在客户端cookie中。当访问服务器A时，登录成功后，将产生的session信息存放在cookie当中，发给客户端。当请求分发到服务器B时，B先判断自己是否存储了这个session的信息，如果没有，再去客户端的cookie中获取这个session信息，并把这个信息存储到B</p>
<ol>
<li>缺点：cookie安全性不高，容易伪造；如果客户端禁止使用cookie可能造成无法共享session</li>
</ol>
<p>\3. 通过服务器之间的数据同步session，使用一台服务器作为登录服务器，当用户成功后，会将session写到当前服务器上，通过脚本或守护进程将session信息同步到其他服务器</p>
<ol>
<li>缺点：速度慢，同步session有延迟；单向同步时，整个系统不能正常运行</li>
</ol>
<p>\4. 通过memcache同步session，把web服务器的内存组合起来，成为一个内存池，所有服务器产生的session都存放在这个内存池中</p>
<ol>
<li><p>优点：不会加大数据库的负担，安全性也比cookie方式高，并且把session存在内存中，比文件中读取快</p>
</li>
<li><p>缺点：memcache把内存分成存储块，这样memcache可能会产生内存碎片；如果内存块不足，可能产生内存溢出</p>
</li>
</ol>
<p>实际中，使用memcache和redis。</p>
<h3 id="session如何创建"><a href="#session如何创建" class="headerlink" title="session如何创建"></a>session如何创建</h3><p>sessionid第一次产生是在某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建。</p>
<p>tomcat的ManagerBase类提供创建sessionid的方法：随机数+时间+jvmid；</p>
<h3 id="session攻击与防御"><a href="#session攻击与防御" class="headerlink" title="session攻击与防御"></a>session攻击与防御</h3><p>基于session的攻击有很多种方式。大部分的手段都是首先通过捕获合法用户的session, 然后冒充该用户来访问系统。攻击者至少可以通过以下三种方式来获取一个有效的session标识符：预测、捕获（劫持）、固定。</p>
<p>防御方法：</p>
<p>\1. 在登录后重置sessionID。在登录验证成功后，通过重置session，是之前的匿名sessionId失效，这样可以避免使用伪造的sessionId进行攻击。</p>
<p>\2. 关闭透明化Session ID。透明化Session ID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。</p>
<p>\3. 设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击</p>
<p>\4. 验证HTTP头部信息，确保User-Agent头部信息一致的确是有效的</p>
<h3 id="除了session和cookies还有什么缓存"><a href="#除了session和cookies还有什么缓存" class="headerlink" title="除了session和cookies还有什么缓存"></a>除了session和cookies还有什么缓存</h3><p><a href="https://blog.csdn.net/weixin_30481087/article/details/102073804">https://blog.csdn.net/weixin_30481087/article/details/102073804</a></p>
<p>\1. localStorage： 是一种你不主动清除它，它会一直将存储数据存储在客户端的存储方式，即使你关闭了客户端（浏览器)，属于本地持久层储存 </p>
<p>\2. sessionStorage： 用于本地存储一个会话（session）中的数据，一旦会话关闭，那么数据会消失，比如刷新。</p>
<p>有时候，我们需要将数据存储到sessionStorage和localStorage中，这样做的好处有：</p>
<p>\1. 缓存数据</p>
<p>\2. 减少对内存的占用</p>
<p>但是，storage只能存储字符串的数据，对于JS中常用的数组或对象却不能直接存储。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><em>TCP</em></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<h3 id="TCP-如何保证可靠传输"><a href="#TCP-如何保证可靠传输" class="headerlink" title="TCP 如何保证可靠传输"></a>TCP 如何保证可靠传输</h3><p><em><strong>*TCP如何保证数据的完整性*</strong>***</em>*？*****包编号；校验和</p>
<p>应用数据被分割成 TCP 认为最适合发送的数据块。</p>
<p>\1. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传给应用层</p>
<p>\2. 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
<p>\3. TCP 的接收端会丢弃重复的数据</p>
<p>\4. 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段</p>
<p>\5. 流量控制：利用滑动窗口实现</p>
<p>\6. 停止等待ARQ和连续ARQ协议：确认和超时</p>
<p>\7. 拥塞控制</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 利用滑动窗口实现流量控制。</p>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p>TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p>
<h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议*"></a>ARQ 协议*</h3><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是数据链路层和传输层的错误纠正协议之一。它通过使用****确认*<em><strong>和</strong></em>*超时****这两个机制。</p>
<p>目的：在不可靠服务的基础上实现可靠的信息传输。</p>
<p>如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<p><em><strong>*停止等待*</strong>***</em>*ARQ协议****</p>
<p>基本原理：每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p>优点： 简单</p>
<p>缺点： 信道利用率低，等待时间长</p>
<p>运行机制：</p>
<p>\1. 无差错情况:发送方发送分组,接收方在规定时间内收到并回复确认.发送方发送新的分组。</p>
<p>\2. 出现差错情况（超时重传）:只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。</p>
<p>\3. 确认丢失：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</p>
<p>\4. 确认迟到：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</p>
<p><em><strong>*连续*</strong>***</em>*ARQ协议****</p>
<p>目的：提高信道利用率。</p>
<p>基本原理：发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</p>
<p>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传</p>
<p>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制***"></a>拥塞控制***</h3><p>拥塞定义：网络中的数据太多，导致某个路由器处理不过来或处理地太慢。</p>
<p>具体： 当发送的数据到达网络中的一个节点时（假设是路由器），它会根据数据包含的地址进行转发。但这些节点需要先将接收到的数据放入自己的内存（可能还要做一些处理），再从中取出进行转发。但路由器的内存是有限的，若同一时间到达某个路由器的数据太多，这个路由器将无法接收所有的数据，只能将一部分丢弃；或者要等待较长的时间才会被转发。</p>
<p>拥塞控制定义：在网络中发生拥塞时，减少向网络中发送数据的速度，防止造成恶性循环；同时在网络空闲时，提高发送数据的速度，最大限度地利用网络资源。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。</p>
<p>TCP的拥塞控制使用四种算法：</p>
<ol>
<li><p><strong>慢开始和拥塞避免</strong></p>
<p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p>
<p>慢开始算法：由小到大、乘法增长，逐渐增加拥塞窗口的大小。即1,2,4,8…目的：不要一开始就发送大量的数据，先探测一下网络的拥塞程度</p>
<p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh：</p>
<p>当cwnd&lt;ssthresh时，使用慢开始算法。</p>
<p>当cwnd&gt;ssthresh时，改用拥塞避免算法。</p>
<p>当cwnd=ssthresh时，慢开始与拥塞避免算法任意。</p>
<p>拥塞避免算法让拥塞窗口缓慢增长，拥塞窗口cwnd加1，而不是加倍。</p>
<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（没有收到确认、分组丢失），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。</p>
</li>
<li><p>快重传和快恢复</p>
<p>目的：快速恢复丢失的数据包</p>
<p>快重传：接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p>快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半。发送方将cwnd设置为ssthresh的大小，然后执行拥塞避免算法，加法增大。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞，所以不用慢开始。</p>
</li>
</ol>
<h3 id="TCP最大连接数"><a href="#TCP最大连接数" class="headerlink" title="TCP最大连接数*"></a>TCP最大连接数*</h3><p>client：内核开放了50000个端口可以供TCP连接使用，最大理论范围是0-65535。</p>
<p>client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大tcp连接数为65535。</p>
<p>用命令查看：</p>
<p>$ sysctl -a | grep ip_local_port_range</p>
<p>net.ipv4.ip_local_port_range = 15000   65000</p>
<p>当Linux作为客户端建立连接的时候，最大连接数量是受内核参数</p>
<p>net.ipv4.ip_local_port_range限制，而ip_local_port_range是可配置的，最大理论范围是0-65535。</p>
<p>对于有一个IP的客户端来说，受限于ip_local_port_range参数，也受限于65535。但单Linux可以配置多个ip，有几个ip，最大理论值就翻几倍。</p>
<p>server：</p>
<p>server通常固定在某个本地端口上监听，等待client的连接请求，本地监听端口是独占的。</p>
<p>一条TCP连接是由一个四元组组成的。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，对于我们这台Nginx Server来说，它的IP和端口是固定的。4元组中只有client ip和client port是可变的。因此最大的连接数是2的32次方（ip数）×2的16次方（port数）。</p>
<p>Linux上除了监听80以外，还可以监听其它的端口，例如Mysql的3306, Redis的6339，当然所有65535个端口你都可以用来监听一遍。这样理论上线就到了2的32次方（ip数）×2的16次方（port数）×2的16次方（服务器port数）个。</p>
<p>一条TCP连接如果不发送数据的话，消耗内存是3.3K左右。假设你只保持连接不发送数据，那么你服务器可以建立的连接最大数量 = 你的内存/3.3K。假如是4GB的内存，那么大约可接受的TCP连接数量是100万左右。</p>
<p>总结：</p>
<p>TCP连接的客户端机：每一个ip可建立的TCP连接理论受限于ip_local_port_range参数，也受限于65535。但可以通过配置多ip的方式来加大自己的建立连接的能力。</p>
<p>TCP连接的服务器机：每一个监听的端口虽然理论值很大，但这个数字没有实际意义。最大并发数取决你的内存大小，每一条静止状态的TCP连接大约需要吃3</p>
<p>.3K的内存。</p>
<h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式*"></a>TCP报文格式*</h3><p>固定首部长度为20字节,可变部分0~40字节</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps43.png" alt="img"> </p>
<p>\1. 源端口，16bits，范围0~65525。</p>
<p>\2. 目的端口，16bits，范围同上。</p>
<p>\3. sequence number： 数据序号，32bits，TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</p>
<p>\4. acknoledgement number： 确认号，32bits，期望收到对方的下一个报文段的数据的第一个字节的序号。</p>
<p>\5. 数据偏移，4bits，单位为4字节，它指出报文数据距TCP报头的起始处有多远(TCP报文头长度)。</p>
<p>\6. 保留字段 6bits，保留今后使用，目前置0处理。</p>
<p>\7. URG：紧急比特，1bit，当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</p>
<p>\8. ACK：确认比特，1bit，只有当 ACK=1时确认号字段才有效。当 ACK=0 时，确认号无效</p>
<p>\9. PSH：推送比特，1bit，接收方 TCP 收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付</p>
<p>\10. RST：复位比特，1bit，当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接</p>
<p>\11. SYN：同步比特，1bit，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文</p>
<p>\12. FIN：终止比特，1bit，用来释放一个连接。当FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</p>
<p>\13. 窗口大小，16bits，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</p>
<p>\14. 检验和，16bits，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p>
<p>\15. 紧急指针字段，16bits，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。</p>
<p>\16. 选项字段，长度可变，这部分最多包含40字节。TCP首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。，因为TCP头部最长是60字节</p>
<ol>
<li><p>选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。</p>
</li>
<li><p>第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。</p>
</li>
<li><p>第三个字段info（如果有的话）是选项的具体信息. kind=0是选项表结束选项kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍kind=2是最大报文段长度选项</p>
</li>
</ol>
<p>TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。</p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps39.jpg" alt="img"> </p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) ：建立连接</p>
<p>ACK：表示响应，告诉对方你发的信息我收到了</p>
<ol>
<li><p>主机A：发送syn=1，随机产生seq number=x的数据包 -&gt; 主机B，收到syn=1，知道A要建立连接（B确认了自己接收正常，对方发送正常）</p>
</li>
<li><p>主机B：确认连接信息，向A发送ack=1，ack number=x+1，syn=1，随机产生seq=y的数据包 -&gt; 主机A（A确认了自己发送、接收正常，对方发送、接收正常）</p>
</li>
<li><p>主机A：检查ack number是否正确，发送ack number=y+1，ack=1 -&gt; 主机B（B确认了自己发送正常，对方接收正常）</p>
</li>
</ol>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手*"></a>为什么要三次握手*</h3><p>三次握手的目的是建立可靠的通信信道，即双方确认自己与对方的发送与接收是正常的。</p>
<p>A和B进行三次握手：A先向B发送</p>
<ol>
<li><p>B确认了对方发送正常，自己接收正常</p>
</li>
<li><p>A确认了自己发送、接收正常，对方发送、接收正常</p>
</li>
<li><p>B确认了：自己发送正常，对方接收正常</p>
</li>
</ol>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p>“三次握手”的目的：“为了防止****已失效的连接请求报文段****突然又传送到了服务端，因而产生错误”</p>
<p>为了解决“网络中存在延迟的重复分组”的问题</p>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<p><em><strong>*为什么是三次，不是四次？*</strong></em></p>
<p>这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的.</p>
<h3 id="第2次握手传回了ACK，为什么还要传回SYN"><a href="#第2次握手传回了ACK，为什么还要传回SYN" class="headerlink" title="第2次握手传回了ACK，为什么还要传回SYN"></a>第2次握手传回了ACK，为什么还要传回SYN</h3><p>SYN 同步序列编号(Synchronize Sequence Numbers) ：建立连接</p>
<p>ACK：表示响应，告诉对方你发的信息我收到了</p>
<p>B给A所发送的ACK是为了告诉A，我接收到的信息确实就是你所发送的信号了，这表明从A到B的通信是正常的。而回传SYN则是为了建立从B到A的通信。</p>
<h3 id="如果第一次、第二次失败"><a href="#如果第一次、第二次失败" class="headerlink" title="如果第一次、第二次失败*"></a>如果第一次、第二次失败*</h3><p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps40.jpg" alt="img"> </p>
<p>第一次失败（client向server发送SYN失败）：</p>
<p>两端都不会申请资源。如果一段时间后之前的SYN发送成功了，这时客户端只会接收他最后发送的SYN的SYN+ACK回应，其他的一概忽略，服务端也是如此，会将之前多申请的资源释放了。</p>
<p>第二次握手失败（server向client发送SYN+ACK失败）：</p>
<p>client由于没有收到这条响应，不会申请资源，虽然服务端申请了资源，但是迟迟收不到来自客户端的ACK，也会将该资源释放。</p>
<p>第三次握手失败（client向server发送ACK失败）：</p>
<p>server迟迟没有收到ACK，就会释放资源</p>
<p>但client认为自己已经连接好了，就会给server发送数据</p>
<p>server由于没有收到第三次握手，就会以RST包对客户端响应，重新建立链接</p>
<p>另外，server会因为没有收到客户端的ACK多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到客户端的ACK，则释放资源。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps41.jpg" alt="img"> </p>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>A 主动关闭         B被动关闭</p>
<ol>
<li><p>主机A：发送fin=1, seq=x 报文，用来关闭A到B的数据传送 -&gt; 主机B</p>
</li>
<li><p>主机B：发送 ack=1, seq=x+1 报文，确认收到关闭连接的信息 -&gt; 主机A</p>
</li>
<li><p>主机B：发送 fin=1, seq=y 报文，用来关闭B到A的数据传送 -&gt; 主机A</p>
</li>
<li><p>主机A：发送 ack=1, seq=y+1 报文，确认收到关闭连接的信息 -&gt; 主机B</p>
</li>
</ol>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps42.png" alt="img"> </p>
<h3 id="为什么三次握手，而关闭却是四次"><a href="#为什么三次握手，而关闭却是四次" class="headerlink" title="为什么三次握手，而关闭却是四次*"></a>为什么三次握手，而关闭却是四次*</h3><p>这是因为服务端收到SYN报文的连接请求后，它可以把ACK和SYN放在一个报文里来发送。</p>
<p>关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭。可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了。</p>
<p>所以关闭时ACK报文和FIN报文多数情况下都是分开发送的。</p>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT*"></a>TIME_WAIT*</h3><p>A主动关闭连接结束后，收到来自B的FIN，在A发送最后一个ack后，A会进入TIME_WAIT状态，再停留2个MSL时间，进入CLOSED状态。</p>
<p>用途：</p>
<p>\1. 可靠地实现TCP全双工连接的终止。避免对方收不到自己的ACK，等对方重发FIN。</p>
<p>\2. 保证旧连接的重复分组在网络中消逝。避免服务器重启（或者其他服务器绑定同样端口）接收到了上一次的数据。（TCP分组可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分组在路由器修复后也会被送到最终目的地，这个迟到的迷途分组到达时可能会引起问题。）</p>
<h3 id="TIME-WAIT状态后为什么需要等2MSL"><a href="#TIME-WAIT状态后为什么需要等2MSL" class="headerlink" title="TIME_WAIT状态后为什么需要等2MSL*"></a>TIME_WAIT状态后为什么需要等2MSL*</h3><p>****MSL****：maximum segment lifetime(最大报文生存时间），指报文能在互联网上生存的最长时间，超过这个时间报文将在网络中消失 。MSL在RFC 1122上建议是2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p>
<p>MSL多长？一般是60s.</p>
<p>cat /proc/sys/net/ipv4/tcp_fin_timeout</p>
<p>等待2MSL时间主要目的是怕四次握手的最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p>
<h3 id="TIME-WAIT状态过多原因与解决"><a href="#TIME-WAIT状态过多原因与解决" class="headerlink" title="TIME_WAIT状态过多原因与解决*"></a>TIME_WAIT状态过多原因与解决*</h3><p>查看当前系统下所有连接状态的数：</p>
<p>[root@vps ~]#netstat -n|awk ‘/^tcp/{++S[$NF]}END{for (key in S) print key,S[key]}’</p>
<p>TIME_WAIT 286</p>
<p>FIN_WAIT1 5</p>
<p>FIN_WAIT2 6</p>
<p>ESTABLISHED 269</p>
<p>SYN_RECV 5</p>
<p>CLOSING 1</p>
<p>原因：短时间内（比如1s）进行大量的短连接，可能出现time wait状态过多。</p>
<p>一般情况下，持续2MSL，不会有太大影响；但如果短时间内过多，会创建大量fd，导致fd被用尽，系统无法再发起新连接。</p>
<p>解决办法：<em><strong>*修改TIME_*</strong>***</em>*WAIT****<em><strong>*时间的Linux内核参数**</strong></em></p>
<p>在****/etc/sysctl.conf****文件中，加入：</p>
<p>net.ipv4.tcp_tw_reuse = 1（默认为0，表示关闭）</p>
<p># 表示开启重用。允许将TIME-WAIT的socket重新用于新的TCP连接</p>
<p>由于两端都使用了时间戳，所以能够避免序列号重复。</p>
<p>net.ipv4.tcp_tw_recycle = 1（默认为0，表示关闭）</p>
<p>#表示开启TCP连接中TIME-WAIT sockets的快速回收</p>
<p><em><strong>*内核如何回收socket**</strong></em></p>
<p>TCP有一种行为，可以缓存每个连接最新的时间戳，后续请求中如果时间戳小于缓存的时间戳，即视为无效，相应的数据包会被丢弃。</p>
<p>Linux是否启用这种行为取决于tcp_timestamps和tcp_tw_recycle，其中tcp_timestamps缺省就是开启的，所以当tcp_tw_recycle被开启后，实际上这种行为就被激活了。</p>
<p>在NAT系统中会共享套接字和时间戳，因此会出现时间戳错乱的情况，后面的数据包就被丢弃了，具体的表现通常是客户端明明发送的SYN，但服务端就是不响应ACK。</p>
<p>net.ipv4.tcp_max_tw_buckets = 5000    </p>
<p>#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。</p>
<p>建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置。</p>
<p>修改 linux kernel 的 tcp time wait的时间。</p>
<p>在 $KERNEL/include/net/tcp.h里面，有下面的行：</p>
<p>#define <em><strong>*TCP_TIMEWAIT_LEN*</strong></em> (60*HZ)</p>
<p>而这个宏是真正控制 TCP TIME_WAIT 状态的超时时间的。根据我们的测试，设置为 10 秒比较合适，即：  　　</p>
<p>#define TCP_TIMEWAIT_LEN (10*HZ)</p>
<p>然后重新编译内核，重启系统即可发现短连接造成的TIME_WAIT状态大大减少。一般情况都可以至少减少2/3。也能相应提高系统应对短连接的速度。</p>
<p>net.ipv4.tcp_fin_timeout = 5    </p>
<p># 修改系统默认的 TIMEOUT 时间（输出用，不用真正起作用）</p>
<p>net.ipv4.tcp_syncookies = 1    （默认为0，表示关闭）</p>
<p>#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击</p>
<p>最后输入下面的命令，让内核参数生效：sudo sysctl -p</p>
<p>net.ipv4.tcp_keepalive_time = 1200 （缺省是2小时，改为20分钟）</p>
<p>#表示当keepalive启用的时候，TCP发送keepalive消息的频度</p>
<p>net.ipv4.ip_local_port_range = 10000 65000    </p>
<p>#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。</p>
<p>net.ipv4.tcp_max_syn_backlog = 8192    </p>
<p>#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数</p>
<h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT*"></a>CLOSE_WAIT*</h3><p>CLOSE_WAIT，借用某位大牛的话来说应该倒过来叫做 WAIT_CLOSE，也就是说「等待关闭」</p>
<p>A发出 FIN 包，B响应 ACK 包，此时，B就进入了 CLOSE_WAIT 状态。如果一切正常，稍后B会发出 FIN 包，然后进入 LAST_ACK 状态。</p>
<p>如果出现大量的 CLOSE_WAIT 状态，那么就意味着B没有及时发出 FIN 包，一般有如下几种可能：</p>
<ol>
<li><p>程序问题：代码层面忘记关闭相应的 socket 连接导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到</p>
</li>
<li><p>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。</p>
</li>
<li><p>BACKLOG 太大：此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在队列里就被对方关闭了。</p>
</li>
</ol>
<p>服务器中存在大量close wait的危害：</p>
<p>大量close wait会占用服务器的fd，而一个机器能打开的fd数量是有限的，超过后就无法分配fd，无法建立新连接。</p>
<h3 id="CLOSE-WAIT-TIME-WAIT哪个危害大"><a href="#CLOSE-WAIT-TIME-WAIT哪个危害大" class="headerlink" title="CLOSE_WAIT TIME_WAIT哪个危害大*"></a>CLOSE_WAIT TIME_WAIT哪个危害大*</h3><p>通常情况下，time wait对服务器影响有限，而大量的close wait风险较高，一般正确编码可以避免。</p>
<h2 id="TCP粘包拆包"><a href="#TCP粘包拆包" class="headerlink" title="TCP粘包拆包"></a>TCP粘包拆包</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p>
<p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为一个进行发送，这就形成了粘包问题。</p>
<p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p>
<h3 id="具体出现场景"><a href="#具体出现场景" class="headerlink" title="具体出现场景"></a>具体出现场景</h3><p>假设client向服sever连续发送了两个数据包，packet1和packet2，server收到的数据可分为三种：</p>
<ol>
<li><p>正常收到两个数据包，没有发生拆包和粘包</p>
</li>
<li><p>只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包</p>
</li>
</ol>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps44.jpg" alt="img"> </p>
<ol start="3">
<li>接收端收到了两个数据包，但是这两个数据包是不完整的、或者是多出来一块，这种情况即发生了拆包和粘包（Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理）</li>
</ol>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/wps45.jpg" alt="img"> </p>
<h3 id="为什么TCP有拆包粘包-UDP没有"><a href="#为什么TCP有拆包粘包-UDP没有" class="headerlink" title="为什么TCP有拆包粘包  UDP没有"></a>为什么TCP有拆包粘包  UDP没有</h3><p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生，日常的网络应用开发大都在传输层进行。</p>
<p>UDP有消息保护边界，不会发生粘包拆包问题。</p>
<p>因此粘包拆包问题只发生在TCP中。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组。</p>
<p>常用方案：</p>
<ol>
<li><p>消息定长，比如每个报文的大小为固定长度200字节，如果不够，空位补空格</p>
</li>
<li><p>在包尾增加回车换行符进行分割，例如FTP协议</p>
</li>
<li><p>将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，只有读取到足够长度的消息之后才算是读到了一个完整的消息</p>
</li>
<li><p>通过自定义协议进行粘包和拆包的处理。</p>
</li>
</ol>
<h3 id="TCP粘包拆包-发生的原因"><a href="#TCP粘包拆包-发生的原因" class="headerlink" title="TCP粘包拆包 发生的原因"></a>TCP粘包拆包 发生的原因</h3><ol>
<li><p>应用程序写入的数据大于套接字的缓冲区大小，发生拆包</p>
</li>
<li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，发生粘包</p>
</li>
<li><p>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</p>
</li>
<li><p>接收方法不及时读取套接字缓冲区数据，这将发生粘包</p>
</li>
</ol>
<p>摘自：</p>
<p><a href="https://www.cnblogs.com/azraelly/archive/2012/12/25/2832393.html">https://www.cnblogs.com/azraelly/archive/2012/12/25/2832393.html</a></p>
<p><a href="https://www.jianshu.com/p/e4cd3de320f7">https://www.jianshu.com/p/e4cd3de320f7</a></p>
<p><a href="https://blog.huoding.com/2016/01/19/488">https://blog.huoding.com/2016/01/19/488</a></p>
<p><a href="https://www.zhihu.com/question/298214130">https://www.zhihu.com/question/298214130</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>Websocket</title>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Websocket/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>WebSocket 是一种网络通信协议，应用层协议。</p>
<p>已经有了 HTTP 协议，为什么还需要另一个协议：因为 HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p>
<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p>
<p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>特点：</p>
<ol>
<li><p>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</p>
</li>
<li><p>建立在 TCP 协议之上，服务器端的实现比较容易</p>
</li>
<li><p>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</p>
</li>
<li><p>数据格式比较轻量，性能开销小，通信高效</p>
</li>
<li><p>可以发送文本，也可以发送二进制数据</p>
</li>
<li><p>没有同源限制，客户端可以与任意服务器通信</p>
</li>
<li><p>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。比如ws://example.com:80/some/path</p>
</li>
</ol>
<p>WebSocket依赖于HTTP连接，那么它如何从连接的HTTP协议转化为WebSocket协议？</p>
<p>每个WebSocket连接都始于一个HTTP请求。具体来说，WebSocket协议在第一次握手连接时，通过HTTP协议在传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端：</p>
<p>GET /chat HTTP/1.1</p>
<p>Host: server.example.com</p>
<p>Upgrade: websocket</p>
<p>Connection: Upgrade</p>
<p>Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==</p>
<p>Origin: <a href="http://example.com/">http://example.com</a></p>
<p>Sec-WebSocket-Version: 13</p>
<p>Upgrade首部，用来把当前的HTTP请求升级到WebSocket协议。</p>
<p>WebSocket为什么要依赖于HTTP协议的连接？</p>
<ol>
<li><p>WebSocket设计上就是天生为HTTP增强通信（全双工通信等），所以在HTTP协议连接的基础上是很自然的一件事，并因此而能获得HTTP的诸多便利</p>
</li>
<li><p>兼容支持，比如即使服务器不支持WebSocket也能建立HTTP通信，只不过返回的是onerror而已，这显然比服务器无响应要好的多。</p>
</li>
</ol>
<h3 id="HTTP-长连接-WebSocket-长连接"><a href="#HTTP-长连接-WebSocket-长连接" class="headerlink" title="HTTP 长连接  WebSocket 长连接*"></a>HTTP 长连接  WebSocket 长连接*</h3><p>在http1.1中，Connection默认为Keep-alive参数，可以用这个来作为长连接。</p>
<p>缺点：没法做到服务端主动发送通知给客户端的。</p>
<p>在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。WebSocket是一种双向通信协议。</p>
<p>摘自：</p>
<p><a href="https://www.jianshu.com/p/86a550a521c5">https://www.jianshu.com/p/86a550a521c5</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTPS</title>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/</url>
    <content><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>[TOC]</p>
<h3 id="1-HTTPS是什么"><a href="#1-HTTPS是什么" class="headerlink" title="1. HTTPS是什么"></a>1. HTTPS是什么</h3><p>定义：HTTPS（全称： Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。HTTPS由两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体来说，HTTPS是HTTP报文直接将报文信息传输给SSL套接字进行加密，SSL加密后将加密后的报文发送给TCP套接字，然后TCP套接字再将加密后的报文发送给目的主机，目的主机将通过TCP套接字获取加密后的报文给SSL套接字，SSL解密后交给对应进程。</p>
<p>HTTP： 直接通过明文在浏览器和服务器之间传递信息。</p>
<p>HTTPS： 采用 对称加密算法加密数据+非对称加密算法交换密钥+数字证书验证身份 结合的方式来保护浏览器和服务端之间的通信安全。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/wps37.jpg" alt="img"> </p>
<h3 id="2-HTTPS-请求-加密过程"><a href="#2-HTTPS-请求-加密过程" class="headerlink" title="2. HTTPS 请求/加密过程"></a>2. HTTPS 请求/加密过程</h3><p><em><strong>*HTTPS是对称加密还是非对称加密**</strong></em></p>
<p>随机值：非对称加密</p>
<p>数据传输：对称加密</p>
<p>\1. client用户在浏览器里输入一个HTTPS网址，然后连接到服务端的443端口。以明文传输请求信息，包含版本信息，加密-套件候选列表，压缩算法候选列表，随机数，扩展字段等信息</p>
<p>\2. 服务端配置。采用HTTPS协议的服务器必须要有一套数字证书，这个证书中包含私钥和公钥。可以自己制作和向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。</p>
<p>\3. server返回证书，以及包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S</p>
<p>\4. client验证证书的合法性，包括可信性，是否吊销，过期时间和域名(这部分工作是由客户端的SSL/TLS来完成的)。首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题<em><strong>*（*</strong>***</em>*如何验证合法性*********）****。</p>
<p>\5. 如果证书没有问题，client就生成一个随机值。然后用证书的公钥对这个随机值进行加密，发送给server</p>
<p>\6. server用证书的私钥解密，得到这个随机值。将这个随机值作为对称加密的密匙，对要传输的数据进行加密，并传输给client。</p>
<p>\7. client使用随机值解密信息，获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p>
<p><img src="file:///C:\Users\FYR\AppData\Local\Temp\ksohtml21792\wps38.jpg" alt="img"> </p>
<p>公钥和私钥：</p>
<p>公钥：锁；私钥：钥匙。</p>
<p>锁可以给别人，别人可以用这个锁把重要的东西锁起来，发给你。</p>
<p>钥匙只有一把，也就是只有你能看到被锁起来的数据。</p>
<h3 id="3-为什么不直接用非对称加密传输数据"><a href="#3-为什么不直接用非对称加密传输数据" class="headerlink" title="3. 为什么不直接用非对称加密传输数据*"></a>3. 为什么不直接用非对称加密传输数据*</h3><p>\1. 只有server有私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密</p>
<p>\2. 非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的</p>
<h3 id="4-对称加密-非对称加密"><a href="#4-对称加密-非对称加密" class="headerlink" title="4. 对称加密  非对称加密"></a>4. 对称加密  非对称加密</h3><p>对称加密：采用的是使用相同密钥对报文进行加密解密</p>
<p>encrypt(明文，秘钥) = 密文</p>
<p>decrypt(密文，秘钥) = 明文</p>
<p>典型的对称加密算法有DES、AES等；</p>
<p>非对称加密：加密和解密是需要不同的秘钥的。</p>
<p>encrypt(明文，公钥) = 密文</p>
<p>decrypt(密文，私钥) = 明文</p>
<p>典型的非对称加密算法有RSA、DSA等。</p>
<h3 id="5-为什么非对称加密慢"><a href="#5-为什么非对称加密慢" class="headerlink" title="5. 为什么非对称加密慢"></a>5. 为什么非对称加密慢</h3><p>对称加密主要的运算是****位运算****，速度非常快，如果使用硬件计算，速度会更快。以 AES 算法为例，如下图所示，其运算本质上来说就是位移和替换。另外还有一个原因是，AES 中的许多中间计算过程是可以事先计算好的。加密数据时许多中间过程可以直接查表，而不需要实时地计算。</p>
<p>但是非对称加密计算****一般都比较复杂****，比如 RSA，它里面涉及到大数乘法、大数模等等运算。</p>
<h3 id="6-HTTPS用到了哪些加密技术"><a href="#6-HTTPS用到了哪些加密技术" class="headerlink" title="6. HTTPS用到了哪些加密技术*"></a>6. HTTPS用到了哪些加密技术*</h3><p><a href="https://www.cnblogs.com/xdyixia/p/9237742.html">https://www.cnblogs.com/xdyixia/p/9237742.html</a></p>
<p><a href="https://blog.csdn.net/WoTrusCA/article/details/100105031">https://blog.csdn.net/WoTrusCA/article/details/100105031</a></p>
<p>非对称加密技术：</p>
<h3 id="7-TLS-SSL-HTTP-HTTPS的关系"><a href="#7-TLS-SSL-HTTP-HTTPS的关系" class="headerlink" title="7.TLS/SSL, HTTP, HTTPS的关系"></a>7.TLS/SSL, HTTP, HTTPS的关系</h3><p>SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协 议，均用于在传输层为数据通讯提供安全支持。 </p>
<p>可以将HTTPS协议简单理解为HTTP协议＋TLS/SSL </p>
<p>引用</p>
<p><a href="https://www.jianshu.com/p/e30a8c4fa329">https://www.jianshu.com/p/e30a8c4fa329</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-HTTP是什么"><a href="#1-HTTP是什么" class="headerlink" title="1. HTTP是什么"></a>1. HTTP是什么</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
<h3 id="2-状态码"><a href="#2-状态码" class="headerlink" title="2. 状态码"></a>2. 状态码</h3><p><strong>1XX：Informational信息性状态码，接收的请求正在处理</strong></p>
<p><strong>2XX：Success成功状态码，请求正常处理完毕</strong></p>
<p>​    200：ok 请求成功</p>
<p>​    204：no content请求成功，但没有结果返回</p>
<p>​    206：partial content客户端请求一部分资源，服务端成功响应，返回一部分资源</p>
<p><strong>3XX：Redirection重定向状态码</strong></p>
<p>代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请    求地址（重定向目标）在本次响应的Location域中指明。</p>
<p>​    300 Multiple Choices</p>
<p>​    被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议    信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p>
<p>​    301：move permanently永久性重定向</p>
<p>​    被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。</p>
<p>​    302：found临时性重定向</p>
<p>​    要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。</p>
<p>​    注意：很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。[20]因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p>
<p>​    303：see other</p>
<p>​    对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</p>
<p>​    304：not modified </p>
<p>​    表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</p>
<p>​    307 temporary redirect </p>
<p>​    在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求。</p>
<p><strong>4XX：Client Error客户端错误状态码，服务器无法处理的请求</strong></p>
<p>​    400：bad request</p>
<p>​    由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗    性路由请求），服务器不能或不会处理该请求。</p>
<p>​    401：unauthorized</p>
<p>​    该状态码表示当前请求需要用户验证。</p>
<p>​    第一次请求后，响应包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户    信息。客户端第二次请求，重复提交一个包含恰当的Authorization头信息的请求，如果再次    返回401响应代表着服务器验证已经拒绝了那些证书，认证失败。</p>
<p>​    403：forbidden</p>
<p>​    服务器已经理解请求，但是拒绝执行它。</p>
<p>​    404：not found</p>
<p>​    服务器上无法找到请求的资源</p>
<p>​    405：method not allow请求所针对的资源不支持对应的请求方法</p>
<p><strong>5XX：Server Error服务器错误状态码，服务器处理请求出错</strong></p>
<p>​    500：internal server error服务端执行请求时发生了错误</p>
<p>​    502：bad Gateway网关错误</p>
<p>​    503：service unavailable服务器正在超负载或停机维护，无法处理请求</p>
<h3 id="3-HTTP-请求头字段"><a href="#3-HTTP-请求头字段" class="headerlink" title="3. HTTP 请求头字段"></a>3. HTTP 请求头字段</h3><ol>
<li><p>Accept : 浏览器可以接收的内容类型，例如 Accept: text/plain</p>
</li>
<li><p>Accept-Charset：浏览器能识别的字符集，例如 Accept-Charset: utf-8</p>
</li>
<li><p>Accept-Encoding：浏览器可以处理的编码方式，注意这里的编码方式有别于字符集，这里的编码方式通常指gzip,deflate等。例如 Accept-Encoding: gzip, deflate</p>
</li>
<li><p>Accept-Language：浏览器接收的语言，其实也就是用户在什么语言地区，例如简体中文的就是 Accept-Language: zh-CN</p>
</li>
<li><p>Accept-Datetime：设置接受的版本时间，例如Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</p>
</li>
<li><p>Via：用来记录一个请求经过了哪些代理或网关才被送到目标服务器上</p>
</li>
<li><p>Referer：指当前请求的URL是在什么地址引用的</p>
</li>
<li><p>User-Agent： 通常就是用户的浏览器相关信息。例如：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0</p>
</li>
<li><p>Cache-Control：这个指令在request和response中都有，用来指示缓存系统（服务器上的，或者浏览器上的）应该怎样处理缓存。eg：Cache-Control: no-cache</p>
</li>
<li><p>Connection：告诉服务器这个浏览器想要使用怎样的连接方式。值有keep-alive和close</p>
</li>
</ol>
<p>等等。</p>
<h3 id="4-HTTP-长连接-短连接"><a href="#4-HTTP-长连接-短连接" class="headerlink" title="4. HTTP  长连接 短连接*"></a>4. HTTP  长连接 短连接*</h3><p><em><strong>如何保证长连接</strong></em></p>
<p>短连接：客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。在HTTP/1.0中默认使用。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在请求头中设置：<em><strong>Connection:keep-alive</strong></em></p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>开启Keep-Alive的优缺点：</p>
<p>优点：Keep-Alive模式更加高效，因为避免了连接建立和释放的开销。</p>
<p>缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</p>
<h3 id="5-HTTP-无状态，如何保存用户状态"><a href="#5-HTTP-无状态，如何保存用户状态" class="headerlink" title="5. HTTP 无状态，如何保存用户状态"></a>5. HTTP 无状态，如何保存用户状态</h3><p>HTTP 是一种无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p>
<p>那么我们保存用户状态呢？Session 机制。</p>
<p>主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p>Cookie 被禁用怎么办?</p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<h3 id="6-HTTP-八种请求方式"><a href="#6-HTTP-八种请求方式" class="headerlink" title="6. HTTP 八种请求方式*"></a>6. HTTP 八种请求方式*</h3><p><em><strong>*get*</strong></em> 请求从服务器获取特定资源</p>
<p><em><strong>*post*</strong></em> 在服务器上创建一个新的资源</p>
<p>put 更新服务器上的资源（更新整个资源，比如编号12的学生信息）</p>
<p>delete 从服务器删除特定的资源</p>
<p>head 类似于get，只不过返回的响应中没有具体内容，用于获取报头</p>
<p>options 返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</p>
<p>connect 预留给能够将连接改为管道方式的代理服务器</p>
<p>trace 回显服务器收到的请求，主要用于测试或诊断</p>
<h3 id="7-HTTP-1-0-HTTP-1-1"><a href="#7-HTTP-1-0-HTTP-1-1" class="headerlink" title="7. HTTP 1.0 HTTP 1.1"></a>7. HTTP 1.0 HTTP 1.1</h3><p>主要区别主要体现在：</p>
<ol>
<li><p>长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求</p>
</li>
<li><p>错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除</p>
</li>
<li><p>缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略</p>
</li>
<li><p>带宽优化及网络连接的使用 :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。、</p>
</li>
</ol>
<h4 id="9-http-1-0、1-1、2-0"><a href="#9-http-1-0、1-1、2-0" class="headerlink" title="9. http***1.0、1.1、2.0***"></a>9. <em><strong>http</strong>***</em>1.0、1.1、2.0***</h4><p><em><strong>HTTP1.0版本的特性：</strong></em></p>
<p>①　早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。</p>
<p>②　HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p>
<p> <strong>HTTP1.1版本新特性</strong></p>
<p>①　默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</p>
<p>②　管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</p>
<p>③　断点续传原理</p>
<p><strong>HTTP2.0版本的特性</strong></p>
<p>①　二进制分帧（采用二进制格式的编码将其封装）</p>
<p>②　首部压缩（设置了专门的首部压缩设计的HPACK算法。）</p>
<p>③　流量控制（设置了接收某个数据流的多少字节一些流量控制）</p>
<p>④　多路复用（可以在共享TCP链接的基础上同时发送请求和响应）</p>
<p>⑤　请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）</p>
<p>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。</p>
<h3 id="10-HTTP断点重传"><a href="#10-HTTP断点重传" class="headerlink" title="10. HTTP断点重传"></a>10. HTTP断点重传</h3><p>定义：HTTP/FTP 服务器或下载软件具有断点续传能力，允许用户从上传/下载断线的地方继续传送。 </p>
<p>HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。它通过在 Header 里两个参数实现的，客户端发请求时对应的是 <em><strong>*Range*</strong></em> ，服务器端响应时对应的是 ****Content-Range****。</p>
<p>Range：用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：</p>
<p>Range:(unit=first byte pos)-[last byte pos]</p>
<p>Range 头部的格式有以下几种情况：</p>
<p>Range: bytes=0-499 表示第 0-499 字节范围的内容 </p>
<p>Range: bytes=500-999 表示第 500-999 字节范围的内容 </p>
<p>Range: bytes=-500 表示最后 500 字节的内容 </p>
<p>Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容 </p>
<p>Range: bytes=0-0,-1 表示第一个和最后一个字节 </p>
<p>Range: bytes=500-600,601-999 同时指定几个范围</p>
<p>Content-Range：用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。一般格式：</p>
<p>Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth]</p>
<p>例如：</p>
<p>Content-Range: bytes 0-499/22400</p>
<p>0－499 是指当前发送的数据的范围，而 22400 则是文件的总大小。</p>
<p>而在响应完成后，返回的响应头状态码也不同：</p>
<p>HTTP/1.1 <em><strong>*200*</strong></em> Ok（不使用断点续传方式） </p>
<p>HTTP/1.1 <em><strong>*206*</strong></em> Partial Content（使用断点续传方式）表示客户端请求一部分资源，服务端成功响应，返回一部分资源</p>
<p>增强校验</p>
<p>在实际场景中，会出现一种情况，即在终端发起续传请求时，URL 对应的文件内容在服务器端已经发生变化，此时续传的数据肯定是错误的。解决办法：</p>
<ol>
<li><p>Last-Modified 来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动。</p>
</li>
<li><p>使用 ETag 头来放置文件的唯一标识</p>
</li>
</ol>
<p>检测服务器是否支持断点续传</p>
<p>[root@localhost ~]# curl <em><strong>*-i –range 0-9*</strong></em> <a href="http://www.baidu.com/img/bdlogo.gif">http://www.baidu.com/img/bdlogo.gif</a></p>
<p>HTTP/1.1 206 Partial Content</p>
<p>Date: Mon, 21 Nov 2016 05:26:29 GMT</p>
<p>Server: Apache</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM “</p>
<p>Set-Cookie: BAIDUID=0CD0E23B4D4F739954DFEDB92BE6CE03:FG=1; expires=Tue, 21-Nov-17 05:26:29 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Last-Modified: Fri, 22 Feb 2013 03:45:02 GMT</p>
<p>ETag: “627-4d648041f6b80”</p>
<p>Accept-Ranges: bytes</p>
<p>Content-Length: 10</p>
<p>Cache-Control: max-age=315360000</p>
<p>Expires: Thu, 19 Nov 2026 05:26:29 GMT</p>
<p>Content-Range: bytes 0-9/1575</p>
<p>Connection: Keep-Alive</p>
<p>Content-Type: image/gif</p>
<p>能够找到 Content-Range，则表明服务器支持断点续传。有些服务器还会返回 Accept-Ranges，输出结果 Accept-Ranges: bytes ，说明服务器支持按字节下载。</p>
<p><em><strong>*Last-Modified*</strong></em>    服务器发给客户</p>
<p>If-Modified-Since    客户发给服务器</p>
<p>都是用于记录页面最后修改时间的 HTTP 头信息。再次请求本地存在的 cache 页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的 Last-Modified 最后修改时间戳发送回去，这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担。</p>
<p>（304：not modified 服务端已经执行了GET，但文件未变化）</p>
<p><em><strong>*Etag*</strong></em></p>
<p>为了解决 Last-Modified 无法解决的一些问题。</p>
<p>一些文件也许会周期性的更改，但是内容并不改变（仅改变修改时间），这时候我们并不希望客户端认为这个文件被修改了，而重新 GET。</p>
<p>某些文件修改非常频繁，例如：在秒以下的时间内进行修改（1s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）。</p>
<p>某些服务器不能精确的得到文件的最后修改时间。</p>
<p>为此，HTTP/1.1 引入了 Etag。Etag 仅仅是一个和文件相关的标记，可以是一个版本标记，例如：v1.0.0；或者说 “627-4d648041f6b80” 这么一串看起来很神秘的编码。但是 HTTP/1.1 标准并没有规定 Etag 的内容是什么或者说要怎么实现，唯一规定的是 Etag 需要放在 “” 内。</p>
<p>If-Range</p>
<p>用于判断实体是否发生改变，如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。一般格式：If-Range: Etag | HTTP-Date</p>
<p>也就是说，If-Range 可以使用 Etag 或者 Last-Modified 返回的值。当没有 ETage 却有 Last-modified 时，可以把 Last-modified 作为 If-Range 字段的值。</p>
<p>例如：</p>
<p>If-Range: “627-4d648041f6b80” </p>
<p>If-Range: Fri, 22 Feb 2013 03:45:02 GMT</p>
<p>If-Range 必须与 Range 配套使用。如果请求报文中没有 Range，那么 If-Range 就会被忽略。如果服务器不支持 If-Range，那么 Range 也会被忽略。</p>
<p>如果请求报文中的 Etag 与服务器目标内容的 Etag 相等，即没有发生变化，那么应答报文的状态码为 206。如果服务器目标内容发生了变化，那么应答报文的状态码为 200。</p>
<p>用于校验的其他 HTTP 头信息：If-Match/If-None-Match、If-Modified-Since/If-Unmodified-Since。</p>
<h3 id="11-HTTP-HTTPS"><a href="#11-HTTP-HTTPS" class="headerlink" title="11. HTTP  HTTPS*"></a>11. HTTP  HTTPS*</h3><p>区别：</p>
<ol>
<li><p>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>
</li>
<li><p>安全性： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在****SSL/TLS****之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以，HTTP 安全性没有 HTTPS高。</p>
</li>
<li><p>资源消耗：HTTPS 比HTTP耗费更多服务器资源</p>
</li>
<li></li>
</ol>
<h3 id="12-HTTP-Request-Response格式"><a href="#12-HTTP-Request-Response格式" class="headerlink" title="12. HTTP Request Response格式*"></a>12. HTTP Request Response格式*</h3><p>HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息︰ </p>
<p>请求（requests）–由客户端发送用来触发一个服务器上的动作</p>
<p>​    起始行</p>
<p>​    Headers</p>
<p>​    Body</p>
<p>响应（responses）–来自服务器的应答。</p>
<p>​    状态行</p>
<p>​    Headers</p>
<p>​    Body</p>
<p><em><strong>*Request*</strong>***</em>*- 起始行****</p>
<p>包含三个元素：</p>
<p>\1. HTTP 方法，GET, PUT 或者 POST等</p>
<p>\2. 请求目标 ，通常是一个 URL，或者是协议、端口和域名的绝对路径，通常以请求的环境为特征。</p>
<p>\3. HTTP 版本 </p>
<p><em><strong>*Request*</strong>***</em>*- Headers****</p>
<p>整个 header（包括值）由一行组成，这一行可以相当长。</p>
<p>有许多请求头可用，它们可以分为几组：</p>
<p>\1. General headers，例如 Via，适用于整个报文。</p>
<p>\2. Request headers，例如 User-Agent，Accept-Type，通过进一步的定义(例如 Accept-Language)，或者给定上下文(例如 Referer)，或者进行有条件的限制 (例如 If-None) 来修改请求。</p>
<p>\3. Entity headers，例如 Content-Length，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/wps35-1631252167679.jpg" alt="img"> </p>
<p><em><strong>*Request*</strong>***</em>*- Body****</p>
<p>请求的最后一部分是它的 body。不是所有的请求都有一个 body：例如获取资源的请求，GET，HEAD，DELETE 和 OPTIONS，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 POST 请求（包含 HTML 表单数据）。</p>
<p>Body 大致可分为两类：</p>
<p>\1. Single-resource bodies，由一个单文件组成。该类型 body 由两个 header 定义： Content-Type 和 Content-Length.</p>
<p>\2. Multiple-resource bodies，由多部分 body 组成，每一部分包含不同的信息位。通常是和  HTML Forms 连系在一起。</p>
<p><em><strong>*Response*</strong>***</em>*-状态行****</p>
<p>HTTP 响应的起始行被称作 状态行 (status line)，包含以下信息：</p>
<p>\1. 协议版本，通常为 HTTP/1.1</p>
<p>\2. 状态码 (status code)，表明请求是成功或失败。常见的状态码是 200，404，或 302。</p>
<p>\3. 状态文本 (status text)。一个简短的，纯粹的信息，通过状态码的文本描述，帮助人们理解该 HTTP 消息。</p>
<p>一个典型的状态行看起来像这样：HTTP/1.1 404 Not Found。</p>
<p><em><strong>*Response*</strong>***</em>*-Headers****</p>
<p>有许多响应头可用，这些响应头可以分为几组：</p>
<p>\1. General headers，例如 Via，适用于整个报文</p>
<p>\2. Response headers，例如 Vary 和 Accept-Ranges，提供其它不符合状态行的关于服务器的信息</p>
<p>\3. Entity headers，例如 Content-Length，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/wps36-1631252167678.jpg" alt="img"> </p>
<p><em><strong>*Response*</strong>***</em>*-Body****</p>
<p>响应的最后一部分是 body。不是所有的响应都有 body：具有状态码 (如 201 或 204) 的响应，通常不会有 body。</p>
<p>Body 大致可分为三类：</p>
<ol>
<li><p>Single-resource bodies，由已知长度的单个文件组成。该类型 body 由两个 header 定义：Content-Type 和 Content-Length。</p>
</li>
<li><p>Single-resource bodies，由未知长度的单个文件组成，通过将 Transfer-Encoding 设置为 chunked 来使用 chunks 编码</p>
</li>
<li><p>Multiple-resource bodies，由多部分 body 组成，每部分包含不同的信息段。但这是比较少见的。</p>
</li>
</ol>
<p>引用：</p>
<p><a href="https://www.cnblogs.com/findumars/p/5745345.html">https://www.cnblogs.com/findumars/p/5745345.html</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>DNS</title>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-DNS"><a href="#1-DNS" class="headerlink" title="1. DNS"></a>1. <strong>DNS</strong></h2><p>域名系统(Domain Name System：将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>DNS域名解析过程：</p>
<p>在主机中输入<a href="http://www.bytedancom/">www.bytedancom</a></p>
<ol>
<li><p>浏览器缓存中查询</p>
</li>
<li><p>系统缓存中查询，本地的hosts文件</p>
</li>
<li><p>路由器缓存</p>
</li>
<li><p>主机开始****递归查询****本地域名服务器。</p>
<ol>
<li><p>先查本地域名服务器的缓存。如果没有，继续下一步</p>
</li>
<li><p>本地域名服务器代替主机，以DNS client的身份，进行下一步查询，这个查询过程称为<em><strong>*迭代查询*</strong></em></p>
</li>
</ol>
<p>​    ① 请求根域名服务器，返回com服务器地址</p>
<p>​    ② 请求com服务器，返回bytedance.com服务器地址</p>
<p>​    ③ 请求bytedance.com服务器，返回<a href="http://www.bytedance.com/">www.bytedance.com</a>服务器地址</p>
<ol start="3">
<li>把这个地址返回给主机</li>
</ol>
</li>
</ol>
<p>本地DNS服务器一般是网络服务商提供的DNS，也可以自己修改为常用的公共DNS。</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps31.jpg" alt="img"> </p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps32.jpg" alt="img"> </p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps33.jpg" alt="img"> </p>
<h2 id="2-域名解析记录"><a href="#2-域名解析记录" class="headerlink" title="2. 域名解析记录"></a>2. <em><strong>域名解析记录</strong></em></h2><p>域名注册完成后首先需要做域名解析，即把域名指向网站所在服务器的IP。</p>
<p>域名解析时会添加解析记录，这些记录有：A记录、AAAA记录、CNAME记录、MX记录、NS记录、TXT记录、SRV记录、URL转发。</p>
<p><em><strong>*A记录*</strong>***</em>******： 将域名指向一个IPv4地址</p>
<p>****CNAME记录****： 将域名指向另一个域名，实现与被指向域名相同的访问效果</p>
<p>****NS记录****：将子域名指定某个域名服务器来解析</p>
<p>****SOA记录****：起始授权机构记录，用于在众多NS记录中标记哪一台是主服务器</p>
<p>****AAAA记录****： 将域名指向一个IPv6地址</p>
<p>****MX记录****： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录</p>
<p>****TXT记录****： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录</p>
<p>****SRV记录****：记录哪台计算机提供哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）</p>
<p>****PTR记录****： A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名</p>
<p><em><strong>*显性*</strong>***</em>*URL转发记录****： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址。例如：将<a href="http://www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。">www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。</a></p>
<p><em><strong>*隐性*</strong>***</em>*UR转发记录L****： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将<a href="http://www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn。">www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn。</a></p>
<h2 id="3-我的域名如何实现"><a href="#3-我的域名如何实现" class="headerlink" title="3. 我的域名如何实现"></a>3. <em><strong>我的域名如何实现</strong></em></h2><p>购买域名<a href="https://www.namesilo.com/">https://www.namesilo.com/</a></p>
<p>配置自己域名的CNAME Record：</p>
<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS/wps34.jpg" alt="img"> </p>
<p>设置github自定义域名：</p>
<p>本地博客public目录下新建CNAME文件(无后缀名,纯文件),在其中填入新的域名</p>
<p>juliajiang.top</p>
<h2 id="4-在浏览器中输入-url地址直到显示页面的过程"><a href="#4-在浏览器中输入-url地址直到显示页面的过程" class="headerlink" title="4. 在浏览器中输入***url地址直到显示页面的过程*******"></a>4. <em><strong>在浏览器中输入</strong>***</em>url地址<strong><strong><strong>直到</strong></strong></strong>显示<strong><strong><strong>页面</strong></strong></strong>的过程*******</h2><ol>
<li><p>浏览器输入url后，DNS解析</p>
<p>① DNS，查找过程：浏览器缓存、路由器缓存、DNS缓存</p>
</li>
<li><p>建立TCP连接</p>
<p>① TCP：与服务器建立TCP连接（传输层）</p>
<p>② IP：建立TCP连接时，需要发送数据，发送数据在网络层使用IP协议（网络层）</p>
<p>③ OSPF：open shortest path first开放最短路径优先，IP数据包在路由器之间进行选择时使用（网络层）</p>
<p>④ ARP：路由器在与服务器通信时，将IP地址转为MAC地址（数据链路层）</p>
</li>
<li><p>浏览器向web服务器发送http请求</p>
<p>① HTTP：使用http协议访问网页（应用层）</p>
</li>
<li><p>服务器处理请求，并返回http报文</p>
</li>
<li><p>浏览器解析渲染页面</p>
</li>
<li><p>连接结束</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机体系结构</title>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><img src="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/wps30.jpg" alt="img"> </p>
<h3 id="1-对比"><a href="#1-对比" class="headerlink" title="1. 对比"></a>1. <em><strong>对比</strong></em></h3><p>OSI模型：是一个完整的、完善的宏观理论模型</p>
<p>TCP/IP：更加侧重的是围绕TCP/IP协议展开的一系列通信协议的分层</p>
<h3 id="2-OSI每一层的作用"><a href="#2-OSI每一层的作用" class="headerlink" title="2. OSI每一层的作用"></a>2. <em><strong>OSI每一层的作用</strong></em></h3><table>
<thead>
<tr>
<th><em><strong>*OSI七层模型*</strong></em></th>
<th><em><strong>*功能*</strong></em></th>
<th><em><strong>*对应的网络协议*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*应用层*</strong></em></td>
<td>应用层是网络体系中最高的一层，也是唯一面向用户的一层，也可视为****为用户提供常用的应用程序****，每个网络应用都对应着不同的协议</td>
<td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>
</tr>
<tr>
<td><em><strong>*表示层*</strong></em></td>
<td>主要负责****数据格式的转换****，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密，同时也对应用层的协议进行翻译</td>
<td>Telnet, Rlogin, SNMP, Gopher</td>
</tr>
<tr>
<td><em><strong>*会话层*</strong></em></td>
<td>负责网络中两节点的建立，在数据传输中****维护计算机网络中两台计算机之间的通信连接****，并决定何时终止通信</td>
<td>SMTP, DNS</td>
</tr>
<tr>
<td><em><strong>*传输层*</strong></em></td>
<td>是整个网络关键的部分，是实现****两个用户进程间端到端的可靠通信，****处理数据包的错误等传输问题。是向下通信服务最高层，向上用户功能最底层。即向网络层提供服务，向会话层提供独立于网络层的传送服务和可靠的透明数据传输。</td>
<td>TCP, UDP</td>
</tr>
<tr>
<td><em><strong>*网络层*</strong></em></td>
<td>进行逻辑地址寻址，实现不同****网络之间的路径选择****，IP就在网络层</td>
<td>IP, ICMP, ARP, RARP, AKP, UUCP</td>
</tr>
<tr>
<td><em><strong>*数据链路层*</strong></em></td>
<td>物理地址（MAC地址），网络设备的唯一身份标识。****建立逻辑连接、进行硬件地址寻址****，相邻的两个设备间的互相通信</td>
<td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继</td>
</tr>
<tr>
<td><em><strong>*物理层*</strong></em></td>
<td>七层模型中的最底层，主要是****物理介质传输媒介*<em><strong>（网线或者是无线），</strong></em>*在不同设备中传输比特****，将0/1信号与电信号或者光信号互相转化</td>
<td>IEEE 802.1A, IEEE 802.2到IEEE 802</td>
</tr>
</tbody></table>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="3-五层-每一层作用"><a href="#3-五层-每一层作用" class="headerlink" title="3. 五层 每一层作用"></a>3. <em><strong>五层</strong></em> <em><strong>每一层作用</strong></em></h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><em><strong>应用层</strong></em></h4><ol>
<li><p>任务：应用进程间的通信和交互。</p>
</li>
<li><p>应用层协议：域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP</p>
</li>
<li><p>交互的数据单元称为报文</p>
</li>
</ol>
<h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a><em><strong>运输层</strong></em></h4><ol>
<li><p>任务：负责向两台主机进程之间的通信提供的数据传输服务。应用进程利用该服务传送应用层报文。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
</li>
<li><p>两种协议</p>
<ol>
<li><p>传输控制协议 TCP（Transmission Control Protocol），提供面向连接的，可靠的数据传输服务</p>
</li>
<li><p>用户数据协议 UDP（User Datagram Protocol），提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</p>
</li>
</ol>
</li>
</ol>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><em><strong>网络层</strong></em></h4><ol>
<li><p>任务：选择合适的网间路由和交换结点，确保数据及时传送。</p>
</li>
<li><p>数据单元：IP数据报。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。</p>
</li>
<li><p>协议：无连接的网际协议IP（Internet Protocol）和许多路由选择协议ARP RARP OSPF</p>
</li>
<li><p>注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
</li>
</ol>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ol>
<li><p>任务：两台主机之间的链路上的数据传输 </p>
</li>
<li><p>数据单元：帧。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
</li>
</ol>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><em><strong>物理层</strong></em></h4><ol>
<li><p>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
</li>
<li><p>数据单位：比特。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[TOC]</p>
<h4 id="复杂度总结"><a href="#复杂度总结" class="headerlink" title="复杂度总结"></a><em><strong>复杂度总结</strong></em></h4><p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/wps29.jpg" alt="img"> </p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a><em><strong>思路</strong></em></h4><h5 id="（1）直接插入"><a href="#（1）直接插入" class="headerlink" title="*（1）直接插入*"></a><em><strong>*（1）直接插入*</strong></em></h5><p>每次将一个待排序的数据，插入到前面已经排好序的序列之中，直到全部数据插入完成。</p>
<h5 id="（2）-二分法插入排序"><a href="#（2）-二分法插入排序" class="headerlink" title="*（2） 二分法插入排序*"></a><em><strong>*（2） 二分法插入排序*</strong></em></h5><p>首先取出原有序中间数与新插的数比较，然后插入新数大小包含于其中的一半数组，再次取该数组中间数,如此重复下去，直至最后得到数组个数为一，将最后得到的数之后的数后移，然后将新插入的数放在该索引处。</p>
<h5 id="（3）希尔排序"><a href="#（3）希尔排序" class="headerlink" title="*（3）希尔排序*"></a><em><strong>*（3）希尔排序*</strong></em></h5><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称希尔排序为“跳着插”</p>
<h5 id="（4）简单选择排序"><a href="#（4）简单选择排序" class="headerlink" title="*（4）简单选择排序*"></a><em><strong>*（4）简单选择排序*</strong></em></h5><p>数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，直到整个数组变有序区。</p>
<h5 id="（5）堆排序"><a href="#（5）堆排序" class="headerlink" title="*（5）堆排序*"></a><em><strong>*（5）堆排序*</strong></em></h5><p>堆排序的难点就在于堆的的插入和删除。</p>
<p>堆的插入就是——每次插入都是将新数据放在数组最后，而从这个新数据的父结点到根结点必定是一个有序的数列，因此只要将这个新数据插入到这个有序数列中即可。</p>
<p>堆的删除就是——堆的删除就是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点开始将一个数据在有序数列中进行“下沉”。</p>
<p>因此，堆的插入和删除非常类似直接插入排序，只不是在二叉树上进行插入过程。所以可以将堆排序形容为“树上插”</p>
<h5 id="（6）冒泡排序"><a href="#（6）冒泡排序" class="headerlink" title="*（6）冒泡排序*"></a><em><strong>*（6）冒泡排序*</strong></em></h5><p>通过交换使相邻的两个数变成小数在前大数在后，这样每次遍历后，最大的数就“沉”到最后面了。重复N次即可以使数组有序。</p>
<p>冒泡排序改进1：在某次遍历中如果没有数据交换，说明整个数组已经有序。因此通过设置标志位来记录此次遍历有无数据交换就可以判断是否要继续循环。</p>
<p>冒泡排序改进2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</p>
<h5 id="（7）快速排序"><a href="#（7）快速排序" class="headerlink" title="*（7）快速排序*"></a><em><strong>*（7）快速排序*</strong></em></h5><p>“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。因此将数组分成二部分再分别重复上述步骤就完成了排序。</p>
<h5 id="（8）归并排序"><a href="#（8）归并排序" class="headerlink" title="*（8）归并排序*"></a><em><strong>*（8）归并排序*</strong></em></h5><p>当一个数组左边有序，右边也有序，那合并这两个有序数组就完成了排序。如何让左右两边有序了？用递归！这样递归下去，合并上来就是归并排序。</p>
<h5 id="（9）基数排序"><a href="#（9）基数排序" class="headerlink" title="*（9）基数排序*"></a><em><strong>*（9）基数排序*</strong></em></h5><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>常用数据结构总结</title>
    <url>/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.<em>数组</em></h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><em>概念</em></h4><p><strong>数组</strong>（Array） 是一种很常见的数据结构。它由****相同类型的元素****（element）组成，并且是使用一块连续的内存来存储。</p>
<p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
<p>数组的特点是：****提供随机访问 并且容量有限****。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong><strong>使用场景</strong></strong></h4><p>1）数据量较小。</p>
<p>2）数据规模已知。</p>
<p>3）随机访问，修改元素值。</p>
<p>如果插入速度很重要，选择无序数组。如果查找速度很重要，选择有序数组，并使用二分查找。</p>
<h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. <em>链表</em></h2><p>****链表*<em><strong>（LinkedList） 虽然是一种</strong></em>*线性表****，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p>
<p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在<em><strong>*查找一个节点或者访问特定位置的节点的时候复杂度为 O(n)*</strong></em> 。</p>
<p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p>
<h4 id="链表分类"><a href="#链表分类" class="headerlink" title="链表分类"></a>链表分类</h4><ol>
<li><p>单链表</p>
</li>
<li><p>双向链表</p>
</li>
<li><p>循环链表</p>
</li>
<li><p>双向循环链表</p>
</li>
</ol>
<p><strong>单链表</strong></p>
<p>单链表 单向链表****只有一个方向，结点只有一个后继指针 next 指向后面的节点****。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p>
<p><strong>循环链表</strong></p>
<p>循环链表 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p>
<p><strong>双向链表</strong></p>
<p>双向链表 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>
<p><strong>双向循环链表</strong></p>
<p>双向循环链表 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>如果需要支持随机访问的话，链表没办法做到。</p>
<p>如果需要****存储的数据元素的个数不确定*<em><strong>，并且需要</strong></em>*经常添加和删除数据****的话，使用链表比较合适。</p>
<p>如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。</p>
<h4 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h4><p>· 数组支持随机访问，而链表不支持。</p>
<p>· 数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</p>
<p>· 数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</p>
<h2 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>****栈 (stack)*<em><strong>只允许在</strong></em>*有序的线性数据集合的一端（称为栈顶 top）进行加入数据****（push）和移除数据（pop）。因而按照 <em><strong>*后进先出*<em><strong>（LIFO, Last In First Out） 的原理运作。在栈中，</strong></em>*push 和 pop 的操作都发生在栈顶。*</strong></em></p>
<p>栈常用一维****数组或链表****来实现，用数组实现的栈叫作 顺序栈 ，用链表实现的栈叫作 链式栈 。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 后进先出（LIFO, Last In First Out） 的特性时，我们就可以使用栈这个数据结构。</p>
<p><strong>1.实现浏览器的回退和前进功能</strong></p>
<p>我们只需要使用<em><strong>*两个栈*</strong></em>(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 ****1,2,3,4 这四个页面压入 Stack1 中****。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 ****4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中****。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。</p>
<p>2.<strong>检查符号是否成对出现</strong></p>
<p>括号匹配问题：</p>
<ol>
<li><p>首先我们将括号间的对应规则存放在 Map 中，这一点应该毋容置疑；</p>
</li>
<li><p>创建一个栈。遍历字符串，如果字符是****左括号就直接加入stack中****，否则将stack 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果stack为空，返回 true。</p>
</li>
</ol>
<p>3.<strong>反转字符串</strong></p>
<p>将字符串中的每个字符先入栈再出栈就可以了。</p>
<p>4.<strong>维护函数调用</strong></p>
<p>最后一个被调用的函数必须先完成执行，符合栈的 后进先出（LIFO, Last In First Out） 特性。</p>
<h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h2><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>队列 是 <em><strong>*先进先出*</strong></em>( FIFO，First In, First Out) 的线性表。在具体应用中通常用****链表或者数组*<em><strong>来实现，用数组实现的队列叫作 顺序队列 ，用链表实现的队列叫作 链式队列 。队列只允许在</strong></em>*后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除****操作也就是出队 dequeue</p>
<p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>
<h4 id="队列分类"><a href="#队列分类" class="headerlink" title="队列分类"></a>队列分类</h4><p><strong>单队列</strong></p>
<p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <em><strong>*顺序队列（数组实现）*</strong></em> 和 ****链式队列（链表实现）****。</p>
<p><em><strong>*顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。*</strong></em></p>
<p><strong>循环队列</strong></p>
<p>****循环队列*<em><strong>可以解决顺序队列的</strong></em>*假溢出和越界问题****。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p>
<p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p>
<p><strong>·</strong> <em><strong>阻塞队列：</strong></em> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</p>
<p><strong>·</strong> <em><strong>线程池中的请求/任务队列：</strong></em> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：FixedThreadPool 使用无界队列 LinkedBlockingQueue。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出java.util.concurrent.RejectedExecutionException 异常。</p>
<p>· Linux 内核进程队列（按优先级排队）</p>
<p>· 现实生活中的派对，播放器上的播放列表;</p>
<p>· 消息队列</p>
<h2 id="5-图"><a href="#5-图" class="headerlink" title="5. 图"></a>5. 图</h2><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>图就是由****顶点*<em><strong>的有穷非空集合和</strong></em>*顶点之间的边**<strong>组成的集合。通常表示为：</strong>G(V,E)**，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>无向图和有向图</strong></p>
<p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就<em><strong>不用关注方向，用不带箭头的边表示，这样的图就是无向图。</strong></em></p>
<p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是<strong>有向图</strong>。</p>
<p><strong>无权图和带权图</strong></p>
<p>对于一个关系，如果我们只****关心关系的有无，而不关心关系有多强*<em><strong>，那么就可以用</strong></em>*无权图****表示二者的关系。</p>
<p>对于一个关系，如果我们****既关心关系的有无，也关心关系的强度*<em><strong>，比如描述地图上两个城市的关系，需要用到距离，那么就用</strong></em>*带权图****来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。</p>
<h4 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h4><p><strong>邻接矩阵存储</strong></p>
<p>邻接矩阵将图用****二维矩阵存储****，是一种较为直观的表示方式。</p>
<p>如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 A[i][j]=n 。</p>
<p>在****无向图****中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，A[i][j]=1，当顶点i和顶点j没有关系时，A[i][j]=0。</p>
<p><strong>邻接表存储</strong></p>
<p>针对上面<em><strong>*邻接矩阵比较浪费内存空间*<em><strong>的问题，诞生了图的另外一种存储方法—</strong></em>*邻接表*</strong></em> 。</p>
<p>邻接链表使用****一个链表来存储某个顶点的所有后继相邻顶点****。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 邻接表。</p>
<h4 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h4><p><strong>广度优先搜索-队列</strong></p>
<p>广度优先搜索就像水面上的波纹一样一层一层向外扩展。</p>
<p><strong>深度优先搜索-栈</strong></p>
<p>深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”。</p>
<h2 id="6-堆"><a href="#6-堆" class="headerlink" title="6. 堆"></a>6. 堆</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>堆是一种满足以下条件的树：</p>
<p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p>
<p><strong>·</strong> <em><strong>堆不一定是完全二叉树</strong></em>，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。</p>
<p>· （<em><strong>二叉</strong></em>）堆是一个数组，它可以被看成是一个 ****近似的完全二叉树****。——《算法导论》第三版</p>
<h4 id="堆的用途"><a href="#堆的用途" class="headerlink" title="堆的用途"></a>堆的用途</h4><p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p>
<p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 O(nlog(n))，查找最大值或者最小值时间复杂度都是 O(1)，但是，涉及到更新（插入或删除）数据时，时间复杂度为 O(n)，即使是使用复杂度为 O(log(n)) 的二分法找到要插入或者删除的数据，在移动数据时也需要 O(n) 的时间复杂度。</p>
<p><em><strong>*相对于有序数组而言，堆的主要优势在于更新数据效率较高。*</strong></em> 堆的初始化时间复杂度为 O(nlog(n))，堆可以做到O(1)时间复杂度取出最大值或者最小值，O(log(n))时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。</p>
<h4 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h4><p>堆分为 <em><strong>*最大堆*</strong></em> 和 ****最小堆****。二者的区别在于节点的排序方式。</p>
<p><strong>·</strong> <em><strong>*最大堆*</strong></em> ：堆中的每一个节点的值都大于等于子树中所有节点的值</p>
<p><strong>·</strong> <em><strong>*最小堆*</strong></em> ：堆中的每一个节点的值都小于等于子树中所有节点的值</p>
<h4 id="堆的操作总结"><a href="#堆的操作总结" class="headerlink" title="堆的操作总结"></a>堆的操作总结</h4><p><strong>·</strong> <em><strong>*插入元素*</strong></em> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</p>
<p><strong>·</strong> <em><strong>*删除堆顶元素*</strong></em> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</p>
<h2 id="7-树"><a href="#7-树" class="headerlink" title="7. 树"></a>7. 树</h2><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a><em>概念</em></h4><p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。</p>
<p>一棵树具有以下特点：</p>
<ol>
<li><p>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</p>
</li>
<li><p>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</p>
</li>
<li><p>一棵树不包含回路。</p>
</li>
</ol>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>①　二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p>
<p>②　二叉树 的分支通常被称作“左子树”或“右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒。</p>
<p>③　二叉树 的第 i 层至多拥有 2^(i-1) 个节点，深度为 k 的二叉树至多总共有 2^k-1 个节点</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 ****满二叉树****。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 ****满二叉树****。如下图所示：</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 <em><strong>*完全二叉树*</strong></em> 。</p>
<p>大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><em><strong>平衡二叉树</strong></em> 是一棵二叉排序树，且具有以下性质：</p>
<ol>
<li><p>可以是一棵空树</p>
</li>
<li><p>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p>
</li>
</ol>
<p>平衡二叉树的常用实现方法有 <em><strong>红黑树</strong></em>、<em><strong>AVL 树</strong></em>、<em><strong>替罪羊树</strong></em>、<em><strong>加权平衡树</strong></em>、<em><strong>伸展树</strong></em> 等。</p>
<h4 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h4><p>二叉树的存储主要分为 <em><strong>*链式存储*</strong></em> 和 <em><strong>*顺序存储*</strong></em> 两种：</p>
<p><strong>链式存储</strong></p>
<p>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。</p>
<p>每个节点包括三个属性：</p>
<p>· 数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</p>
<p>· 左节点指针 left</p>
<p>· 右节点指针 right。</p>
<p><strong>顺序存储</strong></p>
<p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2 _ i 的位置，它的右子节点存储在下标为 2 _ i+1 的位置。</p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>先序、中序、后续</p>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉查找树：为了实现快速查找而生。要求在树的任意一个节点，左子树中每个节点的值都小于这个节点的值，右子树中每个节点的值都大于这个节点。</p>
<h4 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树：二叉树中任意一个节点的左右子树的高度相差不能大于1.</p>
<p>平衡二叉查找树：（很多并没有严格符合上述定义）</p>
<p>****设计初衷*****：解决普通二叉查找树在频繁插入、删除等动态更新情况下，出现的复杂度退化问题。让整个树比较平衡。</p>
<p>平衡二叉树有哪些：</p>
<p>​    AVL树，高度平衡的二叉查找树</p>
<p>​    红黑树，根节点到各个叶子结点的最大路径可能会比最短路径大一倍。</p>
<p>​    Splay Tree伸展树</p>
<p>​    Treap树堆</p>
<p><em><strong>*如何保持平衡：*</strong></em></p>
<p>根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。</p>
<p>分为LL型、RR型、LR型和RL型4种类型</p>
<p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps25.jpg" alt="img"> </p>
<p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps26.jpg" alt="img"> </p>
<p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps27.jpg" alt="img"> </p>
<p><img src="/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/wps28.jpg" alt="img"> </p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是平衡二叉查找树的一种。</p>
<p><em><strong>*红黑树*</strong></em></p>
<p>Red-Black Tree，R-B Tree，不严格的平衡二叉查找树，做到了近似平衡。</p>
<p>解决普通二叉查找树在频繁插入、删除等动态更新情况下，出现的复杂度退化问题。让整个树比较平衡。</p>
<p>红黑树的高度近似log2n，插入、删除、查找操作的时间复杂度都是O(logn)。</p>
<p>红黑树是一种性能非常稳定的二叉查找树。</p>
<p>相比于AVL，<em><strong>*红黑树优势：*</strong></em></p>
<p>引入RB-Tree是功能、性能、空间开销的折中结果。</p>
<ol>
<li><p>维护成本：红黑树较小，AVL更大</p>
</li>
<li><p>读取性能：红黑树略逊于AVL</p>
</li>
<li><p>空间开销：两者类似，内容极多时略优于AVL</p>
</li>
</ol>
<p>基本上主要的几种平衡树看来，红黑树有着良好的稳定性，综合实力强。实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<p>定义：红黑树中的节点一类被标记为黑色，一类标记为红色，还有几个要求：</p>
<ol>
<li><p>根节点为黑色</p>
</li>
<li><p>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据</p>
</li>
<li><p>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的</p>
</li>
<li><p>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点</p>
</li>
</ol>
<h4 id="红黑树、B-树"><a href="#红黑树、B-树" class="headerlink" title="红黑树、B+树"></a>红黑树、B+树</h4><p>红黑树多用在内部排序，即全放在内存中的，STL的map和set的内部实现就是红黑树。</p>
<p>B+树多用于外存上时，B+也被成为一个磁盘友好的数据结构。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2021/09/10/Spring/Mybatis/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.<em><strong>优点</strong></em></h3><p>MyBatis框架的优点：</p>
<ol>
<li><p>与JDBC相比，减少了50%以上的代码量</p>
</li>
<li><p>MyBatis是最简单的持久化框架，小巧并且简单易学</p>
</li>
<li><p>MyBatis灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，降低耦合度，便于统一管理和优化，可重用</p>
</li>
<li><p>提供XML标签，支持编写动态SQL语句（XML中使用if, else）</p>
</li>
<li><p>提供映射标签，支持对象与数据库的ORM字段关系映射（在XML中配置映射关系，也可以使用注解）。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求</p>
</li>
<li><p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
</li>
</ol>
<p>MyBatis框架适用场合：</p>
<p>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</p>
<p>对性能的要求很高，或者需求变化较多的项目，如互联网项目</p>
<h3 id="2-Mybatis一级缓存-二级缓存"><a href="#2-Mybatis一级缓存-二级缓存" class="headerlink" title="2. Mybatis一级缓存 二级缓存"></a>2. <em><strong>Mybatis一级缓存 二级缓存</strong></em></h3><p>针对查询操作，mybatis支持通过缓存的方式来减少SQL的调用，提高查询性能。在缓存级别方面分为一级缓存和二级缓存，区别：</p>
<ol>
<li><p>一级缓存的粒度较小，是与某个SqlSession绑定的，只对该SqlSession的相关查询操作进行缓存，不同SqlSession实例之间相互不影响，缓存为使用本地内存实现</p>
</li>
<li><p>二级缓存是一种全局缓存，是由所有SqlSession实例所共享的，即不同SqlSession实例查询时产生的缓存，对其他SqlSession实例可见</p>
</li>
</ol>
<h3 id="3"><a href="#3" class="headerlink" title="3. #{} ${}"></a>3. <em><strong>#{}</strong></em> <em><strong>${}</strong></em></h3><p>${}是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。</p>
<p>#{}是 sql 的参数占位符，MyBatis 会将 sql 中的#{}替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName()。</p>
<h3 id="4-mybatis和jdbc区别"><a href="#4-mybatis和jdbc区别" class="headerlink" title="4. mybatis和jdbc区别"></a>4. <em><strong>mybatis和jdbc区别</strong></em></h3><p><em><strong>JDBC</strong></em>是Java提供的一个操作数据库的API；</p>
<p><em><strong>MyBatis</strong></em>是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p>
<p>MyBatis是对JDBC的封装。相对于JDBC，MyBatis有以下优点：</p>
<p><em><strong>*1. 优化获取和释放*</strong></em></p>
<p>我们一般在访问数据库时都是通过数据库连接池来操作数据库，数据库连接池有好几种，比如C3P0、DBCP，也可能采用容器本身的JNDI数据库连接池。我们可以通过DataSource进行隔离解耦，我们统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，所以我们将DataSource的具体实现通过让用户配置来应对变化。</p>
<p>C3P0 xml配置：</p>
<p><bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"><br>  <property name="driverClass" value=" oracle.jdbc.driver.OracleDriver ">   </property></bean></p>
  <property name="jdbcUrl" value=" jdbc:oracle:thin:@localhost:1521:ora9i ">   
  <property name="user" value="admin">   
  <property name="password" value="1234">   
 

<p>DBCP xml配置：</p>
<p><bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"><br>  <property name="driverClassName" value="com.mysql.jdbc.Driver"><br>  <property name="url" value="jdbc:mysql://localhost:3309/sampledb"><br>  <property name="username" value="root"><br>  <property name="password" value="1234"><br></property></property></property></property></bean></p>
<p>DURID xml配置：</p>
<bean name="dataSource" class="com.alibaba.druid.pool.DruidDataSource"> 

<p>　　<property name="driverClassName"> </property></p>
<p>　　　　<value>com.mysql.jdbc.Driver</value> </p>
<p>　　</p></bean></property> <p></p>
<p>　　<property name="url"> </property></p>
<p>　　　　<value>${jdbc_url_gx}</value> </p>
<p>　　</p></property> <p></p>
<p>　　<property name="username"> </property></p>
<p>　　　　<value>${jdbc_username_gx}</value> </p>
<p>　　</p></property> <p></p>
<p>　　<property name="password"> </property></p>
<p>　　　　<value>${jdbc_password_gx}</value> </p>
<p>　　 </p>


<p><em><strong>*2.SQL统一管理，对数据库进行存取操作*</strong></em></p>
<p>我们使用JDBC对数据库进行操作时，SQL查询语句分布在各个Java类中，这样可读性差，不利于维护，当我们修改Java类中的SQL语句时要重新进行编译。</p>
<p>Mybatis可以把SQL语句放在配置文件中统一进行管理，以后修改配置文件，也不需要重新就行编译部署。</p>
<p><em><strong>*3.生成动态SQL语句*</strong></em></p>
<p>我们在查询中可能需要根据一些属性进行组合查询，比如我们进行商品查询，我们可以根据商品名称进行查询，也可以根据发货地进行查询，或者两者组合查询。如果使用JDBC进行查询，这样就需要写多条SQL语句。</p>
<p>Mybatis可以在配置文件中通过使用<if test="””"></if>标签进行SQL语句的拼接，生成动态SQL语句。比如下面这个例子：</p>
<select id="getCountByInfo" parametertype="User" resulttype="int">
     select count(*) from user
     <where>
       <if test="nickname!=null">
         and nickname = #{nickname}
       </if>
       <if test="email!=null">
         and email = #{email}
       </if>
     </where>

</select>

<p>就是通过昵称或email或者二者的组合查找用户数。</p>
<p><em><strong>*4.能够对结果集进行映射*</strong></em></p>
<p>我们在使用JDBC进行查询时，返回一个结果集ResultSet,我们要从结果集中取出结果封装为需要的类型</p>
<p>在Mybatis中我们可以设置将结果直接映射为自己需要的类型，比如：JavaBean对象、一个Map、一个List等等。像上个例子中就是将结果映射为int类型。</p>
<h3 id="5-xml映射文件常见标签"><a href="#5-xml映射文件常见标签" class="headerlink" title="5. xml映射文件常见标签"></a>5. <em><strong>xml映射文件常见标签</strong></em></h3><p>select|insert|update|delete</p>
<p><resultMap><parameterMap></parameterMap></resultMap></p>
<p><sql> sql 片段标签</sql></p>
<p><include> 引入 sql 片段</include></p>
<p><selectKey> 为不支持自增的主键生成策略标签</selectKey></p>
<p>动态 sql 的 9 个标签：</p>
<p>trim|where|set|foreach|if|choose|when|otherwise|bind</p>
<h3 id="6-Da-o-接口工作原理"><a href="#6-Da-o-接口工作原理" class="headerlink" title="6. Da***o***接口工作原理"></a>6. <em><strong>Da</strong>***</em>o***<em><strong>接口工作原理</strong></em></h3><p>最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</p>
<p>Dao 接口，就是人们常说的 Mapper接口。</p>
<p>接口的全限名就是xml中的 namespace 的值，接口的方法名就是xml中MappedStatement的 id 值，接口方法内的参数就是传递给 sql 的参数。</p>
<p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个xml中的MappedStatement。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将 sql 执行结果返回。</p>
<p>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在 MyBatis 中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</delete></update></insert></select></p>
<p>Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复。可以这样实现：（能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法）</p>
<p>public interface StuMapper {</p>
<p>  List<Student> getAllStu();</Student></p>
<p>  List<Student> getAllStu(@Param(“id”) Integer id);</Student></p>
<p>}</p>
  <select id="getAllStu" resulttype="com.pojo.Student">

<p>​     select * from student</p>
<p>​    <where></where></p>
<p>​      <if test="id != null"></if></p>
<p>​        id = #{id}</p>
<p>​      </p>
<p>​    </p>
   </select>

<h3 id="7-动态-sql"><a href="#7-动态-sql" class="headerlink" title="7.动态 sql"></a>7.<em><strong>动态 sql</strong></em></h3><p>是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</p>
<p>MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。</p>
<p>MyBatis 提供了 9 种动态 sql 标签 trim|where|set|foreach|if|choose|when|otherwise|bind</p>
<p>其执行原理：使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h3 id="8-如何将-sql-执行结果封装为目标对象并返回"><a href="#8-如何将-sql-执行结果封装为目标对象并返回" class="headerlink" title="8. 如何将 sql 执行结果封装为目标对象并返回"></a>8. <em><strong>如何将 sql 执行结果封装为目标对象并返回</strong></em></h3><p>MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</p>
<p>映射形式：</p>
<ol>
<li><p>使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系</resultMap></p>
</li>
<li><p>使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p>
</li>
</ol>
<p>如何：有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h3 id="9-一对一、一对多的关联查询"><a href="#9-一对一、一对多的关联查询" class="headerlink" title="9. 一对一、一对多的关联查询"></a>9. <em><strong>一对一、一对多的关联查询</strong></em></h3><p>MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</p>
<p>能，MyBatis 不仅可以执行一对一、一对多的关联查询</p>
<p>还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为 selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为 selectList()即可。</p>
<p>关联对象查询，有两种实现方式：</p>
<ol>
<li><p>单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。</p>
</li>
<li><p>使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p>
</li>
</ol>
<p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据列值来完成 100 条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。</id></id></resultMap></p>
<p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p>
<h3 id="10-是否支持延迟加载"><a href="#10-是否支持延迟加载" class="headerlink" title="10. 是否支持延迟加载"></a>10. <em><strong>是否支持延迟加载</strong></em></h3><p>MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</p>
<p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。</p>
<p>association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。</p>
<p>原理：使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<h3 id="11-不同的-Xml-映射文件，id-是否可以重复"><a href="#11-不同的-Xml-映射文件，id-是否可以重复" class="headerlink" title="11. 不同的 Xml 映射文件，id 是否可以重复"></a>11. <em><strong>不同的 Xml 映射文件，id 是否可以重复</strong></em></h3><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p>
<p>原因就是 namespace+id 是作为 Map&lt;String, MappedStatement&gt;的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
<h3 id="12-如何执行批处理？"><a href="#12-如何执行批处理？" class="headerlink" title="12. 如何执行批处理？"></a>12. <em><strong>如何执行批处理？</strong></em></h3><p>使用 BatchExecutor 完成批处理。</p>
<h3 id="13-Executor-执行器"><a href="#13-Executor-执行器" class="headerlink" title="13. Executor 执行器"></a>13. <em><strong>Executor 执行器</strong></em></h3><p>MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？ </p>
<ol>
<li><p>SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象</p>
</li>
<li><p>ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p>
</li>
<li><p>BatchExecutor：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
</li>
</ol>
<p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<p>在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 DefaultSqlSessionFactory 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p>
<h3 id="14-是否可以映射枚举类"><a href="#14-是否可以映射枚举类" class="headerlink" title="14. 是否可以映射枚举类"></a>14. <em><strong>是否可以映射枚举类</strong></em></h3><p>MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。</p>
<p>映射方式为自定义一个 TypeHandler，实现 TypeHandler 的 setParameter()和 getResult()接口方法。TypeHandler 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 setParameter()和 getResult()两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p>
<h3 id="15-引用标签后，两个标签的位置"><a href="#15-引用标签后，两个标签的位置" class="headerlink" title="15. 引用标签后，两个标签的位置"></a>15. <em><strong>引用标签后，两个标签的位置</strong></em></h3><p>MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</p>
<p>虽然 MyBatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。</p>
<p>原理是：MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<h3 id="16-xml和内部数据结构映射关系"><a href="#16-xml和内部数据结构映射关系" class="headerlink" title="16. xml和内部数据结构映射关系"></a>16. <em><strong>xml和内部数据结构映射关系</strong></em></h3><p>简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</p>
<p>MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。</p>
<p><parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</parameterMap></p>
<p><resultMap>标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</resultMap></p>
<p>每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象。</delete></update></insert></select></p>
<p>标签内的 sql 会被解析为 BoundSql 对象。</p>
<h3 id="17-为什么说-MyBatis-是半自动-ORM-映射工具"><a href="#17-为什么说-MyBatis-是半自动-ORM-映射工具" class="headerlink" title="17. 为什么说 MyBatis 是半自动 ORM 映射工具"></a>17. <em><strong>为什么说</strong></em> <em><strong>MyBatis 是半自动 ORM 映射工具</strong></em></h3><p>为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</p>
<p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p>
<p>而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
<p> 摘自：</p>
<p><a href="https://blog.csdn.net/qiushisoftware/article/details/98944211">https://blog.csdn.net/qiushisoftware/article/details/98944211</a></p>
<p> <a href="https://www.cnblogs.com/love-Stefanie/p/6838269.html">https://www.cnblogs.com/love-Stefanie/p/6838269.html</a></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2021/09/10/Spring/Servlet/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-Servlet是什么"><a href="#1-Servlet是什么" class="headerlink" title="1. Servlet是什么"></a>1. Servlet是什么</h3><p>Servlet定义：一段处理 web 请求的逻辑</p>
<p>在Java中，servlet是一个接口，规定请求从容器到达 web 服务端的规范，最重要的三个步骤是:</p>
<ol>
<li><p>init()：初始化请求的时候要做什么；</p>
</li>
<li><p>service()：拿到请求的时候要做什么；</p>
</li>
<li><p>destory()：处理完请求销毁的时候要做什么。</p>
</li>
</ol>
<p>所有实现 Servlet 的实现都是在这个规范的基础上进行开发。</p>
<p>package javax.servlet;</p>
<p>import java.io.IOException;</p>
<p>public interface Servlet {</p>
<p>public void <em><strong>*init*</strong></em>(ServletConfig config) throws ServletException;</p>
<pre><code>  public ServletConfig ***\*getServletConfig\****();

  public void ***\*service\****(ServletRequest req, ServletResponse res)
</code></pre>
<p>​      throws ServletException, IOException;</p>
<pre><code>  public String ***\*getServletInfo\****();

  public void ***\*destroy\****();
</code></pre>
<p>}</p>
<h3 id="2-Servlet容器"><a href="#2-Servlet容器" class="headerlink" title="2. Servlet容器"></a>2. Servlet容器</h3><p>Servlet 只是一个处理请求的应用程序，光有Servlet是无法运行起来的，需要有一个 main 方法去调用你的这段 Servlet 程序才行。这就需要servlet容器了。</p>
<p>Servlet容器的主要作用是：</p>
<ol>
<li><p>建立连接；</p>
</li>
<li><p>调用Servlet处理请求；</p>
</li>
<li><p>响应请求给客户端；</p>
</li>
<li><p>释放连接；</p>
</li>
</ol>
<p>常见的Servlet容器Tomcat的流程：</p>
<p>监听了客户端的请求端口,根据请求信息确定将请求交给哪个Servlet 处理，找到处理的Servlet之后，调用该Servlet的 service() 方法，处理完毕将对应的处理结果包装成ServletResponse 对象返回给客户端。</p>
<p>Servlet容器只有一个，而 Servlet 可以有多个。</p>
<h3 id="3-DispatcherServlet"><a href="#3-DispatcherServlet" class="headerlink" title="3. DispatcherServlet"></a>3. DispatcherServlet</h3><p>定义：是 Spring 中定义的一个 Servlet，实现了 Servlet 接口，本质也是一个 Servlet。</p>
<p>它是 HttpServlet 的继承者，主要处理 http 请求。</p>
<p>所以 Spring 程序本质是就是一个 Servlet。SpringMVC 帮你做了本该你去实现的逻辑。</p>
<p>Spring 的核心就是一个 Servlet,它拦截了所有的请求,将请求交给 DispatcherServlet 去处理</p>
<h3 id="4-Tomcat"><a href="#4-Tomcat" class="headerlink" title="4. Tomcat*"></a>4. Tomcat*</h3><p>Tomcat：常见的Servlet容器Tomcat，实现了对 Java Servlet 规范的支持</p>
<p>Tomcat 也提供了处理HTTP请求的能力，所以也可以作为一个Web服务器。</p>
<p>Tomcat如何设计？如下图：</p>
<p><img src="/2021/09/10/Spring/Servlet/wps23.jpg" alt="img"> </p>
<p>Java web 应用如果部署到 Tomcat 中，一个Tomcat就表示一个服务。</p>
<p>一个 Server 服务器可以包含多个 Service 服务，Tomcat 默认的 Service 服务是 Catalina</p>
<p>一个 Service 服务可以包含</p>
<p>① 多个连接器，因为 Tomcat 支持多种网络协议，包括 HTTP/1.1、HTTP/2、AJP 等等</p>
<p>② 一个容器，容器外部会有一层 Engine 引擎所包裹，负责与处理连接器的请求与响应，连接器与容器之间通过 ServletRequest 和 ServletResponse 对象进行交流。</p>
<p>Server 组件：管理 tomcat 实例的组件，可以监听一个端口</p>
<p>Service 组件：是一个逻辑组件，用于绑定 connector 和 container，有了 service 表示可以向外提供服务，就像是一般的 daemon 类服务的 service。可以认为一个 service 就启动一个JVM，更严格地说，一个 engine 组件才对应一个 JVM （定义负载均衡时，jvmRoute 就定义在 Engine 组件上用来标识这个 JVM ），只不过 connector 也工作在 JVM 中。</p>
<p>Connector 组件：监听组件，它有四个作用：</p>
<ol>
<li><p>开启监听套接字，监听外界请求，并和客户端建立 TCP 连接</p>
</li>
<li><p>使用 protocolHandler 解析请求中的协议和端口等信息，如 http 协议、AJP 协议；</p>
</li>
<li><p>根据解析到的信息，使用 processer 将分析后的请求转发给绑定的 Engine；</p>
</li>
<li><p>接收响应数据并返回给客户端。</p>
</li>
</ol>
<p>Container ：表示一类组件，在配置文件(server.xml)中没有体现出来。它包含4个容器类组件：Engine容器、Host容器、Context容器 和 wrapper容器。</p>
<p>Engine 容器用于从 Connector 组件处接收已建立的 TCP 连接，还用于接收客户端发送的 HTTP 请求并分析请求，然后按照分析的结果将相关参数传递给匹配出的虚拟主机。Engine 还用于指定默认的虚拟主机。</p>
<p>Host 容器定义虚拟主机，对应了服务器中一个网络名实体（如”<a href="http://www.baidu.com”,或ip地址”23.0.32.1”).为了使用户可以通过域名连接/">www.baidu.com”，或IP地址”23.0.32.1”）。为了使用户可以通过域名连接</a> Tomcat 服务器，这个域名应该在域名服务器已经注册过。</p>
<p>Context 容器主要是根据 path 和 docBase 获取一些信息，将结果交给其内的 wrapper 组件进行处理（它提供wrapper运行的环境，所以它叫上下文context）。一般来说，都采用默认的标准 wrapper 类，因此在 Context 容器中几乎不会出现 wrapper 组件。</p>
<p>wrapper 容器对应 Servlet 的处理过程。它开启 Servlet 的生命周期，根据 Context 给出的信息以及解析 web.xml 中的映射关系，负责装载相关的类，初始化 servlet 对象 init()、执行 servlet 代码 service() 以及服务结束时 servlet 对象的销毁 destory()。</p>
<p>摘自：</p>
<p><a href="https://www.cnblogs.com/rickiyang/p/12764615.html">https://www.cnblogs.com/rickiyang/p/12764615.html</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2021/09/10/Spring/SpringBoot/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-Springboot是什么"><a href="#1-Springboot是什么" class="headerlink" title="1. Springboot是什么"></a>1. Springboot是什么</h3><p>Spring Boot 并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p>
<p>集成了大量常用的第三方库配置，Spring Boot中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p>
<h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ol>
<li><p>SpringBoot继承了Spring优秀的基因，在Spring中开发更为方便快捷，帮助开发者快速的搭建Spring框架</p>
</li>
<li><p>简化依赖。比如创建一个 web 项目，在使用 Spring 的时需要在 pom 文件中添加多个依赖，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。</p>
</li>
<li><p>简化配置。Spring各种XML、Annotation配置会让人眼花缭乱，Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。比如@Configuration。另外，Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可</p>
</li>
<li><p>简化部署。Spring 项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里。Spring Boot 不需要在服务器上去部署 tomcat，内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 java -jar xxx.jar一键式启动项目。</p>
</li>
</ol>
<h3 id="3-自动装配原理"><a href="#3-自动装配原理" class="headerlink" title="3. 自动装配原理"></a>3. 自动装配原理</h3><p><em><strong>是什么</strong></em></p>
<p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>
<p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 spring-boot-starter-data-redis即可。</p>
<p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。自动装配可以简单理解为：通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</p>
<p><em><strong>如何实现？</strong></em></p>
<p>@SpringBootApplication可以看做以下3个的集合：</p>
<ol>
<li><p>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</p>
</li>
<li><p>@Configuration：允许在上下文中注册额外的 bean 或导入其他配置</p>
</li>
<li><p>@ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。</p>
</li>
</ol>
<p>@EnableAutoConfiguration:实现自动装配的核心注解</p>
<p>EnableAutoConfiguration 只是一个简单地注解，自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector类。</p>
<p>AutoConfigurationImportSelector:加载自动装配类，该类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。实现如下：</p>
<p>private static final String[] NO_IMPORTS = new String[0];</p>
<p>public String[] selectImports(AnnotationMetadata annotationMetadata) {</p>
<p>​    // &lt;1&gt;.判断自动装配开关是否打开</p>
<p>​    if (!this.isEnabled(annotationMetadata)) {</p>
<p>​      return NO_IMPORTS;</p>
<p>​    } else {</p>
<p>​     //&lt;2&gt;.获取所有需要装配的bean</p>
<p>​      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);</p>
<p>​      AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</p>
<p>​      return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</p>
<p>​    }</p>
<p>  }</p>
<p>getAutoConfigurationEntry()方法：主要负责加载自动配置类的。源码如下：</p>
<p>AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {</p>
<p>​    //&lt;1&gt;.判断自动装配开关是否打开</p>
<p>​    if (!this.isEnabled(annotationMetadata)) {</p>
<p>​      return EMPTY_ENTRY;</p>
<p>​    } else {</p>
<p>​      //&lt;2&gt;.获取exclude 和 excludeName</p>
<p>​      AnnotationAttributes attributes = this.getAttributes(annotationMetadata);</p>
<p>​      //&lt;3&gt;.读取META-INF/spring.factories</p>
<p>​      List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</String></p>
<p>​      //&lt;4&gt;.选出@ConditionalOnXXX 中的所有条件</p>
<p>​      configurations = this.removeDuplicates(configurations);</p>
<p>​      Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);</String></p>
<p>​      this.checkExcludedClasses(configurations, exclusions);</p>
<p>​      configurations.removeAll(exclusions);</p>
<p>​      configurations = this.filter(configurations, autoConfigurationMetadata);</p>
<p>​      this.fireAutoConfigurationImportEvents(configurations, exclusions);</p>
<p>​      return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</p>
<p>​    }</p>
<p>  }</p>
<ol>
<li><p>判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</p>
</li>
<li><p>用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName</p>
</li>
<li><p>获取需要自动装配的所有配置类，读取META-INF/spring.factories</p>
</li>
</ol>
<p><img src="/2021/09/10/Spring/SpringBoot/wps22.jpg" alt="img"> </p>
<p>不光是这个依赖下的META-INF/spring.factories被读取到，所有 Spring Boot Starter 下的META-INF/spring.factories都会被读取到。所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了META-INF/spring.factories文件。</p>
<ol start="4">
<li><p>spring.factories中这么多配置，每次启动并不是全部加载。需要一遍筛选，@ConditionalOnXXX 中的所有条件都满足，该类才会生效。Spring Boot 提供的条件注解</p>
<ol>
<li><p>@ConditionalOnBean：当容器里有指定 Bean 的条件下</p>
</li>
<li><p>@ConditionalOnMissingBean：当容器里没有指定 Bean 的情况下</p>
</li>
<li><p>@ConditionalOnSingleCandidate：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</p>
</li>
<li><p>@ConditionalOnClass：当类路径下有指定类的条件下</p>
</li>
<li><p>@ConditionalOnMissingClass：当类路径下没有指定类的条件下</p>
</li>
<li><p>@ConditionalOnProperty：指定的属性是否有指定的值</p>
</li>
<li><p>@ConditionalOnResource：类路径是否有指定的值</p>
</li>
<li><p>等</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-版本"><a href="#4-版本" class="headerlink" title="4. 版本"></a>4. 版本</h3><p>2.3.4</p>
<h3 id="5-Springboot如何启动Tomcat"><a href="#5-Springboot如何启动Tomcat" class="headerlink" title="5. Springboot如何启动Tomcat*"></a>5. Springboot如何启动Tomcat*</h3><p>SpringBoot可以把web程序打包成jar包，直接启动，这得益于SpringBoot内置了容器，可以直接启动。</p>
<p>Springboot从main启动</p>
<p>@SpringBootApplication</p>
<p>public class TomcatDebugApplication {</p>
<p>  public static void main(String[] args) {</p>
<p>​    SpringApplication.run(TomcatDebugApplication.class, args);</p>
<p>  }</p>
<p>}</p>
<p>run方法是调用ConfigurableApplicationContext 方法</p>
<ol>
<li><p>配置属性，设置系统属性『java.awt.headless』</p>
</li>
<li><p>获取监听器，发布应用开始启动事件</p>
</li>
<li><p>初始化输入参数</p>
</li>
<li><p>配置环境。创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）；并遍历调用所有的SpringApplicationRunListener的environmentPrepared()方法，广播Environment准备完毕。</p>
</li>
<li><p>输出banner</p>
</li>
<li><p>创建ApplicationContext：<em><strong>*createApplicationContext()*</strong></em></p>
</li>
<li><p>通过SpringFactoriesLoader检索META-INF/spring.factories,获取并实例化异常分析器</p>
</li>
<li><p>prepareContext: </p>
<ol>
<li><p>为ApplicationContext加载environment，之后逐个执行ApplicationContextInitializer的initialize()方法来进一步封装ApplicationContext</p>
</li>
<li><p>调用所有的SpringApplicationRunListener的contextPrepared()方法</p>
</li>
<li><p>初始化IoC容器</p>
</li>
</ol>
</li>
<li><p>刷新<em><strong>*refreshContext(context);在此启动tomcat*</strong>***</em>*容器****</p>
</li>
<li><p>发布应用已经启动事件</p>
</li>
<li><p>发布应用启动完成事件</p>
</li>
</ol>
<p><em><strong>*createApplicationContext()*</strong></em></p>
<p>根据webApplicationType属于哪种类型的Servlet，分类如下：</p>
<ol>
<li><p>SERVLET  Web类型（我们建立的是web类型）</p>
</li>
<li><p>REACTIVE响应式Web类型</p>
</li>
<li><p>default 非Web类型</p>
</li>
</ol>
<p>我们建立的是Web类型，实例化对应的applicationContext。</p>
<p>即实例化DEFAULT_SERVLET_WEB_CONTEXT_CLASS指定的类。</p>
<p>也就是****AnnotationConfigServletWebServerApplicationContext****类</p>
<p>经过各种调用..</p>
<p>到达createWebServer()：启动web服务，但是还没有真正启动Tomcat</p>
<p>​    通过工厂方法TomcatServletWebServerFactory.getWebServer()获得</p>
<p>​        第一件事：把Connnctor对象添加到Tomcat中</p>
<p>第二件事：configureEngine。Engine是容器，上层接口Container</p>
<p>而启动Tomcat就是在第9步的“刷新上下文”</p>
<p>Tomcat的启动主要是初始化2个核心组件：连接器(Connector)和容器（Container）</p>
<p>一个Tomcat实例就是一个Server，一个Server包含多个Service，也就是多个应用程序，每个Service包含多个连接器（Connetor）和一个容器（Container)，而容器下又有多个子容器，按照父子关系分别为：Engine、Host、Context、Wrapper，其中除了Engine外，其余的容器都是可以有多个。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2021/09/10/Spring/SpringMVC/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-MVC是什么"><a href="#1-MVC是什么" class="headerlink" title="1. MVC是什么"></a>1. MVC是什么</h3><p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 **Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)**。</p>
<p>解决了什么问题：将前端页面和后端代码分离，实现了一个请求对应一个方法。</p>
<h3 id="2-工作原理（生命周期）"><a href="#2-工作原理（生命周期）" class="headerlink" title="2. 工作原理（生命周期）*"></a>2. 工作原理（生命周期）*</h3><ol>
<li><p>发起请求到DispatcherServlet (前端控制器)</p>
</li>
<li><p>DispatcherServlet根据请求信息调用HandlerMapping（处理器映射器）查找 Handler（处理器，也就是Controller）</p>
</li>
<li><p>HandlerMapping解析请求对应的Handler，并返回给DispatcherServlet</p>
</li>
<li><p>DispatcherServlet调用HandlerAdapter（处理器适配器）去处理Handler</p>
</li>
<li><p>Handler执行完成后返回ModelAndView给DispatcherServlet。ModelAndView是springmvc框架的一个底层对象，包括 Model和view</p>
</li>
<li><p>DispatcherServlet请求ViewResolver（视图解析器）去进行视图解析；根据逻辑视图名解析成真正的视图(jsp)</p>
</li>
<li><p>ViewResolver向DispatcherServlet返回View</p>
</li>
<li><p>DispatcherServlet进行视图渲染，即将模型数据(在ModelAndView对象中)填充到request域</p>
</li>
<li><p>DispatcherServlet向用户响应结果</p>
</li>
</ol>
<p><img src="/2021/09/10/Spring/SpringMVC/wps20.jpg" alt="img"> </p>
<h3 id="3-拦截器Interceptor"><a href="#3-拦截器Interceptor" class="headerlink" title="3. 拦截器Interceptor"></a>3. 拦截器Interceptor</h3><p>Spring MVC中的拦截器（Interceptor）主要用于<strong>拦截用户请求并作相应的处理</strong>。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。</p>
<p>如何使用：</p>
<ol>
<li><p>编写一个简单的拦截器处理类，实现HandlerInterceptor 接口，该接口包含三个方法：preHandle, postHandle, afterCompletion</p>
</li>
<li><p>将自定义好的拦截器处理类进行注册，并通过addPathPatterns、excludePathPatterns等属性设置需要拦截或需要排除的 URL。</p>
</li>
</ol>
<p>小demo：</p>
<p>自定义拦截器：</p>
<p>public class MyInterceptor implements HandlerInterceptor {</p>
<p>  private static final Logger logger =</p>
<p>  LoggerFactory.getLogger(MyInterceptor.class);</p>
<p>  @Override</p>
<p>  public boolean preHandle(HttpServletRequest request, HttpServletResponse</p>
<p>  response, Object handler) throws Exception {</p>
<p>​    HandlerMethod handlerMethod = (HandlerMethod) handler;</p>
<p>​    Method method = handlerMethod.getMethod();</p>
<p>​    String methodName = method.getName();</p>
<p>​    logger.info(“====拦截到了方法：{}，在该方法执行之前执行====”, methodName);</p>
<p>​    // 返回true才会继续执行，返回false则取消当前请求</p>
<p>​    return true;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void postHandle(HttpServletRequest request, HttpServletResponse</p>
<p>  response, Object handler, ModelAndView modelAndView) throws Exception {</p>
<p>​    logger.info(“执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染”);</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void afterCompletion(HttpServletRequest request, HttpServletResponse</p>
<p>  response, Object handler, Exception ex) throws Exception {</p>
<p>​    logger.info(“整个请求都处理完，DispatcherServlet也渲染了对应的视图，此时可以做一些清理的工作”);</p>
<p>  }</p>
<p>}</p>
<p>配置拦截器：</p>
<p>@Configuration</p>
<p>public class MyInterceptorConfig extends WebMvcConfigurationSupport {</p>
<p>  @Override</p>
<p>  protected void addInterceptors(InterceptorRegistry registry) {</p>
<p>​    // 将上面自定义好的拦截器添加进去。</p>
<p>​    registry.addInterceptor(new MyInterceptor()).addPathPatterns(“/**”);</p>
<p>​    super.addInterceptors(registry);</p>
<p>  }</p>
<p>}</p>
<h3 id="4-过滤器Filter"><a href="#4-过滤器Filter" class="headerlink" title="4. 过滤器Filter"></a>4. 过滤器Filter</h3><p>过滤器的配置比较简单，直接实现Filter 接口即可，也可以通过@WebFilter注解实现对特定URL拦截，看到Filter 接口中定义了三个方法。</p>
<p>init() ：在容器启动初始化过滤器时被调用，它在 Filter 的整个生命周期只会被调用一次。注意：这个方法必须执行成功，否则过滤器会不起作用。</p>
<p>doFilter() ：容器中的每一次请求都会调用该方法， FilterChain 用来调用下一个过滤器 Filter。</p>
<p>destroy()： 当容器销毁过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器 Filter 的整个生命周期也只会被调用一次</p>
<p>@Component</p>
<p>public class MyFilter implements Filter { </p>
<p>  @Override</p>
<p>  public void init(FilterConfig filterConfig) throws ServletException {</p>
<p>​    System.out.println(“Filter 前置”);</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {</p>
<p>​    System.out.println(“Filter 处理中”);</p>
<p>​    filterChain.doFilter(servletRequest, servletResponse);</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void destroy() {</p>
<p>​    System.out.println(“Filter 后置”);</p>
<p>  }</p>
<p>}</p>
<h3 id="5-AOP-拦截器-过滤器"><a href="#5-AOP-拦截器-过滤器" class="headerlink" title="5. AOP 拦截器  过滤器"></a>5. AOP 拦截器  过滤器</h3><ol>
<li><p>访问控制功能的粒度： </p>
<p>AOP：可以配置每个 Controller 的访问权限，访问控制功能要精确到每个请求</p>
<p>Filter和 Interceptor的粒度会粗一些，控制 HttpRequest、HttpResponse 的访问</p>
</li>
<li><p>Spring是否支持：Filter不能够使用 Spring 容器资源；而Interceptor是 Spring 提供的组件，由 Spring 来管理，因此它能使用 Spring 里的任何资源、对象，例如 Service 对象，通过 IoC 注入到 拦截器 中即可。</p>
</li>
<li><p>实现原理：Interceptor则是基于动态代理实现的，Filter是基于函数回调的</p>
</li>
<li><p>使用范围：Interceptor它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，也可以用于Application、Swing等程序中。Filter实现的是 javax.servlet.Filter 接口， 说明Filter 的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。</p>
</li>
<li><p>触发时机不同：Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。</p>
</li>
<li><p>拦截的请求范围不同：Filter几乎可以对所有进入容器的请求起作用，而Interceptor只会对Controller中请求或访问static目录下的资源请求起作用</p>
</li>
</ol>
<p><img src="/2021/09/10/Spring/SpringMVC/wps21.jpg" alt="img"> </p>
<h3 id="6-MVC优点"><a href="#6-MVC优点" class="headerlink" title="6. MVC优点"></a>6. MVC优点</h3><ol>
<li><p>清晰的角色划分：controller、model、DispatcherServlet、handler mapping、view  resolver等，每一个角色都可以由一个专门的对象来实现</p>
</li>
<li><p>强大而直接的配置方式：将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在controller中对业务对象的引用</p>
</li>
<li><p>灵活的model转换：在Springweb框架中，使用基于Map的键/值对来达到轻易的与各种视图技术集成</p>
</li>
<li><p>Spring Bean的生命周期：可以被限制在当前的HTTP Request或者HTTP Session。准确的说，这并非Spring MVC框架本身特性，而应归属于Spring MVC使用的WebApplicationContext容器。</p>
</li>
</ol>
<h3 id="7-Restful编程风格"><a href="#7-Restful编程风格" class="headerlink" title="7. Restful编程风格"></a>7. Restful编程风格</h3><p>****Restful 风格*<em><strong>的 API 是一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。<br>在 Restful 风格中，</strong></em>*用户请求的 url 使用同一个 url 而用请求方式：get，post，delete，put…等方式对请求的处理方法进行区分****，这样可以在前后台分离式的开发中使得前端开发人员不会对请求的资源地址产生混淆和大量的检查方法名的麻烦，形成一个统一的接口。</p>
<p>SpringMVC Restful 风格 url 配置实现的方式<br>SpringMVC 的 resturl 是通过 <a href="https://tieba.baidu.com/home/main?un=RequestMapping&fr=pb&ie=utf-8&id=tb.1.af5ecb0a.Sjn8utRjosObEHsEEHuqlQ">@RequestMapping</a> 及 @PathVariable annotation 提供的，通过如 @RequestMapping(value=”/blog /{id}”,method=RequestMethod.DELETE) 即可处理 /blog/1 的 delete 请求。</p>
<p>GET（SELECT）：从服务器查询，可以在服务器通过请求的参数区分查询的 方式。<br>POST（CREATE）：在服务器端新建一个资源，调用 insert 操作。<br>PUT（UPDATE）：在服务器端更新资源，调用 update 操作。<br>PATCH（UPDATE）：在服务器端更新资源（客户端提供改变的属性）。(目前 jdk7 未实现，tomcat7 不支持)。<br>DELETE（DELETE）：从服务器端删除资源，调用 delete 语句。</p>
<p>摘自：</p>
<p><a href="https://blog.csdn.net/l_blackeagle/article/details/61926695">https://blog.csdn.net/l_blackeagle/article/details/61926695</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>常用注解</title>
    <url>/2021/09/10/Spring/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-常用"><a href="#1-常用" class="headerlink" title="1.常用"></a>1.常用</h3><ol>
<li><p>Spring bean依赖注入</p>
<ol>
<li><p>@Autowired：按照类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false</p>
</li>
<li><p>@Qualifier：按照名称来装配，搭配Autowired使用</p>
</li>
<li><p>@Resource：按照名称装配</p>
</li>
<li><p>@Component,@Repository,@Service, @Controller @RestController</p>
</li>
<li><p>@Configuration注解声明配置类更加语义化，可用@Component代替</p>
</li>
<li><p>@Scope声明 Spring Bean 的作用域：@Scope(“singleton”)</p>
</li>
</ol>
</li>
<li><p>请求</p>
<ol>
<li><p>@RequestMapping：用来处理请求地址映射的注解</p>
</li>
<li><p>@GetMapping请求从服务器获取特定资源</p>
</li>
<li><p>@PostMapping在服务器上创建一个新的资源</p>
</li>
<li><p>@PutMapping更新服务器上的资源（更新整个资源，比如编号12的学生信息）</p>
</li>
<li><p>@DeleteMapping从服务器删除特定的资源</p>
</li>
</ol>
</li>
<li><p>前后端传值</p>
<ol>
<li><p>@PathVariable：用于将请求URL中的模板变量映射到参数上</p>
</li>
<li><p>@RequestParam用于获取查询参数</p>
</li>
<li><p>@RequestBody用于读取请求的 body 部分并且Content-Type 为 application/json 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去</p>
</li>
<li><p>@ResponseBody：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用</p>
</li>
</ol>
</li>
<li><p>事务 </p>
<ol>
<li>@Transactional</li>
</ol>
</li>
<li><p>读取配置信息</p>
<ol>
<li><p>@Value(“${property}”) 读取比较简单的配置信息</p>
</li>
<li><p>@ConfigurationProperties读取配置信息并与 bean 绑定</p>
</li>
<li><p>@PropertySource读取指定 properties 文件</p>
</li>
</ol>
</li>
<li><p>全局处理Controller异常</p>
<ol>
<li><p>@ControllerAdvice :注解定义全局异常处理类</p>
</li>
<li><p>@ExceptionHandler :注解声明异常处理方法</p>
</li>
</ol>
</li>
<li><p>json数据处理</p>
<ol>
<li><p>@JsonIgnoreProperties 作用在类上用于过滤掉特定字段不返回或者不解析</p>
</li>
<li><p>@JsonIgnore一般用于类的属性上，作用和上面的@JsonIgnoreProperties 一样。</p>
</li>
<li><p>@JsonFormat一般用来格式化 json 数据</p>
</li>
<li><p>@JsonUnwrapped 扁平对象</p>
</li>
</ol>
</li>
<li><p>测试</p>
<ol>
<li><p>@ActiveProfiles一般作用于测试类上， 用于声明生效的 Spring 配置文件</p>
</li>
<li><p>@Test声明一个方法为测试方法</p>
</li>
<li><p>@Transactional被声明的测试方法的数据会回滚，避免污染测试数据</p>
</li>
</ol>
</li>
</ol>
<h3 id="2-Autowired-Resource-区别"><a href="#2-Autowired-Resource-区别" class="headerlink" title="2.@Autowired  @Resource 区别*"></a>2.@Autowired  @Resource 区别*</h3><p>@Autowired注解由Spring提供，只按照byType注入</p>
<p>@resource注解由J2EE提供，默认按照byName自动注入</p>
<h3 id="3-Controller-ResponseBody-RestController"><a href="#3-Controller-ResponseBody-RestController" class="headerlink" title="3.@Controller+@ResponseBody=@RestController"></a>3.@Controller+@ResponseBody=@RestController</h3><p>@Controller使用它标记的类就是一个SpringMVC Controller 对象，HandlerMapping会扫描使用了该注解的类的方法</p>
<p>单独使用：返回一个视图，属于比较传统的Spring MVC 的应用，前后端不分离</p>
<p>@ResponseBody ：将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p>
<p>@RestController只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<p>@Controller +@ResponseBody= @RestController</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>修饰类或方法，用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>常用请求注解：</p>
<p>GetMapping PostMapping PutMapping DeleteMapping</p>
<ol>
<li><p>get 请求从服务器获取特定资源</p>
</li>
<li><p>post 在服务器上创建一个新的资源</p>
</li>
<li><p>put 更新服务器上的资源（更新整个资源，比如编号12的学生信息）</p>
</li>
<li><p>delete 从服务器删除特定的资源</p>
</li>
</ol>
<p>常用的参数是什么？</p>
<ol>
<li><p>value：指定请求的实际地址</p>
</li>
<li><p>method：指定请求的method类型， GET、POST、PUT、DELETE等</p>
</li>
<li><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html</p>
</li>
<li><p>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p>
</li>
<li><p>params： 指定request中必须包含某些参数值时，才让该方法处理；适用情况：进一步帮助我们缩小请求映射的定位范围，可以让多个处理方法处理到同一个URL 的请求, 而这些请求的参数是不一样的。</p>
</li>
</ol>
<p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring事务</title>
    <url>/2021/09/10/Spring/Spring%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-Spring-管理事务的方式"><a href="#1-Spring-管理事务的方式" class="headerlink" title="1. Spring 管理事务的方式"></a>1. Spring 管理事务的方式</h3><p>两种方式：</p>
<ol>
<li><p>编程式事务：在代码中硬编码。(不推荐使用) 通过 TransactionTemplate或者TransactionManager手动管理事务，实际应用中很少使用</p>
</li>
<li><p>声明式事务：在配置文件中配置（推荐使用），又分为两种。代码侵入性最小，实际是通过 AOP 实现（基于@Transactional 的注解方式使用最多）</p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
</li>
</ol>
<h3 id="2-Spring事务管理的3个重要接口"><a href="#2-Spring事务管理的3个重要接口" class="headerlink" title="2. Spring事务管理的3个重要接口*"></a>2. Spring事务管理的3个重要接口*</h3><p>源码如何实现的*</p>
<ol>
<li><p><strong>PlatformTransactionManager</strong>：事务管理器，Spring 事务策略的核心</p>
<ol>
<li><p>Spring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是：PlatformTransactionManager 。通过这个接口，Spring 为各个平台如 JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
</li>
<li><p>接口中定义了三个方法：</p>
</li>
</ol>
<p>① 获得事务TransactionStatus getTransaction(TransactionDefinition var1)</p>
<p>② 提交事务commit</p>
<p>③ 回滚事务rollback</p>
</li>
<li><p><strong>TransactionDefinition</strong>：事务属性(事务隔离级别、传播行为、超时、只读、回滚规则)</p>
<ol>
<li><p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上</p>
</li>
<li><p>事务属性包含了 5 个方面：</p>
</li>
</ol>
<p>① 隔离级别</p>
<p>② 传播行为</p>
<p>③ 回滚规则</p>
<p>④ 是否只读</p>
<p>⑤ 事务超时</p>
</li>
<li><p><strong>TransactionStatus</strong>：事务状态</p>
<ol>
<li><p>该接口定义了一组方法,用来获取或判断事务的相应状态信息</p>
</li>
<li><p>接口中的方法：</p>
</li>
</ol>
<p>① isNewTransaction(); // 是否是新的事物</p>
<p>② setRollbackOnly();  // 设置为只回滚</p>
<p>③ isRollbackOnly(); // 是否为只回滚</p>
<p>④ isCompleted; // 是否已完成</p>
<p>⑤ hasSavepoint(); // 是否有恢复点</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>我们可以把 <strong>PlatformTransactionManager 接口可以被看作是事务上层的管理者，而 TransactionDefinition 和 TransactionStatus 这两个接口可以看作是事物的描述。</strong></p>
<p>PlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p>
<h3 id="3-5种事务隔离级别"><a href="#3-5种事务隔离级别" class="headerlink" title="3. 5种事务隔离级别"></a>3. 5种事务隔离级别</h3><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ol>
<li><p>ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，mysql默认采用的 REPEATABLE_READ 隔离级别， Oracle 默认采用的 READ_COMMITTED 隔离级别</p>
</li>
<li><p>ISOLATION_READ_UNCOMMITTED ：导致脏读、幻读、不可重复读</p>
</li>
<li><p>ISOLATION_READ_COMMITTED：导致幻读、不可重复读</p>
</li>
<li><p>ISOLATION_REPEATABLE_READ：导致幻读</p>
</li>
<li><p>ISOLATION_SERIALIZABLE</p>
</li>
</ol>
<h3 id="4-7种事务传播行为"><a href="#4-7种事务传播行为" class="headerlink" title="4. 7种事务传播行为"></a>4. 7种事务传播行为</h3><p><strong>什么是事务传播行为？</strong></p>
<p>事务传播行为是为了解决<strong>业务层方法之间互相调用的事务问题。</strong></p>
<p>事务传播行为用来描述一个事务方法被另一个事务方法调用时，事务如何传播。（内部方法如何传播）</p>
<p>Spring 在 TransactionDefinition 接口中规定了 7 种类型的事务传播行为。</p>
<ol>
<li><p>PROPAGATION_REQUIRED  (<strong>required</strong>)</p>
<ol>
<li><p>如果外部方法没有开启事务的话，required修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
</li>
<li><p>如果外部方法开启事务，并且被required修饰的话，内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。</p>
</li>
</ol>
</li>
<li><p>PROPAGATION_REQUIRES_NEW  <strong>(requires_new)</strong> </p>
<ol>
<li>不管外部方法是否开启事务，requires_new修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>
</ol>
</li>
<li><p>PROPAGATION_NESTED <strong>(nested)</strong> </p>
<ol>
<li><p>在外部方法未开启事务的情况下，nested修饰的内部方法都会新开启自己的事务 </p>
</li>
<li><p>如果外部方法开启事务的话，nested修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。</p>
</li>
</ol>
</li>
<li><p>PROPAGATION_MANDATORY  <strong>(mandatory)</strong></p>
<ol>
<li>如果当前存在事务，加入该事务；如果当前没有事务，则抛出异常</li>
</ol>
</li>
<li><p>PROPAGATION_SUPPORTS <strong>(supports)</strong> </p>
<ol>
<li>如果当前存在事务，加入该事务；如果当前没有事务，则以非事务的方式继续运行</li>
</ol>
</li>
<li><p>PROPAGATION_NOT_SUPPORTED <strong>(not_supported)</strong> </p>
<ol>
<li>以非事务方式运行，如果当前存在事务，则把当前事务挂起</li>
</ol>
</li>
<li><p>PROPAGATION_NEVER <strong>(never)</strong> </p>
<ol>
<li>以非事务方式运行，如果当前存在事务，则抛出异常</li>
</ol>
</li>
</ol>
<h3 id="5-事务超时"><a href="#5-事务超时" class="headerlink" title="5. 事务超时"></a>5. 事务超时</h3><p>就是指<strong>一个事务所允许执行的最长时间</strong>，如果超过该时间限制但事务还没有完成，则自动回滚事务。在TransactionDefinition中以 int 的值来表示超时时间，其单位是秒，默认值为-1.</p>
<h3 id="6-事务只读属性"><a href="#6-事务只读属性" class="headerlink" title="6. 事务只读属性"></a>6. 事务只读属性</h3><p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p>
<h3 id="7-事务回滚"><a href="#7-事务回滚" class="headerlink" title="7. 事务回滚"></a>7. 事务回滚</h3><p>事务回滚规则定义了<strong>哪些异常会导致事务回滚而哪些不会。</strong></p>
<p>默认情况下，事务只有遇到运行期异常和Error 会导致事务回滚，但是，在遇到检查型异常时不会回滚。</p>
<p>如果你想要回滚你定义的特定的异常类型的话，可以这样：</p>
<p>@Transactional(rollbackFor=MyException.class)</p>
<h3 id="8-Transactional"><a href="#8-Transactional" class="headerlink" title="8. @Transactional*"></a>8. @Transactional*</h3><p><strong>作用范围</strong></p>
<ol>
<li><p>方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。</p>
</li>
<li><p>类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</p>
</li>
<li><p>接口 ：不推荐在接口上使用。</p>
</li>
</ol>
<p><em><strong>常用配置参数</strong></em></p>
<p>@Transactional 的常用配置参数总结（只列5 个我平时比较常用的）：</p>
<ol>
<li><p>propagation：事务的传播行为，默认值为 REQUIRED</p>
</li>
<li><p>isolation    事务的隔离级别，默认值采用 DEFAULT</p>
</li>
<li><p>timeout    事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p>
</li>
<li><p>readOnly     指定事务是否为只读事务，默认值为 false。</p>
</li>
<li><p>rollbackFor用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</p>
</li>
</ol>
<p><em><strong>原理</strong>***</em>（基于AOP）***</p>
<p>@Transactional 的工作机制是基于 AOP 实现的。</p>
<p>如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p>
<h3 id="9-Transactional自调用问题"><a href="#9-Transactional自调用问题" class="headerlink" title="9. @Transactional自调用问题"></a>9. @Transactional自调用问题</h3><p>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有@Transactional 注解的方法的事务会失效。</p>
<p>这是由于Spring AOP代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p>
<p>解决办法：避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</p>
<h3 id="10-为什么数据查询操作还要启用事务支持"><a href="#10-为什么数据查询操作还要启用事务支持" class="headerlink" title="10. 为什么数据查询操作还要启用事务支持"></a>10. 为什么数据查询操作还要启用事务支持</h3><p>一次执行多条查询，需要开启事务；只执行一条，不需要开启。</p>
<p>MySQL 默认对每一个新建立的连接都启用了autocommit模式。在该模式下，每一个发送到 MySQL 服务器的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。也就是说：如果你给方法加上了Transactional注解的话，这个方法执行的所有sql会被放在一个事务中；如果不加Transactional，每条sql会开启一个单独的事务。</p>
<p>因此对于数据查询来说，事务是否启用是分场景分情况来考虑的：</p>
<p>① 如果一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</p>
<p>② 如果一次执行多条查询语句，例如统计查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring中的设计模式</title>
    <url>/2021/09/10/Spring/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>以下几种：</p>
<ol>
<li><p>简单工厂：BeanFactory</p>
</li>
<li><p>工厂方法：FactoryBean</p>
</li>
<li><p>单例模式：单例注册表</p>
</li>
<li><p>代理模式：AOP</p>
</li>
<li><p>模板模式</p>
</li>
<li></li>
</ol>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><em><strong>简单工厂</strong></em></h3><p>简单工厂定义：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类</p>
<p>实现： <em><strong>*BeanFactory 接口*</strong></em></p>
<p>是一个管理bean的工厂，有多个实现类。</p>
<p>在<em><strong>*g*</strong>***</em>*etBean(beanName)****方法中，根据传入的参数beanName，动态决定创建哪一个Bean对象。</p>
<p>举例：在ClassPathXmlApplicationContext启动Spring中，使用DefaultListableBeanFactory。</p>
<p>在初始化该BeanFactory时，会加载配置文件，并解析为BeanDefinition，最后将这个beanDefinition注册到BeanFactory中，即将beanName-BeanDefinition放到beanDefinitionMap中。</p>
<p>在初始化单例 bean阶段，会调用getBean(beanName)，先从beanDefinitionMap中获取对应的BeanDefinition，然后进行后面的创建操作。</p>
<p>作用：</p>
<ol>
<li><p>封装创建过程，对调用者透明；适用于创建逻辑比较复杂的，将对象的创建和使用相分离。</p>
</li>
<li><p>代码复用：创建对象的代码可复用</p>
</li>
<li><p>隔离复杂性：调用者无需了解复杂的创建逻辑</p>
</li>
<li><p>职责单一：将创建代码抽离，使原来的函数或类职责更加单一，代码简洁</p>
</li>
</ol>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><em><strong>工厂方法</strong></em></h3><p>工厂方法定义：定义一个创建对象的接口，让其子类决定实例化哪一个工厂类，使对象的创建过程延迟到子类进行。</p>
<p>实现方式：<em><strong>*FactoryBean接口*</strong></em></p>
<p>实现原理：实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是spring会在使用getBean()调用获得该bean时，自动调用该bean的****getObject()****方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p>
<p>例子：典型的例子有spring与mybatis的结合。</p>
<p><img src="/2021/09/10/Spring/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/wps19.png" alt="img"> </p>
<p>sqlSessionFactory因为实现了FactoryBean接口，所以返回的不是 SqlSessionFactoryBean 的实例，而是它的 SqlSessionFactoryBean.getObject() 的返回值。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><em><strong>单例模式</strong></em></h3><p><a href="https://www.cnblogs.com/twoheads/p/9723543.html">https://www.cnblogs.com/twoheads/p/9723543.html</a></p>
<p>单例模式定义： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>Spring框架对单例的支持是采用****单例注册表****的方式实现。原因：一般的将单例类构造方法定义为private是不可继承的。</p>
<p>singletonCache：Bean实例的缓存，作为单例注册表</p>
<ol>
<li><p>先singletonCache.get(beanName)，如果已经注册过，直接返回，否则下一步</p>
</li>
<li><p>加锁synchronized(this.singletonCache)</p>
</li>
<li><p>再次判断如果singletonCache.get(beanName)=null，创建bean，并将这个bean加入map中</p>
</li>
</ol>
<p>public abstract class AbstractBeanFactory implements ConfigurableBeanFactory{   </p>
<p>  private final Map <em><strong>*singletonCache*</strong></em>=new HashMap();   </p>
<p>  public Object getBean(String name)throws BeansException{   </p>
<p>​    return getBean(name,null,null);   </p>
<p>  }   </p>
<p>…   </p>
<p>  public Object getBean(String name,Class requiredType,Object[] args)</p>
<p>throws BeansException{   </p>
<p>   //处理传入的name  </p>
<p>   String beanName=transformedBeanName(name);   </p>
<p>   Object bean=null;   </p>
<p>   //手工检测单例注册表   </p>
<p>   Object sharedInstance=null;   </p>
<p>   //使用了代码锁定同步块，原理和同步方法相似，但是这种写法效率更高   </p>
<p>   <em><strong>*synchronized(this.singletonCache)*</strong></em>{   </p>
<p>​     sharedInstance=this.singletonCache.get(beanName);   </p>
<p>​    }   </p>
<p>   if(sharedInstance!=null){   </p>
<p>​     …   </p>
<p>​     //返回已缓存Bean实例   </p>
<p>​     bean=getObjectForSharedInstance(name,sharedInstance);   </p>
<p>   }else{   </p>
<p>​    …   </p>
<p>​    //取得Bean的定义   </p>
<p>​    RootBeanDefinition mergedBeanDefinition=getMergedBeanDefinition(beanName,false);   </p>
<p>​     …   </p>
<p>​    //根据Bean定义判断，如果是单例  </p>
<p>​    if(mergedBeanDefinition.isSingleton()){   </p>
<p>​      <em><strong>*synchronized(this.singletonCache)*</strong></em>{   </p>
<p>​      //再次检测单例注册表   </p>
<p>​       sharedInstance=this.singletonCache.get(beanName);   </p>
<p>​       if(sharedInstance==null){   </p>
<p>​        …   </p>
<p>​        try {   </p>
<p>​         //真正创建Bean实例   </p>
<p>​         sharedInstance=createBean(beanName,mergedBeanDefinition,args);   </p>
<p>​         //向单例注册表注册Bean实例   </p>
<p>​          <em><strong>*addSingleton(beanName,sharedInstance);*</strong></em>   </p>
<p>​        }catch (Exception ex) {   </p>
<p>​         …   </p>
<p>​        }finally{   </p>
<p>​         …   </p>
<p>​       }   </p>
<p>​       }   </p>
<p>​      }   </p>
<p>​     bean=getObjectForSharedInstance(name,sharedInstance);   </p>
<p>​    }   </p>
<p>​    //如果是非单例</p>
<p>​    else{   </p>
<p>​     bean=createBean(beanName,mergedBeanDefinition,args);   </p>
<p>​    }   </p>
<p>}   </p>
<p>…   </p>
<p>  return bean;   </p>
<p>}   </p>
<p>}</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><em><strong>代理模式</strong></em></h3><p>定义：在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<p>动态代理：不事先为每个原始类编写代理类，而是在运行时，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p>作用：与大业务代码解耦；保证业务类职责单一</p>
<p>实现方式：AOP底层，就是****动态代理****模式的实现。</p>
<h3 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a><em><strong>模版方法</strong></em></h3><p>定义：在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>
<p>Spring模板方法模式实质：是****模板方法模式和回调模式的结合****，Spring几乎所有的外接扩展都采用这种模式。</p>
<p>JDBC：</p>
<p>具体实现：JDBC的抽象和对Hibernate的集成，都采用了一种理念或者处理方式，那就是模板方法模式与相应的Callback接口相结合。</p>
<p>解决问题：</p>
<ol>
<li><p>复用。把算法中不变的流程抽象到父类的模板方法中，将可变部分留给子类来实现。所有子类复用父类模板方法中定义的流程代码。</p>
</li>
<li><p>扩展。不是指代码的扩展性，而是功能扩展，使框架用户可以不修改框架源码的情况下，定制化框架的功能。</p>
</li>
</ol>
<p>引入回调原因：</p>
<p>JdbcTemplate是抽象类，不能够独立使用，我们每次进行数据访问的时候都要给出一个相应的子类实现,这样肯定不方便，所以就引入了回调。</p>
<p>回调代码</p>
<p>Public interface StatementCallback{</p>
<p>  Object doWithStatement（Statement stmt）;</p>
<p>}</p>
<p>JdbcTemplate方法：</p>
<p>Public class JdbcTemplate {</p>
<p>  Public final Object execute（StatementCallback callback）{</p>
<p>​    Connection con=null;</p>
<p>​    Statement stmt=null;</p>
<p>​    try{</p>
<p>​      con=getConnection（）;</p>
<p>​      stmt=con.createStatement（）;</p>
<p>​      Object retValue=callback.doWithStatement（stmt）;</p>
<p>​      return retValue;</p>
<p>​    }catch（SQLException e）{</p>
<p>​      …</p>
<p>​    }finally{</p>
<p>​      closeStatement（stmt）;</p>
<p>​      releaseConnection（con）;</p>
<p>​    }</p>
<p>  }</p>
<p>  …//其它方法定义</p>
<p>}</p>
<p>Jdbc使用方法如下：</p>
<p>  JdbcTemplate jdbcTemplate=…;</p>
<p>  final String sql=…;</p>
<p>  StatementCallback callback=new StatementCallback(){</p>
<p>  public Object=doWithStatement(Statement stmt){</p>
<p>​    return …;</p>
<pre><code>    &#125;
</code></pre>
<p>  }</p>
<p>jdbcTemplate.execute(callback);</p>
<p>模板模式：基于继承实现，子类重写父类方法，是一种类之间的关系。</p>
<p>回调：基于组合关系实现，把一个对象传递给另一个对象，是一种对象之间的关系。组合优于继承。更加灵活。优势如下：</p>
<ol>
<li><p>类只能单继承</p>
</li>
<li><p>回调可以使用匿名类创建回调函数</p>
</li>
<li><p>某个类中有多个模板方法，每个方法都有对应的抽象方法，如果我们只用到一个模板方法，子类必须实现所有的抽象方法。回调更加灵活，只需要将需要的模板方法注入回调对象即可。</p>
</li>
</ol>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><em><strong>观察者模式</strong></em></h3><p>发布订阅模式</p>
<p>定义：在对象之间定义一个一对多的依赖，当一个对象（被观察者）状态改变时，所有依赖的对象（观察者）都会自动收到通知。</p>
<p>将观察者和被观察者的代码解耦。</p>
<p>事件的发布者（ApplicationEventPublisher）</p>
<p>事件类型（ApplicationEvent）</p>
<p>事件广播器（ApplicationEventMulticaster）：该类是整个观察者的核心，接收发布者的事件推送并选择适当的事件监听器进行事件的准确分发。</p>
<p>事件监听器（ApplicationListener）：该组件为观察者对象，由用户自行实现其void onApplicationEvent(E event)方法，定制业务逻辑。</p>
<p>导出项目中基于spring观察者模式的应用：</p>
<p>需求：在application初始化完成后，将事件类型和事件处理器映射存储到map中。方便Consumer中根据EventType调用不同的EventHandler，比如导出事件调用ExportHandler。</p>
<p>这样设计的作用：可扩展。</p>
<p>事件处理器接口EventHandler</p>
<p>导出事件实现EventHandler，定义为：ExportHandler</p>
<p>导入事件实现EventHandler，定义为：ImportHandler</p>
<p>具体设计：</p>
<ol>
<li><p>在Consumer类实现ApplicationListener<ApplicationReadyEvent>接口，并实现其onApplicationEvent方法，在完成ApplicationReadyEvent后，触发onApplicationEvent方法中的自定义的逻辑</ApplicationReadyEvent></p>
</li>
<li><p>Consumer类实现ApplicationContextAware，用来得到applicationContext，从中可获得EventHandler的所有bean</p>
</li>
<li><p>在onApplicationEvent中，从applicationContext中获取所有EventHandler的bean，将type和bean的映射存储到map中</p>
</li>
</ol>
<p>代码：</p>
<p>@Component</p>
<p>public class EventConsumer implements ApplicationContextAware, ApplicationListener<ApplicationReadyEvent> {</ApplicationReadyEvent></p>
<p>  private ApplicationContext applicationContext;</p>
<p>  private static final Map&lt;EventType, List<EventHandler>&gt; config = new HashMap&lt;&gt;();</EventHandler></p>
<p>  @Override</p>
<p>  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {</p>
<p>​    this.applicationContext = applicationContext;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) {</p>
<p>​    //初始化所有的事件</p>
<p>​    //获取所有EventHandler的实现类</p>
<p>​    Map&lt;String, EventHandler&gt; beans = applicationContext.getBeansOfType(EventHandler.class);</p>
<p>​    for (Map.Entry&lt;String, EventHandler&gt; entry : beans.entrySet()) {</p>
<p>​      List<EventType> types = entry.getValue().getSupportEventTypes();</EventType></p>
<p>​      for (EventType type : types) {</p>
<p>​        if(!config.containsKey(type)){</p>
<p>​          config.put(type, new ArrayList&lt;&gt;());</p>
<p>​        }</p>
<p>​        //一种事件类型对应多个处理类</p>
<p>​        config.get(type).add(entry.getValue());</p>
<p>​      }</p>
<p>​    }</p>
<p>}</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><em><strong>适配器模式</strong></em></h3><p>实现方式：SpringMVC中的适配器HandlerAdatper</p>
<p>实现原理：HandlerAdatper根据Handler规则找到对应的Handler，并让其执行。Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样再扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</p>
<p>实现意义：HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。</p>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a><em><strong>装饰器模式</strong></em></h3><p>定义：</p>
<ol>
<li><p>使用组合代替继承</p>
</li>
<li><p>装饰器类是对原始类功能相关的增强</p>
</li>
<li><p>装饰器类和原始类继承同样的父亲，这样可以对原始类嵌套多个装饰器类。</p>
</li>
</ol>
<p>实现方式：Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<p>实质：动态地给一个对象添加一些额外的职责。</p>
<p>摘自：</p>
<p><a href="https://zhuanlan.zhihu.com/p/114244039">https://zhuanlan.zhihu.com/p/114244039</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring容器的启动流程</title>
    <url>/2021/09/10/Spring/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="S-pring-容器的启动流程"><a href="#S-pring-容器的启动流程" class="headerlink" title="S***pring***容器的启动流程"></a><em><strong>S</strong>***</em>pring***<em><strong>容器的启动流程</strong></em></h3><p>spring容器的启动方式有很多种： </p>
<ol>
<li><p>xml的方式，入口为ClassPathXmlApplicationContext（从类路径中加载xml文件）或FileSystemXmlApplicationContext（从指定文件地址加载xml文件）</p>
</li>
<li><p>Java Config，基于注解中的方式，入口为AnnotationConfigApplicationContext</p>
</li>
</ol>
<h3 id="xml方式（源码分析）"><a href="#xml方式（源码分析）" class="headerlink" title="xml方式（源码分析）"></a>xml方式（源码分析）</h3><p><a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
<p>整个流程的大致过程：初始化BeanFactory；加载xml配置文件；将beanDefinition注册到beanFactory；创建bean（创建bean实例；属性填充；各种回调）</p>
<p>启动Spring容器，入口：</p>
<p>public static void main(String[] args) {</p>
<p>  ApplicationContext context </p>
<p>= new <em><strong>*ClassPathXmlApplicationContext*</strong></em>(“classpath:applicationfile.xml”);</p>
<p>}</p>
<p>maven中添加spring-context依赖，spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>
<p>从ClassPathXmlApplicationContext构造方法开始：</p>
<ol>
<li><p>处理文件路径</p>
</li>
<li><p>refresh()</p>
</li>
</ol>
<p>refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作</p>
<ol>
<li><p>prepareRefresh() 做一些准备工作，比如记录下容器的启动时间、标记“已启动”状态、检验xml配置文件</p>
</li>
<li><p>初始化BeanFactory，加载配置文件，并解析为BeanDefinition，最后将这个beanDefinition注册到BeanFactory中，这一步并不会生成Bean实例。ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</p>
<p><strong>1)</strong> <em><strong>初始化</strong>***</em>BeanFactory***，DefaultListableBeanFactory，这基本上是最厉害的BeanFactory</p>
<ol start="2">
<li>设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用customizeBeanFactory();</li>
</ol>
<p><strong>3)</strong> <strong>加载</strong>loadBeanDefinitions();通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean</p>
<p><strong>4)</strong> <em><strong>解析</strong></em>parseBeanDefinitions(root, this.delegate)核心解析方法</p>
<p><strong>5)</strong> <em><strong>注册</strong></em>registerBeanDefinition(String beanName, BeanDefinition beanDefinition)注册Bean，将beanName-BeanDefinition放到beanDefinitionMap中；把beanName添加到ArrayList&lt;&gt; beanDefinitionNames中</p>
<ol start="6">
<li>发送注册事件</li>
</ol>
</li>
<li><p>准备Bean容器prepareBeanFactory(beanFactory); </p>
<ol>
<li><p>设置 BeanFactory 的类加载器</p>
</li>
<li><p>添加****ApplicationContextAwareProcessor*<em><strong>，如果bean在初始化时实现了</strong></em>*Aware接口****，这个processor负责回调，回调ApplicationContextAware、EnvironmentAware、ResourceLoaderAware 等（导出项目中，EventConsumer实现了ApplicationContextAware接口，来获取ApplicationContext，从中获取EventHandler中的所有bean）</p>
</li>
<li><p>添加ApplicationListenerDetector，用来注册监听事件，如果bean实例化后，是ApplicationListener 的子类，那么将其添加到 listener 列表中</p>
</li>
<li><p>注册几个有用的bean：environment、systemProperties、systemEnvironment</p>
</li>
</ol>
</li>
<li><p>postProcessBeanFactory(beanFactory); 提供给子类的扩展点，此时所有的 Bean 都加载、注册完成了，但是都还没有初始化，子类可以在这里定义自己的BeanFactoryPostProcessor实现类</p>
</li>
<li><p>调用 <em><strong>*BeanFactoryPostProcessor*</strong></em> 各个实现类的 postProcessBeanFactory() 方法invokeBeanFactoryPostProcessors(beanFactory); </p>
</li>
<li><p>注册自定义的<em><strong>*BeanPostProcessor*</strong></em> ，registerBeanPostProcessors(beanFactory);，这个接口包含两个方法，分别在Bean初始化前、后执行</p>
</li>
<li><p>初始化国际化initMessageSource();初始化当前 ApplicationContext 的 MessageSource </p>
</li>
<li><p>初始化当前 ApplicationContext 的事件广播器initApplicationEventMulticaster();</p>
</li>
<li><p>onRefresh();典型的模板方法(钩子方法)，具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</p>
</li>
<li><p>registerListeners();注册事件监听器，监听器需要实现 ApplicationListener 接口</p>
</li>
</ol>
<p><strong>11.</strong> <em><strong>*初始化所有的*</strong></em> <em><strong>*singleton bean*</strong></em> ：finishBeanFactoryInitialization(beanFactory); </p>
<p>​    </p>
<ol start="12">
<li>finishRefresh();广播事件，ApplicationContext 初始化完成</li>
</ol>
<p><em><strong>*createBeanInstance*</strong></em>(beanName, mbd, args)</p>
<p>作用：实例化指定的类</p>
<ol>
<li><p>确保已经加载了此 class</p>
</li>
<li><p>校验一下这个类的访问权限</p>
</li>
<li><p>如果是FactoryBean，则采用工厂方法实例化；否则继续</p>
</li>
<li><p>根据args，调用无参构造函数、或者有参构造函数创建实例</p>
</li>
</ol>
<p><em><strong>*initializeBean*</strong></em>(beanName, exposedObject, mbd);</p>
<p>处理各种回调；init方法</p>
<ol>
<li><p>如果 bean 实现了 <em><strong>BeanNameAware</strong></em>、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</p>
</li>
<li><p>**** <em><strong>BeanPostProcessor</strong></em> 的 postProcessBeforeInitialization 回调</p>
</li>
<li><p>处理 bean 中定义的 ****init-method****，或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</p>
</li>
</ol>
<p><strong>4.</strong> <em><strong>BeanPostProcessor</strong></em> 的 postProcessAfterInitialization 回调</p>
<h3 id="Java-Config方式"><a href="#Java-Config方式" class="headerlink" title="Java Config方式"></a>Java Config方式</h3><p><a href="https://blog.csdn.net/qq_35190492/article/details/110383213">https://blog.csdn.net/qq_35190492/article/details/110383213</a></p>
<p>如何设计一个IOC容器：</p>
<ol>
<li><p>提供入口AnnotationConfigApplicationContext，供用户使用，然后初始化一些工具组件，如下：</p>
</li>
<li><p>bean工厂（DefaultListableBeanFactory），用来生成bean对象</p>
</li>
<li><p>注解配置读取器（AnnotatedBeanDefinitionReader），对加了特定注解比如@Service、@Repository的类读取转化为BeanDefinition对象</p>
</li>
<li><p>路径扫描器（ClassPathBeanDefinitionScanner），对用户指定的包目录进行扫描查找 bean 对象</p>
</li>
<li></li>
</ol>
<p><img src="/2021/09/10/Spring/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/wps18.png" alt="img"> </p>
<p>第一步：new AnnotationConfigApplicationContext() 创建Spring容器，有参的构造方法如下，分为三步：</p>
<ol>
<li><p>通过this()调用无参构造方法，分为三步</p>
<ol>
<li><p>先执行父类GenericApplicationContext的初始化方法，实例化一个DefaultListableBeanFactory</p>
</li>
<li><p>实例化AnnotatedBeanDefinitionReader，registerAnnotationConfigProcessors()</p>
</li>
</ol>
<p>① 向容器中添加2个beanFactory后置处理器</p>
<ol>
<li><p>ConfigurationClassPostProcessor: 一个 beanFactory 后置处理器，用来完成 bean 的扫描与注入工作</p>
</li>
<li><p>EventListenerMethodProcessor</p>
</li>
</ol>
<p>② 向容器中添加2个bean后置处理器</p>
<ol>
<li><p>AutowiredAnnotationBeanPostProcessor：一个 bean 后置处理器，用来完成 @AutoWired 自动注入</p>
</li>
<li><p>CommonAnnotationBeanPostProcessor</p>
</li>
</ol>
<p>③ 向容器中添加普通组件：DefaultEventListenerFactory</p>
<ol start="3">
<li>实例化ClassPathBeanDefinitionScanner</li>
</ol>
</li>
<li><p>调用register(componentClasses); 注册传入的配置类，可以是多个类。最终调用doRegisterBean()，用来解析用户传入的 Spring 配置类，解析成一个 BeanDefinition 然后注册到容器中。</p>
</li>
</ol>
<p>\3. 调用refresh() 容器刷新，这是spring的核心方法</p>
<p>刷新流程</p>
<ol>
<li><p>prepareRefresh() 刷新前预处理</p>
</li>
<li><p>obtainFreashBeanFactory（）获取beanFactory，前面已经初始化过</p>
</li>
<li><p>prepareBeanFactory() 预处理beanFactory，向容器中添加一些组件</p>
</li>
<li><p>postProcessBeanFactory() 子类重写这个方法，可以在beanFactor</p>
</li>
<li><p>执行BeanFactoryPostProcessor方法</p>
</li>
<li><p>向容器中注册bean后置处理器</p>
</li>
<li><p>初始化MessageSource组件：国际化、消息绑定与解析</p>
</li>
<li><p>初始化事件派发器，在注册监听时会用到</p>
</li>
<li><p>onRefresh() 留给子类重写，在容器刷新时，可以自定义逻辑，web场景下会用到</p>
</li>
<li><p>registerListeners() 注册监听器，派发之前产生的一些事件</p>
</li>
<li><p>初始化所有bean</p>
</li>
<li><p>finishRefresh() 刷新完成，发布容器</p>
</li>
</ol>
<p>public AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses) {</p>
<p>​        this();</p>
<p>​        register(componentClasses);</p>
<p>​        refresh();</p>
<p>​    }</p>
<h3 id="测试demo"><a href="#测试demo" class="headerlink" title="测试demo"></a>测试demo</h3><p><a href="https://www.jianshu.com/p/52b988e02c37">https://www.jianshu.com/p/52b988e02c37</a></p>
<p><em><strong>*配置*</strong></em></p>
<p><em><strong>*XML方式：*</strong></em></p>
<p>&lt;context:component-scan base-package=”com.me.xml”/&gt;</p>
<p>@Component</p>
<p>public class OneBean {</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>  ApplicationContext context </p>
<p>= new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>
<p>  OneBean bean = context.getBean(“oneBean”,OneBean.class);</p>
<p>  System.out.println(bean);</p>
<p>}</p>
<p><em><strong>*Java*</strong></em> <em><strong>*Config*</strong></em></p>
<p>@Configuration：标注了该注解的类是一个Spring的配置类,等价于原先的applicationContext.xml</p>
<p>@ComponentScan ：启动该注解，表明开启Spring的注解自动扫描 , 默认情况下,扫描当前类所在包及其子包</p>
<p>代码如下：</p>
<p>@Configuration </p>
<p>@ComponentScan </p>
<p>public class Config {</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>  ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);</p>
<p>  OneBean oneBean = context.getBean(OneBean.class);</p>
<p>  System.out.println(oneBean);</p>
<p>}</p>
<p>创建bean</p>
<bean id="oneBena" class="com.me.xml.OneBean">

<p>@Configuration</p>
<p>public class Config {</p>
<p>  @Bean // 表明这是一个Spring 管理的bean</p>
<p>  public OneBean oneBean() {</p>
<p>​    // 显然,这个Bean的CLass 是OneBean.class</p>
<p>​    // 在spring 中,bean的 id 是不能重复的,而现在使用java config来代替xml配置</p>
<p>​    // 在java config 方法名就是这个bean的id</p>
<p>​    return new OneBean();</p>
<p>  }</p>
<p>}</p>
</bean>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Bean的生命周期</title>
    <url>/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-Spring创建bean的流程图"><a href="#1-Spring创建bean的流程图" class="headerlink" title="1. Spring创建bean的流程图"></a>1. <em>Spring创建bean的流程图</em></h3><p><img src="/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/wps15.png" alt="img"> </p>
<h3 id="2-Spring-Bean的生命周期"><a href="#2-Spring-Bean的生命周期" class="headerlink" title="2. Spring Bean的生命周期"></a>2. Spring Bean的生命周期</h3><p>四个阶段（在核心方法doCreateBean中）：</p>
<ol>
<li><p>实例化Instantiation，创建bean实例</p>
</li>
<li><p>属性赋值Populate</p>
</li>
<li><p>初始化Initialization，执行init方法</p>
</li>
<li><p>销毁Destruction</p>
</li>
</ol>
<p>初始化和销毁是用户能自定义扩展的两个阶段。</p>
<p>加入扩展点的流程图：</p>
<p><img src="/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/wps16.jpg" alt="img"> </p>
<p>扩展点：</p>
<ol>
<li><p>Bean自身的方法，比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，对应这四个阶段</p>
</li>
<li><p>容器级的方法。主要是后处理器方法，比如下图的 InstantiationAwareBeanPostProcessor、BeanPostProcessor 接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用</p>
</li>
<li><p>Bean 级生命周期方法。比如 BeanNameAware、BeanFactoryAware、ApplicationContextAware、InitializingBean、DisposableBean 等方法，这些方法只对当前 Bean 生效。</p>
</li>
</ol>
<p><img src="/2021/09/10/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/wps17.jpg" alt="img"> </p>
<p>摘自：</p>
<p><a href="https://blog.csdn.net/riemann_/article/details/118500805">https://blog.csdn.net/riemann_/article/details/118500805</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Bean相关接口</title>
    <url>/2021/09/10/Spring/Bean%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="1-BeanFactoryPostProcessor"><a href="#1-BeanFactoryPostProcessor" class="headerlink" title="1. BeanFactoryPostProcessor"></a>1. <em><strong>BeanFactoryPostProcessor</strong></em></h3><p>接口，只有一个方法postProcessBeanFactory</p>
<p>如果实现了此接口，那么会在所有的 Bean 都加载、注册到BeanFactory，但是都还没有初始化时，Spring 会负责调用里面的 postProcessBeanFactory 方法</p>
<p>@FunctionalInterface</p>
<p>public interface BeanFactoryPostProcessor {</p>
<p>  void <em><strong>*postProcessBeanFactory*</strong></em>(ConfigurableListableBeanFactory var1) </p>
<p>throws BeansException;</p>
<p>}</p>
<h3 id="2-BeanPostProcessor"><a href="#2-BeanPostProcessor" class="headerlink" title="2. BeanPostProcessor"></a>2. <em><strong>BeanPostProcessor</strong></em></h3><p>此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</p>
<p>分别在 Bean 初始化之前和初始化之后得到执行</p>
<p>public interface BeanPostProcessor {</p>
<p>  @Nullable</p>
<p>  default Object <em><strong>*postProcessBeforeInitialization*</strong></em>(Object bean, String beanName) throws BeansException {</p>
<p>​    return bean;</p>
<p>  }</p>
<p>  @Nullable</p>
<p>  default Object <em><strong>*postProcessAfterInitialization*</strong></em>(Object bean, String beanName) throws BeansException {</p>
<p>​    return bean;</p>
<p>  }</p>
<p>}</p>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a><em><strong>BeanDefinition</strong></em></h3><p>自己定义的各个 Bean 会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p>
<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>
<p>Bean是什么？Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p>
<p>public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {</p>
<p>  // 我们可以看到，默认只提供 sington 和 prototype 两种，</p>
<p>  // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</p>
<p>  // 不过，它们属于基于 web 的扩展。</p>
<p>  String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</p>
<p>  String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</p>
<p>  // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</p>
<p>  // 一句话就是：继承父 Bean 的配置信息而已</p>
<p>  void setParentName(String parentName);</p>
<p>  // 获取父 Bean</p>
<p>  String getParentName();</p>
<p>  // 设置 Bean 的类名称，将来是要通过反射来生成实例的</p>
<p>  void setBeanClassName(String beanClassName);</p>
<p>  // 获取 Bean 的类名称</p>
<p>  String getBeanClassName();</p>
<p>  // 设置 bean 的 scope</p>
<p>  void setScope(String scope);</p>
<p>  // 设置是否懒加载</p>
<p>  void setLazyInit(boolean lazyInit);</p>
<p>  // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</p>
<p>  // 是 depends-on=”” 属性设置的值。</p>
<p>  void setDependsOn(String… dependsOn);</p>
<p>  // 返回该 Bean 的所有依赖</p>
<p>  String[] getDependsOn();</p>
<p>  // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</p>
<p>  // 如果根据名称注入，即使这边设置了 false，也是可以的</p>
<p>  void setAutowireCandidate(boolean autowireCandidate);</p>
<p>  // 该 Bean 是否可以注入到其他 Bean 中</p>
<p>  boolean isAutowireCandidate();</p>
<p>  // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</p>
<p>  void setPrimary(boolean primary);</p>
<p>  // 是否是 primary 的</p>
<p>  boolean isPrimary();</p>
<p>  // 如果该 Bean 采用工厂方法生成，指定工厂名称。即有些实例不是用反射生成的，而是用工厂模式生成的</p>
<p>  void setFactoryBeanName(String factoryBeanName);</p>
<p>  // 获取工厂名称</p>
<p>  String getFactoryBeanName();</p>
<p>  // 指定工厂类中的 工厂方法名称</p>
<p>  void setFactoryMethodName(String factoryMethodName);</p>
<p>  // 获取工厂类中的 工厂方法名称</p>
<p>  String getFactoryMethodName();</p>
<p>  // 构造器参数</p>
<p>  ConstructorArgumentValues getConstructorArgumentValues();</p>
<p>  // Bean 中的属性值，后面给 bean 注入属性值的时候会说到</p>
<p>  MutablePropertyValues getPropertyValues();</p>
<p>  // 是否 singleton</p>
<p>  boolean isSingleton();</p>
<p>  // 是否 prototype</p>
<p>  boolean isPrototype();</p>
<p>  // 如果这个 Bean 是被设置为 abstract，那么不能实例化，</p>
<p>  // 常用于作为 父bean 用于继承，其实也很少用……</p>
<p>  boolean isAbstract();</p>
<p>  int getRole();</p>
<p>  String getDescription();</p>
<p>  String getResourceDescription();</p>
<p>  BeanDefinition getOriginatingBeanDefinition();</p>
<p>}</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>IOC</title>
    <url>/2021/09/10/Spring/Spring%20IOC/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-IOC是什么"><a href="#1-IOC是什么" class="headerlink" title="1. IOC是什么"></a>1. IOC是什么</h3><p>Inversion of control，控制反转，是一种设计思想。在Java开发中，IoC意味着将设计好的对象交由容器控制，而不是传统的在你的对象内部控制。从以下几个方面理解IoC:</p>
<ol>
<li><p>谁控制谁？ IoC容器控制对象</p>
</li>
<li><p>控制什么？控制了外部资源的获取（对象、文件）</p>
</li>
<li><p>为什么是反转？传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，即正转；这里的反转是指由容器帮我们查找及注入依赖对象，对象只是被动的接收依赖对象。</p>
</li>
<li><p>反转了什么？依赖对象的获取被反转了。</p>
</li>
</ol>
<h3 id="2-Spring中的IOC"><a href="#2-Spring中的IOC" class="headerlink" title="2. Spring中的IOC"></a>2. <em>Spring中的IOC</em></h3><p>IoC是Spring的核心。对于Spring来说，IoC就是Spring来负责控制对象的生命周期和对象间的关系。Spring倡导的开发方式是：所有的类在Spring容器中登记，告诉Spring你是什么，需要什么，然后Spring会在系统运行到适当的时候，把你需要的东西交给你。所有类的创建、销毁都是由Spring来控制，而不是引用它的对象。</p>
<p>​    IoC的重点是：在系统运行中，动态的向某个对象提供它所需要的其他对象。这是通过DI来实现的。而DI是通过反射实现的。</p>
<h3 id="3-DI-IOC"><a href="#3-DI-IOC" class="headerlink" title="3. DI IOC"></a>3. DI IOC</h3><p>dependency injection依赖注入。</p>
<p>IOC容器动态地将某个对象注入应用程序中，这个对象是应用程序依赖的对象。</p>
<p>由IOC容器动态的将某个依赖关系注入到组件之中。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。从以下几个方面理解DI：</p>
<ol>
<li><p>谁依赖谁？应用程序依赖IoC容器</p>
</li>
<li><p>为什么需要依赖？应用程序需要IoC容器提供对象需要的外部资源</p>
</li>
<li><p>谁注入谁？IoC容器注入应用程序某个对象，即应用程序依赖的对象</p>
</li>
<li><p>注入了什么？注入了应用程序需要的外部资源（对象、资源、常量数据）</p>
</li>
</ol>
<p>DI和IoC的关系：是对同一个概念不同角度的描述。由于控制反转概念比较含糊，之后又提出了新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
<p>IoC描述了容器控制对象这一层面，DI描述了被注入对象依赖IoC容器配置依赖对象。</p>
<h3 id="4-IOC作用"><a href="#4-IOC作用" class="headerlink" title="4. IOC作用"></a>4. IOC作用</h3><p>好处：解耦，便于测试，利于功能复用，整个体系结构灵活</p>
<p>IoC对于编程从思想上，发生了主从换位的变化，应用程序原本是最大的，即要获取什么资源都是应用程序主动去获取的，但是在IoC的思想中，应用程序变成了被动，被动的等待IoC容器注入它需要的资源。</p>
<h3 id="5-Spring-IoC的循环依赖问题"><a href="#5-Spring-IoC的循环依赖问题" class="headerlink" title="5. Spring IoC的循环依赖问题"></a>5. Spring IoC的循环依赖问题</h3><h4 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a><em>是什么：</em></h4><p>循环依赖其实是循环引用，也就是两个或则两个以上的 bean 互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。</p>
<h4 id="产生循环依赖的三种场景："><a href="#产生循环依赖的三种场景：" class="headerlink" title="产生循环依赖的三种场景："></a>产生循环依赖的三种场景：</h4><ol>
<li><p>构造器的循环依赖：项目启动时报错some of beans in the application context form a circle</p>
</li>
<li><p>field 属性的循环依赖prototype：同上</p>
</li>
<li><p>field 属性的循环依赖：项目启动成功，尽管有循环依赖，但bean 可以被成功初始化</p>
</li>
</ol>
<h4 id="单例bean如何解决循环依赖问题："><a href="#单例bean如何解决循环依赖问题：" class="headerlink" title="单例bean如何解决循环依赖问题："></a>单例bean如何解决循环依赖问题：</h4><p>解决办法：<em><strong>三级缓存</strong></em></p>
<p>具体来说：</p>
<p>假设A中注入属性B，B中注入属性A：</p>
<ol>
<li><p>初始化A：A第一次初始化缓存中没有，使用反射初始化，此时并不会触发B的初始化</p>
</li>
<li><p>将初始化完成，但尚未填充属性的A加入三级缓存</p>
</li>
<li><p>开始A的属性填充，获取B的bean，触发B的初始化</p>
</li>
<li><p>初始化B：B第一次初始化缓存中没有，使用反射初始化</p>
</li>
<li><p>将初始化完成，但尚未填充属性的B加入三级缓存</p>
</li>
<li><p>开始B的属性填充，获取A的bean</p>
</li>
<li><p>A属于第二次初始化，直接从三级缓存中拿到之前存储的值，直接返回</p>
</li>
</ol>
<h4 id="为什么构造器无法解决循环依赖问题"><a href="#为什么构造器无法解决循环依赖问题" class="headerlink" title="为什么构造器无法解决循环依赖问题"></a>为什么构造器无法解决循环依赖问题</h4><p>单例的bean：反射初始化bean-写入三级缓存-填充属性</p>
<p>Prototype、构造器：在写入缓存之前执行构造方法，进行初始化，导致并没有存入三级缓存，发生死循环，spring抛出异常。</p>
<h4 id="为什么prototype无法解决"><a href="#为什么prototype无法解决" class="headerlink" title="为什么prototype无法解决"></a>为什么prototype无法解决</h4><p>prototypeBean会在创建之前将正在创建的Bean Name放入一个Set中，在循环依赖时检查beanName是否处于创建状态。</p>
<h4 id="如何检查循环依赖的"><a href="#如何检查循环依赖的" class="headerlink" title="如何检查循环依赖的"></a>如何检查循环依赖的</h4><p>根据Bean的状态给Bean进行mark，无论是构造注入还是属性值注入，第二次进入初始化同一个bean时（即调用getBean(A)方法时），如果发现bean当时正在创建中，那么抛出循环依赖的异常即可。</p>
<h4 id="三级缓存是什么？"><a href="#三级缓存是什么？" class="headerlink" title="三级缓存是什么？"></a><em>三级缓存是什么？</em></h4><p>一级缓存Map&lt;String, Object&gt; singletonObjects：保存所有的singletonBean的实例</p>
<p>二级缓存Map&lt;String, Object&gt; earlySingletonObjects：保存所有早期创建的Bean对象，这个Bean还没有完成依赖注入 </p>
<p>三级缓存Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories： singletonBean的生产工厂</p>
<p>Set<String> registeredSingletons：保存所有已经完成初始化的Bean的名字</String></p>
<p>Set<String> singletonsCurrentlyInCreation：标识指定name的Bean对象是否处于创建状态  </String></p>
<h4 id="Bean依赖注入的过程："><a href="#Bean依赖注入的过程：" class="headerlink" title="Bean依赖注入的过程："></a><em>Bean依赖注入的过程：</em></h4><ol>
<li><p>Bean实例化，即调用对象的构造方法进行实例化，使用反射和cglib</p>
</li>
<li><p>填充属性，设置bean对象的依赖关系，对依赖对象进行填充</p>
</li>
</ol>
<p>具体报错如下：</p>
<ol>
<li><p>构造器的循环依赖</p>
<p>代码：</p>
<p>@Service</p>
<p>public class A {</p>
<p>  public A(B b) {  }</p>
<p>}</p>
<p>@Service</p>
<p>public class B {</p>
<p>  public B(C c) {</p>
<p>  }</p>
<p>}</p>
<p>@Service</p>
<p>public class C {</p>
<p>  public C(A a) {  }</p>
<p>}</p>
<p>报错：some of beans in the application context form a circle.</p>
<p><img src="/2021/09/10/Spring/Spring%20IOC/IOC/wps12.png" alt="img"> </p>
</li>
<li><p>Field属性的循环依赖</p>
<p>代码：</p>
<p>@Service</p>
<p>public class A1 {</p>
<p>  @Autowired</p>
<p>  private B1 b1;</p>
<p>}</p>
<p>@Service</p>
<p>public class B1 {</p>
<p>  @Autowired</p>
<p>  public C1 c1;</p>
<p>}</p>
<p>@Service</p>
<p>public class C1 {</p>
<p>  @Autowired  public A1 a1;</p>
<p>}</p>
<p>结果：项目启动成功</p>
</li>
<li><p>Field属性注入循环依赖prototype</p>
<p>代码：</p>
<p>@Service</p>
<p>@Scope(“prototype”)</p>
<p>public class A1 {</p>
<p>  @Autowired</p>
<p>  private B1 b1;</p>
<p>}</p>
<p>@Service</p>
<p>@Scope(“prototype”)</p>
<p>public class B1 {</p>
<p>  @Autowired</p>
<p>  public C1 c1;</p>
<p>}</p>
<p>@Service</p>
<p>@Scope(“prototype”)</p>
<p>public class C1 {</p>
<p>  @Autowired  public A1 a1;</p>
<p>}</p>
<p>结果：项目启动失败，发现了一个cycle。同第一种。</p>
</li>
</ol>
<p>总结：构造器注入和prototype类型的属性注入都会初始化Bean失败，但单例的属性注入是可以成功的。</p>
<h3 id="6-bean-依赖注入方式（xml）"><a href="#6-bean-依赖注入方式（xml）" class="headerlink" title="6. bean 依赖注入方式（xml）"></a>6. bean 依赖注入方式（xml）</h3><p>在Spring中，共有四种方式为bean的属性注入值，分别是：</p>
<p>构造器、 set方法、静态工厂、实例工厂</p>
<h4 id="构造器注入："><a href="#构造器注入：" class="headerlink" title="构造器注入："></a><em>构造器注入：</em></h4><p>通过<strong>constructor-arg标签</strong>为构造器传入参数值</p>
<p>public class Car {</p>
<p>  String name;</p>
<p>  String brand;</p>
<p>  public void setName(String name) {</p>
<p>​    this.name = name;</p>
<p>  }</p>
<p>  public void setBrand(String brand) {</p>
<p>​    this.brand = brand;</p>
<p>  }</p>
<p>  public Car() {</p>
<p>  }</p>
<p>  public Car(String name, String brand) {</p>
<p>​    this.name = name;</p>
<p>​    this.brand = brand;</p>
<p>  }</p>
<p>  public void drive() {</p>
<p>​    System.out.println(brand + “ “ + name + “ is running”);</p>
<p>  }</p>
<p>}   </p>
<p>定义bean.xml文件：</p>
<bean id="car" class="com.juliajiang.aopdemo.bean.Car">

<p>​    <constructor-arg name="brand" value="BMW"></constructor-arg></p>
<p>​    <constructor-arg name="name" value="Jack"></constructor-arg></p>
  </bean>

<p>测试：</p>
<p>  @Test</p>
<p>  void testCar() {</p>
<p>​    ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p>
<p>​    Car car = (Car)context.getBean(“car”);</p>
<p>​    car.drive();</p>
<p>  }</p>
<p>输出：</p>
<p>BMW Jack is running</p>
<h4 id="set方法注入："><a href="#set方法注入：" class="headerlink" title="set方法注入："></a>set方法注入：</h4><p>Spring容器就是通过调用<strong>bean的set方法为属性注入值</strong>的。而在xml文件中，使用set注入的方式就是通过<strong>property标签</strong>。</p>
  <bean id="car2" class="com.juliajiang.aopdemo.bean.Car">

<p>​    <property name="brand" value="aodi"></property></p>
<p>​    <property name="name" value="julia"></property></p>
  </bean>

<p>  @Test</p>
<p>  void testCar2() {</p>
<p>​    ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p>
<p>​    Car car = (Car)context.getBean(“car2”);</p>
<p>​    car.drive();</p>
<p>  }</p>
<p>输出：</p>
<p>aodi julia is running</p>
<h4 id="静态工厂注入"><a href="#静态工厂注入" class="headerlink" title="静态工厂注入"></a><em>静态工厂注入</em></h4><p>编写一个静态的工厂方法，这个工厂方法会返回一个我们需要的值，然后在配置文件中，我们指定使用这个工厂方法（<strong>factory-method标签</strong>）创建bean</p>
<p>public class CarFactory {</p>
<p>  public static Car staticCreateCar(){</p>
<p>​    return new Car(“benchi”, “jennie”);</p>
<p>  }</p>
<p>}</p>
  <bean id="car3" class="com.juliajiang.aopdemo.bean.CarFactory" factory-method="staticCreateCar">

  </bean>

<p>  @Test</p>
<p>  void testCar3() {</p>
<p>​    ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p>
<p>​    Car car = (Car)context.getBean(“car3”);</p>
<p>​    car.drive();</p>
<p>  }</p>
<h4 id="实例工厂注入"><a href="#实例工厂注入" class="headerlink" title="实例工厂注入"></a><strong><strong>实例工厂注入</strong></strong></h4><p><strong>需要有一个实例对象</strong>，才能调用它的工厂方法</p>
<p>public class CarFactory {</p>
<p>  public Car createCar(){</p>
<p>​    return new Car(“benchi”, “jennie”);</p>
<p>  }</p>
<p>}</p>
<p>  <bean id="carFactory" class="com.juliajiang.aopdemo.bean.CarFactory"></bean></p>
<p>  <bean id="car4" factory-bean="carFactory" factory-method="createCar"></bean></p>
<p>  @Test</p>
<p>  void testCar4() {</p>
<p>​    ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p>
<p>​    Car car = (Car)context.getBean(“car4”);</p>
<p>​    car.drive();</p>
<p>  }</p>
<h3 id="7-bean-依赖注入方式（Java-Config）"><a href="#7-bean-依赖注入方式（Java-Config）" class="headerlink" title="7. bean 依赖注入方式（Java Config）"></a>7. bean 依赖注入方式（Java Config）</h3><p><a href="https://www.jianshu.com/p/52b988e02c37">https://www.jianshu.com/p/52b988e02c37</a></p>
<p>通过Java Config创建bean有以下几种方式：</p>
<ol>
<li><p>构造器</p>
</li>
<li><p>静态工厂</p>
</li>
<li><p>实例工厂</p>
</li>
<li><p>通过FactoryBean创建</p>
</li>
</ol>
<p>Spring自动扫描组件：</p>
<p><em><strong>@Configuration</strong></em> </p>
<p>//标注了该注解的类是一个Spring的配置类,等价于原先的applicationContext.xml</p>
<p><em><strong>@ComponentScan</strong></em> </p>
<p>//开启Spring的注解自动扫描 , 默认情况下,扫描当前类所在包及其子包</p>
<p>public class Config {</p>
<p>}public static void main(String[] args) {</p>
<p>  ApplicationContext context </p>
<p>= new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>
<p>  OneBean bean = context.getBean(“oneBean”,OneBean.class);</p>
<p>  System.out.println(bean);</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>  ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);</p>
<p>  OneBean oneBean = context.getBean(OneBean.class);</p>
<p>  System.out.println(oneBean);</p>
<p>}</p>
<p><em><strong>构造器创建bean</strong></em></p>
<p>@Configuration</p>
<p>public class Config {</p>
<p>  <em><strong>@Bean</strong></em></p>
<p>  public OneBean oneBean() {</p>
<p>​    // 显然,这个Bean的CLass 是OneBean.class</p>
<p>​    // 在spring 中,bean的 id 是不能重复的,而现在使用java config来代替xml配置</p>
<p>​    // 在java config 方法名就是这个bean的id</p>
<p>​    return new OneBean();</p>
<p>  }</p>
<p>}</p>
<p><em><strong>静态工厂</strong></em></p>
<p>public class OneBeanFactory {</p>
<p>  public static OneBean getOneBean() {</p>
<p>​    return new OneBean();</p>
<p>  }</p>
<p>}</p>
<p>@Configuration</p>
<p>public class Config {</p>
<p>  <em><strong>@Bean</strong></em></p>
<p>  public OneBean oneBean1() {</p>
<p>​    return <em><strong>*OneBeanFactory.getOneBean();*</strong></em></p>
<p>  }</p>
<p>}</p>
<p><em><strong>实例工厂</strong></em></p>
<p>public class OneBeanFactory {</p>
<p>  public OneBean getOneBean() {</p>
<p>​    return new OneBean();</p>
<p>  }</p>
<p>}</p>
<p>@Configuration</p>
<p>public class Config {</p>
<p>  <em><strong>@Bean</strong></em></p>
<p>  public OneBean oneBean2() {</p>
<p>​    return <em><strong>*new OneBeanFactory().getOneBean();*</strong></em></p>
<p>  }</p>
<p>}</p>
<p><em><strong>通过</strong>***</em>FactoryBean***<em><strong>创建</strong></em></p>
<p>public class OneBeanFactory implements <em><strong>*FactoryBean<OneBean>*</OneBean></strong></em> {</p>
<p>  @Override</p>
<p>  public OneBean getObject() throws Exception {</p>
<p>​    return new OneBean();</p>
<p>  }</p>
<p>  @Override</p>
<p>  public Class&lt;?&gt; getObjectType() {</p>
<p>​    return OneBean.class;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public boolean isSingleton() {</p>
<p>​    return true;</p>
<p>  }</p>
<p>}</p>
<p>@Configuration</p>
<p>public class Config {</p>
<p>  /**</p>
<p>   * OneBeanFactory 类实现了 Spring的 FactoryBean 接口,</p>
<p>   * Spring 知道这个类是用来创建 OneBean 对象的,</p>
<p>   * <em><strong>*方法虽然返回了 OneBeanFactory , 但是Spring 会帮我们用这个类来创建 OneBean*</strong></em></p>
<p>   */</p>
<p>  <em><strong>*@Bean*</strong></em></p>
<p>  public OneBeanFactory oneBean() {</p>
<p>​    return <em><strong>*new OneBeanFactory();*</strong></em></p>
<p>  }</p>
<p>  public static void main(String[] args) {</p>
<p>​    ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);</p>
<p>​    OneBean oneBean = context.getBean(“oneBean”, OneBean.class);</p>
<p>​    System.out.println(oneBean);</p>
<p>​    // 通过 “&amp;”的方式获取对应的Factory</p>
<p>​    OneBeanFactory oneBeanFactory </p>
<p>= context.getBean(“<em><strong>*&amp;oneBean*</strong></em>“, OneBeanFactory.class);</p>
<p>​    System.out.println(oneBeanFactory);</p>
<p>  }</p>
<p>}</p>
<h3 id="8-bean的作用域"><a href="#8-bean的作用域" class="headerlink" title="8. bean的作用域"></a>8. bean的作用域</h3><ol>
<li><p>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的</p>
</li>
<li><p>prototype : 每次请求都会创建一个新的 bean 实例</p>
</li>
<li><p>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效</p>
</li>
<li><p>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效</p>
</li>
<li><p>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</p>
</li>
</ol>
<h3 id="9-单例-Bean的线程安全问题"><a href="#9-单例-Bean的线程安全问题" class="headerlink" title="9. 单例 Bean的线程安全问题"></a>9. 单例 Bean的线程安全问题</h3><p>的确是存在安全问题的。因为，当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。</p>
<p>但是，一般情况下，我们常用的 Controller、Service、Dao 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</p>
<p><strong>常见的有 2 种解决办法：</strong></p>
<ol>
<li><p>在类中定义一个 <strong>ThreadLocal</strong> 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）</p>
</li>
<li><p>改变 Bean 的作用域为 “<strong>prototype</strong>”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</p>
</li>
</ol>
<h3 id="10-Component-Bean"><a href="#10-Component-Bean" class="headerlink" title="10. @Component  @Bean"></a>10. @Component  @Bean</h3><ol>
<li><p>作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法</p>
</li>
<li><p>作用不同：</p>
</li>
<li><p>@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。</p>
</li>
<li><p>@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的实例，当我需要用它的时候还给我</p>
</li>
<li><p>@Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</p>
</li>
</ol>
<h3 id="11-注入的接口有多个实现类"><a href="#11-注入的接口有多个实现类" class="headerlink" title="11. 注入的接口有多个实现类"></a>11. 注入的接口有多个实现类</h3><p>在TestController中注入接口testRepository：</p>
<p>@Controller</p>
<p>public class TestController {</p>
<p>  @Autowired</p>
<p>  TestRepository testRepository;</p>
<p>}</p>
<p>但接口testRepository有两个实现类：TestRepositoryImpl1 TestRepositoryImpl2</p>
<p>启动项目时会报错：</p>
<p>Field testRepository in com.juliajiang.aopdemo.employee.controller.TestController required a single bean, but 2 were found:</p>
<p>​    - testRepositoryImp2: defined in file [E:… repository\impl\TestRepositoryImp2.class]</p>
<p>​    - testRepositoryImpl1: defined in file [E:… repository\impl\TestRepositoryImpl1.class]</p>
<p><strong>@Autowired 的注入方式是 byType</strong> 注入， 当要注入的类型在容器中存在多个时，Spring是不知道要引入哪个实现类的，所以会报错。</p>
<p>这种场景下，只能通过 <strong>byName 注入</strong>的方式：</p>
<ol>
<li><p><strong>@Resource 默认是按照 byName</strong> 的方式注入的， 如果通过 byName 的方式匹配不到，再按 byType 的方式去匹配。name参数指定@Service注解中标定的名字，如果不指定会将testRepository作为类名，这样会报错找不到。</p>
<p>@Controller</p>
<p>public class TestController {</p>
<p>  <em><strong>@Resource(name = “testRepositoryImpl1”)</strong></em></p>
<p>  TestRepository testRepository;</p>
<p>}</p>
</li>
<li><p><strong>@Qualifier和@Autowired</strong>配合使用</p>
<p>@Controller</p>
<p>public class TestController {</p>
<p>  @Autowired</p>
<p>  @Qualifier(“testRepositoryImp2”)</p>
<p>  TestRepository testRepository;</p>
<p>}</p>
</li>
</ol>
<p>摘自：</p>
<p><a href="https://www.cnblogs.com/xdp-gacl/p/4249939.html">https://www.cnblogs.com/xdp-gacl/p/4249939.html</a></p>
<p><a href="https://www.jianshu.com/p/52b988e02c37">https://www.jianshu.com/p/52b988e02c37</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring框架</title>
    <url>/2021/09/10/Spring/Spring%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="1-什么是Spring"><a href="#1-什么是Spring" class="headerlink" title="1. 什么是Spring"></a>1. <em><strong>什么是Spring</strong></em></h3><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：<a href="https://spring.io/%E3%80%82">https://spring.io/。</a></p>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<p>Spring 官网列出的 Spring 的 6 个特征:</p>
<ol>
<li><p>核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</p>
</li>
<li><p>测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient</p>
</li>
<li><p>数据访问 ：事务，DAO支持，JDBC，ORM，编组XML</p>
</li>
<li><p>Web支持 : Spring MVC和Spring WebFlux Web框架</p>
</li>
<li><p>集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存</p>
</li>
<li><p>语言 ：Kotlin，Groovy，动态语言。</p>
</li>
</ol>
<h3 id="2-Spring的重要模块"><a href="#2-Spring的重要模块" class="headerlink" title="2. Spring的重要模块"></a><em><strong>2. Spring的重要模块</strong></em></h3><p>Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</p>
<p>Spring Aspects ： 该模块为与AspectJ的集成提供支持。</p>
<p>Spring AOP ：提供了面向切面的编程实现。</p>
<p>Spring JDBC : Java数据库连接。</p>
<p>Spring JMS ：Java消息服务。</p>
<p>Spring ORM : 用于支持Hibernate等ORM工具。</p>
<p>Spring Web : 为创建Web应用程序提供支持。</p>
<p>Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2021/09/10/Java/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-面向对象-面向过程"><a href="#1-面向对象-面向过程" class="headerlink" title="1. 面向对象 面向过程"></a>1. 面向对象 面向过程</h3><h4 id="（1）面向对象"><a href="#（1）面向对象" class="headerlink" title="（1）面向对象"></a>（1）面向对象</h4><p>面向对象：编程范式</p>
<p>类和对象作为组织代码的基本单元</p>
<p><strong>四大特性：</strong></p>
<ol>
<li><p>封装：类通过暴露有限的访问接口，授权外部仅通过类提供的函数来访问内部数据。</p>
<p>作用：保护数据不被随意修改，提高可维护性；仅暴露有限接口，提高类的易用性</p>
</li>
<li><p>抽象：隐藏方法的具体实现，使用者只需要关心方法提供了哪些功能，不需要知道这些功能如何实现</p>
<p>作用：代码可维护性，修改实现不需要改变定义；过滤不需要关注的信息</p>
</li>
<li><p>继承</p>
<p>作用：代码复用</p>
</li>
<li><p>多态：父类的引用指向子类的实例</p>
</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li><p>模块化：提供一个更清晰的模块化结构，使得程序可以更好地定义抽象数据类型，抽象数据类型隐藏了实现细节并且提供了清晰的接口</p>
</li>
<li><p>可伸缩：将开发者加到项目往往很容易，因为他们不需要理解整个项目的代码，只需要理解与他们工作相关的那些代码。增加硬件资源可以被更有效地利用，因为你可以为每个模块分配不同的资源</p>
</li>
<li><p>可维护：可以更容易地维护和修改现有代码，因为新对象可以与现有对象有些许不同</p>
</li>
<li><p>可拓展：提供一个更好的框架来通过库拓展项目，而这些组件可以很容易地被程序员修改和调整，这在用户界面和图形界面开发中尤其有用</p>
</li>
<li><p>代码可复用：各模块与其他模块相互独立，这可以让你提取出一个功能，比如用户登录，在其他项目中使用</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><p>现实世界很难被完整地划分为类和子类</p>
</li>
<li><p>有时候多个对象会以复杂地形式交互，甚至在写程序地时候都无法预期到</p>
</li>
<li><p>对于小项目或只需要几个简单任务地项目来说，会徒增代码量和复杂度</p>
</li>
<li><p>性能下降，这是最激烈地讨论之一，虽然一个设计良好地面向过程站点性能会比设计良好地面向对象站点高，但是仍然有许多因素需要考虑，这不应该是你主要关心地问题</p>
</li>
</ol>
<h4 id="（2）面向过程"><a href="#（2）面向过程" class="headerlink" title="（2）面向过程"></a>（2）面向过程</h4><p><strong>优点</strong>：</p>
<ol>
<li><p>功能通过一个个函数编写，小程序可以很简单地实现</p>
</li>
<li><p>易于维护，每一个过程和函数可以被单独调试</p>
</li>
<li><p>如果是为一个非常特定地目的编写代码，常常可以使程序获得更高地效率和性能</p>
</li>
<li><p>代码更加灵活，你可以随意更改整个程序中地特定部分</p>
</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>代码量变大时，面向过程地代码越来越难以维护</p>
</li>
<li><p>当项目变大，全局变量会越来越多，会带来严重的后果，特别是多个程序员在一个大项目中协同作业时</p>
</li>
<li><p>代码相互依赖，导致代码无法在其他程序复用，而面向对象编程却可以</p>
</li>
<li><p>与现实世界中的对象没有关联</p>
</li>
<li><p>改动一块代码会牵连到其他代码</p>
</li>
<li><p>代码量变大时，会更加难易理解和修改</p>
</li>
<li><p>难以将代码迁移到其他程序</p>
</li>
</ol>
<h4 id="（3）-什么时候面向对象"><a href="#（3）-什么时候面向对象" class="headerlink" title="（3） 什么时候面向对象"></a>（3） 什么时候面向对象</h4><p>当程序代码量很小时，面向过程编程可以更快更简洁地实现，并且可维护性和可阅读性都不错。</p>
<p>而当程序为一个代码量大且复杂的模块化项目，并且有多个程序员或团队协同作业时，使用面向对象编程可以让你更好地划分和组织代码，在让程序更快、更简洁的同时，也能保持可维护性和可阅读性。</p>
<p><strong>面向对象编程最适合在以下情况使用：</strong></p>
<ol>
<li><p>你有多个程序员并且各自不需要了解每个组件</p>
</li>
<li><p>有许多复用和共享地代码</p>
</li>
<li><p>项目经常变动并且之后不断新增功能</p>
</li>
<li><p>不同模块服务于不同数据源或硬件</p>
</li>
</ol>
<p><strong>面向过程编程最适合在以下情况使用</strong>：</p>
<ol>
<li><p>一个非常复杂的操作包括几个相互依赖的操作并且需要不同程序间的状态清晰可见，通常是程序的启动和关闭</p>
</li>
<li><p>程序非常特殊，并且由几个元素共享</p>
</li>
<li><p>程序是静态的，并且之后不会经常改动</p>
</li>
<li><p>项目结束后没有或只有很少的一些功能需要添加到项目中</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>常用的集合总结</title>
    <url>/2021/09/10/Java/%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-什么是集合？特点？"><a href="#1-什么是集合？特点？" class="headerlink" title="1.什么是集合？特点？"></a>1.<strong>什么是集合？特点？</strong></h3><p>集合是：用于存储对象的容器。</p>
<p>集合框架是为表示和操作集合而规定的一种统一的标准的统一结构。任何集合框架都包含三部分内容：对外的接口、接口的实现、对集合运算的算法。</p>
<p>特点：</p>
<ol>
<li><p>集合用于存储对象</p>
</li>
<li><p>可变长度，对象个数不确定时使用集合，确定时可使用数组</p>
</li>
</ol>
<h3 id="2-集合和数组的区别？"><a href="#2-集合和数组的区别？" class="headerlink" title="2.集合和数组的区别？"></a>2.<em><strong>集合和数组的区别？</strong></em></h3><ol>
<li><p>长度是否固定</p>
</li>
<li><p>数组可存储基本数据类型、引用数据类型；集合只能存储引用数据类型（如果存储基本类型，可以直接存，系统会自动装箱变成包装器类型）</p>
</li>
<li><p>数组中存储的元素必须是同一数据类型；集合可以是不同的（定义List<Object>，所有类都继承Object）</Object></p>
</li>
</ol>
<h3 id="3-常用的集合类"><a href="#3-常用的集合类" class="headerlink" title="3.常用的集合类"></a>3.<em><strong>常用的集合类</strong></em></h3><p>Map和Collection是所有集合框架的父接口。</p>
<ol>
<li><p>Collection接口的子接口包括：Set、List、Queue</p>
</li>
<li><p>List接口的实现类：ArrayList、LinkedList、Vector、Stack</p>
</li>
<li><p>Set接口的实现类：HashSet、TreeSet、LinkedHashSet</p>
</li>
<li><p>Queue接口的实现类：ArrayDeque；Queue接口的子接口：Deque</p>
</li>
<li><p>Map接口的实现类：HashMap、TreeMap、HashTable、ConcurrentHashMap</p>
</li>
</ol>
<h3 id="4-List，Set，Map三者的区别？"><a href="#4-List，Set，Map三者的区别？" class="headerlink" title="4.List，Set，Map三者的区别？"></a>4.<em><strong>List，Set，Map三者的区别？</strong></em></h3><p><a href="https://blog.csdn.net/bingocoder/article/details/80258683">https://blog.csdn.net/bingocoder/article/details/80258683</a></p>
<ol>
<li><p>List：（注重顺序存储）特点：有序，可重复</p>
</li>
<li><p>Set：不同的实现类有不同的特性：</p>
<p>① HashSet：无序，不可重复</p>
<p>② TreeSet：保证元素的自然顺序，也可自定义排序</p>
<p>③ LinkedHashSet：保证元素的添加顺序</p>
</li>
<li><p>Map：（键值对，key搜索快）特点：键值对存储，key是无序、不可重复的，value是无序、可重复的</p>
</li>
</ol>
<h3 id="5-底层数据结构总结"><a href="#5-底层数据结构总结" class="headerlink" title="5.底层数据结构总结"></a>5.<em><strong>底层数据结构总结</strong></em></h3><ol>
<li><p>List</p>
<p><strong>1)</strong> ****ArrayList****：Object[] 数组    线程不安全</p>
<ol start="2">
<li><p>Vector：Object[] 数组 线程安全 古老</p>
</li>
<li><p>Stack：Object[] 数组，继承了Vector</p>
</li>
<li><p>LinkedList</p>
</li>
</ol>
<p>i. 底层数据结构：双端链表。实现List和Deque接口。</p>
<p>ii. 自定义Node节点，其中包含next和prev节点。</p>
<p>private static class Node<E> {</E></p>
<p>​    E item;</p>
<p>​    Node<E> next;</E></p>
<p>​    Node<E> prev;</E></p>
<p>iii. 自定义属性  transient Node<E> first;和transient Node<E> last;指定链表头结点和尾结点。</E></E></p>
</li>
<li><p>Set</p>
<ol>
<li>HashSet</li>
</ol>
<p>i. 底层数据结构：基于HashMap实现的，底层使用HashMap来存储元素</p>
<p>ii. 在HashSet中，元素都存到HashMap键值对的Key上面，而Value是一个虚拟的Object对象，并且是static final的。</p>
<p>iii. 可存储null值</p>
<ol start="2">
<li><p>LinkedHashSet：HashSet的子类，内部通过LinkedHashMap实现，支持添加顺序访问。</p>
</li>
<li><p>TreeSet：红黑树（自平衡的排序二叉树），可按照添加顺序访问，支持自然排序和定制排序</p>
</li>
</ol>
</li>
<li><p>Map</p>
<ol>
<li><p><em>HashMap</em>：数组+链表/红黑树 详解</p>
</li>
<li><p>LinkedHashMap：继承HashMap，底层在数组+链表/红黑树的基础上，增加了双向链表，保证插入的顺序。</p>
</li>
<li><p>HashTable：数组+链表</p>
</li>
<li><p>TreeMap：红黑树（自平衡的排序二叉树）</p>
</li>
</ol>
</li>
</ol>
<h3 id="6-ArrayList"><a href="#6-ArrayList" class="headerlink" title="6. ArrayList"></a>6. <em><strong>ArrayList</strong></em></h3><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p>transient Object[] elementData; //Object数组存储数据</p>
<p>默认初始容量10</p>
<h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><ol>
<li><p>先调用ensureCapacityInternal方法：ensureCapacityInternal(size + 1)</p>
<ol>
<li><p>获取默认容量和size+1较大值，作为最小需要容量</p>
</li>
<li><p>modCount++</p>
</li>
<li><p>如果最小容量大于数组长度，调用grow()进行扩容</p>
</li>
</ol>
</li>
<li><p>为数组赋值：elementData[size++] = e</p>
</li>
</ol>
<h3 id="7-LinkedList"><a href="#7-LinkedList" class="headerlink" title="7. LinkedList"></a>7. <em><strong>LinkedList</strong></em></h3><p>双向链表，可以被当作堆栈、队列或双端队列进行操作。</p>
<p>定义head、tail节点，指向链表的首尾节点。</p>
<p>自定义带有pre、next的Node节点，存储数据。</p>
<p>添加元素，添加到last节点之后。</p>
<p>  public boolean add(E e) {</p>
<p>​    linkLast(e);</p>
<p>​    return true;</p>
<p>  }</p>
<h3 id="8-ArrayList和LinkedList的区别"><a href="#8-ArrayList和LinkedList的区别" class="headerlink" title="8. ArrayList和LinkedList的区别"></a>8. <em><strong>ArrayList和LinkedList的区别</strong></em></h3><ol>
<li><p>底层数据结构：Arraylist 底层使用的是 Object 数组；LinkedList 底层使用双向链表</p>
</li>
<li><p>是否支持快速随机访问：LinkedList 不支持高效的随机元素访问，而 ArrayList 支持</p>
</li>
<li><p>直接插入或删除add(E e)：ArrayList 默认在将指定的元素追加末尾O(1)；LinkedList为O(1)</p>
</li>
<li><p>指定位置插入或删除add(int index, E element)：ArrayList为O(n) LinkedList为O(n)</p>
</li>
<li><p>内存空间占用：ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）</p>
</li>
<li><p>是否保证线程安全： ArrayList 和 LinkedList 都不是线程安全；可以使用Collections类的List list=Collections.synchronizedList(new LinkedList(…));</p>
</li>
</ol>
<h3 id="9-CopyOnWriteArrayList"><a href="#9-CopyOnWriteArrayList" class="headerlink" title="9. CopyOnWriteArrayList"></a>9. <em><strong>CopyOnWriteArrayList</strong></em></h3><p>CopyOnWriteArrayList是ArrayList的线程安全版本，JUC下的一个类。</p>
<p>有写操作的时候会copy一份数据，然后写完再设置成新的数据。</p>
<p>适用于读多写少的并发场景</p>
<p>CopyOnWriteArraySet是线程安全版本的Set实现，它的内部通过一个CopyOnWriteArrayList来代理读写等操作。</p>
<p>如何保证线程安全：</p>
<p>数据存储在Object[]中，定义为volatile保证可见性。</p>
<p>使用了ReentrantLock来支持并发操作，当add元素时，先加lock，保证只有一个线程修改数组数据。然后拷贝当前数据，在最后一个位置插入数据。最后将新的数组赋值给原数组，返回即可。</p>
<p>get(i)时直接返回对应下标的数据，因为有volatile保证可见性。</p>
<h3 id="10-RandomAccess接口"><a href="#10-RandomAccess接口" class="headerlink" title="10. RandomAccess接口"></a>10. <em><strong>RandomAccess接口</strong></em></h3><ol>
<li><p>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。</p>
</li>
<li><p>作用：标识实现这个接口的类具有随机访问功能。而不是说因为实现了RandomAccess接口而具有随机访问的特性。</p>
</li>
<li><p>应用：在Collections的binarySearch方法中，它要判断传入的 list 是否 RamdomAccess 的实例，如果是，调用indexedBinarySearch()方法，如果不是，那么调用iteratorBinarySearch()方法。</p>
</li>
<li><p>ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合容器</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2021/09/10/Java/ConcurrentHashMap/</url>
    <content><![CDATA[<h3 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1. 底层数据结构"></a>1. 底层数据结构</h3><p><strong>JDK1.7</strong>： segment数组+HashEntry数组+链表</p>
<p><strong>JDK1.8</strong>：Node数组+链表/红黑树，当链表长度达到一定长度时，转为红黑树。</p>
<p>volatile Node&lt;K,V&gt;[] table;</p>
<p>  static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</p>
<p>​    final int hash;</p>
<p>​    final K key;</p>
<p>​    volatile V val;</p>
<p>​    volatile Node&lt;K,V&gt; next;</p>
<h3 id="2-1-7如何实现线程安全"><a href="#2-1-7如何实现线程安全" class="headerlink" title="2. 1.7如何实现线程安全"></a>2. 1.7如何实现线程安全</h3><ol>
<li><p>数据结构：segment数组+HashEntry数组+链表</p>
</li>
<li><p>初始化：依次对segment数组和HashEntry数组进行初始化</p>
</li>
<li><p>put：</p>
<p>① 两次hash映射去定位数据存储的位置。第一次hash过程，定位segment位置；第二次hash过程，定位HashEntry位置</p>
<p>② Segment继承ReentrantLock，在数据插入指定的HashEntry过程的时候会尝试调用ReentrantLock的tryLock方法获取锁，如果获取成功就直接插入相应位置，如果已有线程获得该Segment的锁，当前线程就会以自旋方式去继续调用tryLock方法去获取锁，超过指定次数就挂起，等待唤醒。</p>
</li>
<li><p>get：两次hash映射过程，相对于put，少了加锁过程</p>
</li>
<li><p>size：即计算ConcurrentHashMap的大小，有两种方案：</p>
<p>① 给每个Segment都加上锁(相当于给整个Map加上锁)，然后计算size返回</p>
<p>② 不加锁的模式，尝试多次计算ConcurrentHashMap的size，最多三次，比较前后计算的结果，结果一致就认为当前没有元素加入，计算结果是准确的</p>
</li>
</ol>
<h3 id="3-1-8如何实现线程安全"><a href="#3-1-8如何实现线程安全" class="headerlink" title="3. 1.8如何实现线程安全"></a>3. 1.8如何实现线程安全</h3><p>put：synchronized+CAS自旋</p>
<p>get：volatile</p>
<p>initTable：CAS自旋+volatile</p>
<h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>执行过程：</p>
<ol>
<li><p>如果key或value为Null，抛出NullPointerException结束（ConCurrentHashMap不允许存放null型的key和value，这点和HashMap也不同）</p>
</li>
<li><p>如果数组为null或为空，调用initTable()初始化</p>
</li>
<li><p>根据key计算hash值，根据hash值计算下标位置，如果该位置为空，利用CAS尝试写入元素，如果失败，通过自旋保证写入成功</p>
</li>
<li><p>判断是否需要扩容，如果是，则执行helpTransfer方法</p>
</li>
<li><p>如果下标位置有值，则利用synchronized锁来写入元素，分为写入链表或红黑树</p>
</li>
</ol>
<p>\6. 最后，调用addCount函数，执行CAS操作，更新数组大小；并判断是否需要扩容</p>
<p>如何保证线程安全：CAS+synchronized</p>
<h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><ol>
<li><p>根据key计算hash值</p>
</li>
<li><p>查找到指定位置，如果该位置非空，则下一步</p>
</li>
<li><p>如果头节点就是要找的，直接返回它的 value，否则，下一步</p>
</li>
<li><p>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，则在树中查找后直接返回；否则下一步</p>
</li>
<li><p>到这一步只能遍历链表，依次查找</p>
</li>
</ol>
<p>如何保证线程安全：volatile</p>
<h3 id="size"><a href="#size" class="headerlink" title="size()*"></a>size()*</h3><p><em><strong>*size*</strong>***</em>*()****<em><strong>*方法是加锁实现的吗？不是*</strong></em></p>
<p>核心方法<em><strong>*sumCount*</strong></em>()：</p>
<p>当数组counterCells为空时直接返回baseCount</p>
<p>当数组counterCells不为空时遍历它并累加到baseCount中</p>
<p>****baseCount****是一个volatile变量</p>
<p>在put方法最后调用的addCount()方法中：</p>
<ol>
<li><p>首先对baseCount做CAS自增操作</p>
</li>
<li><p>如果并发导致了baseCount的CAS失败了，则使用counterCells进行CAS</p>
</li>
<li><p>如果counterCells的CAS也失败了，那么则进入fullAddCount()方法，fullAddCount()方法中会进入死循环，直到成功为止。</p>
</li>
</ol>
<p><strong>CountCell</strong></p>
<p>CounterCell数组的每个元素，都存储一个元素个数，调用size方法就是通过循环累加元素个数来得到。</p>
<p>一个使用了 @sun.misc.Contended 标记的类，内部一个 volatile 变量。</p>
<p>@sun.misc.Contended 这个注解是为了防止“伪共享”。</p>
<p>这样设计的****原因****：</p>
<p>一般的集合大小直接定义一个size的成员变量，当出现改变的时候只要更新这个变量就行。ConcurrentHashMap是并发集合，如果用一个成员变量来统计元素个数的话，为了保证并发情况下共享变量的的安全，势必会需要通过加锁或者自旋来实现，如果竞争比较激烈的情况下，size的设置上会出现比较大的冲突反而影响了性能，所以在ConcurrentHashMap采用了分片的方法来记录大小。</p>
<p>伪共享：</p>
<p>缓存系统中是以缓存行为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节（常见64）。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。所以伪共享对性能危害极大。JDK1.8之后使用拼接来解决这个问题，把缓存行加满，让缓存之间的修改互不影响。</p>
<p>public int size() {</p>
<p>  long n = <em><strong>*sumCount*</strong></em>();</p>
<p>  return ((n &lt; 0L) ? 0 :</p>
<p>​      (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</p>
<p>​      (int)n);</p>
<p>}</p>
<p>final long <em><strong>*sumCount*</strong></em>() {</p>
<p>  CounterCell[] as = counterCells; CounterCell a;</p>
<p>  long sum = baseCount;</p>
<p>  if (as != null) {</p>
<p>​    for (int i = 0; i &lt; as.length; ++i) {</p>
<p>​      if ((a = as[i]) != null)</p>
<p>​        sum += a.value;</p>
<p>​    }</p>
<p>  }</p>
<p>  return sum;</p>
<p>}</p>
<p>@sun.misc.Contended static final class <em><strong>*CounterCell*</strong></em> {</p>
<p>  volatile long value;</p>
<p>  CounterCell(long x) { value = x; }</p>
<p>}</p>
<h4 id="initTable"><a href="#initTable" class="headerlink" title="initTable()"></a>initTable()</h4><p>调用时机：与HashMap相似，使用懒加载，在使用之前发现tab == null || (n = tab.length) == 0时调用initTable().</p>
<p>变量private transient volatile int sizeCtl;，数组初始化和扩容的控制，在多线程情况下避免多次初始化，初始默认值为0：</p>
<ol>
<li><p>-1 表示正在初始化</p>
</li>
<li><p>-(1+N) 表示有N个线程正在进行扩容</p>
</li>
<li><p>正数且table没有初始化，表示table初始化大小</p>
</li>
<li><p>正数且table已被初始化，表示table下一次resize的阈值</p>
</li>
</ol>
<p>执行过程：</p>
<ol>
<li><p>如果当前数组是空的，下一步</p>
</li>
<li><p>判断当前sizeCtl是否小于0，如果是，Thread.yield()让出CPU使用权；否则，下一步</p>
</li>
<li><p>使用CAS操作，将sizeCtl置为-1，表示正在初始化</p>
</li>
<li><p>如果sizeCtl&gt;0，初始化大小为sizeCtl，否则初始化为16</p>
</li>
<li><p>初始化table</p>
</li>
</ol>
<p>如何保证线程安全： CAS自旋+volatile</p>
<h4 id="为什么get-为何无需加锁"><a href="#为什么get-为何无需加锁" class="headerlink" title="为什么get()为何无需加锁"></a>为什么get()为何无需加锁</h4><p>ConcurrentHashMap的get操作并没有像put操作一样有CAS和synchronized锁。get操作不需要加锁，因为 Node 的元素 value 和指针 next 是用 volatile 修饰的，所以在多线程的环境下，即便value的值被修改了，在线程之间也是可见的。</p>
<h3 id="4-1-8中弃用分段锁的原因"><a href="#4-1-8中弃用分段锁的原因" class="headerlink" title="4. 1.8中弃用分段锁的原因"></a>4. 1.8中弃用分段锁的原因</h3><ol>
<li><p>加入多个分段锁浪费内存空间</p>
</li>
<li><p>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待</p>
</li>
<li><p>为了提高 GC 的效率</p>
</li>
</ol>
<p>摘自：</p>
<p><a href="#/docs/java/collection/ConcurrentHashMap%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90">https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ConcurrentHashMap%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90</a></p>
<p><a href="https://blog.csdn.net/zycxnanwang/article/details/105424734">https://blog.csdn.net/zycxnanwang/article/details/105424734</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>集合容器</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2021/09/10/Java/HashMap/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>HashMap 主要用来存放<strong>键值对</strong>，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p>
<p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。</p>
<h3 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1.底层数据结构"></a>1.底层数据结构</h3><h4 id="JDK1-7-：数组-链表"><a href="#JDK1-7-：数组-链表" class="headerlink" title="JDK1.7 ：数组+链表"></a>JDK1.7 ：数组+链表</h4><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过<strong>拉链法</strong>解决冲突。</p>
<p> <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="https://camo.githubusercontent.com/aa7cb4f75f247d974819c750e8f9ca530a5ee83f1e7b162eebc64a506f38ae92/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f6a646b312e382545342542392538422545352538392538442545372539412538342545352538362538352545392538332541382545372542422539332545362539452538342e706e67" alt="jdk1.8之前的内部结构"></p>
<h4 id="JDK1-8-：数组-链表-红黑树"><a href="#JDK1-8-：数组-链表-红黑树" class="headerlink" title="JDK1.8 ：数组+链表/红黑树"></a>JDK1.8 ：数组+链表/红黑树</h4><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当<strong>数组长度大于或者等于 64</strong> 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。相关源码这里就不贴了，重点关注 <code>treeifyBin()</code>方法即可！</p>
<p><img src="https://camo.githubusercontent.com/95fe53625bad15529f73f6e15e74a6937e464c3863903dcfd136ec3113c906ce/68747470733a2f2f6f7363696d672e6f736368696e612e6e65742f6f73636e65742f75702d62626132383332323836393364616537346537386461316566376139613034633638342e706e67" alt="img"></p>
<h3 id="2-put"><a href="#2-put" class="headerlink" title="2.put()"></a>2.put()</h3><p>put方法中调用了putVal()，putVal并未提供给用户使用。</p>
<p>putVal()方法的过程：</p>
<ol>
<li><p>table是否为null或者为空：是，resize；否，第2步</p>
</li>
<li><p>使用hash计算数组下标(n - 1) &amp; hash，判断对应下标是否有值：如果没有，newNode后直接插入数组；如果有，第3步</p>
</li>
<li><p>如果数组对应位置已经有值且key值相等，直接覆盖；如果key值不相同，产生哈希冲突，第4步</p>
</li>
<li><p>判断该位置节点是否为树节点TreeNode，如果是，放入树中；如果不是，第5步</p>
</li>
<li><p>那么该位置节点必定是链表节点，在链表尾部插入新节点。判断此时链表长度是否大于TREEIFY_THRESHOLD=8，如果大于，第6步</p>
</li>
<li><p>如果大于8，执行treeifyBin 方法转为红黑树</p>
</li>
<li><p>所有步骤的最后一步：++size，并判断数组长度是否超过threshold=64，如果大于调用resize进行扩容</p>
</li>
</ol>
<h3 id="3-get"><a href="#3-get" class="headerlink" title="3.get()"></a>3.get()</h3><ol>
<li><p>判断数组table非null非空</p>
</li>
<li><p>根据hash计算下标，找出该位置的第一个元素first = tab[(n - 1) &amp; hash]</p>
</li>
<li><p>如果两者hash相同且key相同，返回first；否则说明数组该位置不止一个节点，下一步</p>
</li>
<li><p>判断是否为树节点TreeNode，在树中get；如果不是，下一步</p>
</li>
<li><p>遍历链表，找出hash相同且key相同的值返回。</p>
</li>
</ol>
<h3 id="4-reisze"><a href="#4-reisze" class="headerlink" title="4.reisze()"></a>4.reisze()</h3><ol>
<li><p>若threshold（阈值）不为空，table的首次初始化大小为阈值，否则初始化为缺省值大小16</p>
</li>
<li><p>当size（元素总数）大于threshold（阈值），就会扩容，扩容后的table大小变为原来的两倍。即扩容前的table大小为2的N次方，扩容后为2的N+1次方。那么该元素的table索引值由这N+1位确定，比原来多了一位</p>
</li>
<li><p>rehashing，节点分为三种情况：</p>
<ol>
<li><p>该索引位置没有冲突，没有链表，直接newTab[e.hash &amp; (newCap - 1)] = e;</p>
</li>
<li><p>有冲突，是红黑树节点，调用split方法，重建树</p>
</li>
<li><p>有冲突，有链表。如果hash值第N+1位为0，则表示不需要调整该链表节点位置；如果为1，表示需要调整到原索引的两倍位置（原因如下）</p>
</li>
</ol>
</li>
<li><p>扩容或初始化完成后，resize方法返回新的table</p>
</li>
</ol>
<h3 id="5-HashMap1-8中的hash函数（扰动函数）"><a href="#5-HashMap1-8中的hash函数（扰动函数）" class="headerlink" title="5.HashMap1.8中的hash函数（扰动函数）"></a>5.HashMap1.8中的hash函数（扰动函数）</h3><p>扰动函数的目的：避免一些比较差的hashCode方法，减少碰撞。</p>
<p>  static final int hash(Object key) {</p>
<p>​    int h;</p>
<p>​    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</p>
<p>  }</p>
<p>为什么hash函数要这样设计？</p>
<p>首先，hash函数也称为扰动函数，这个函数的最终返回值会用来计算数组的下标，即源码中的 (n - 1) &amp; hash。 </p>
<p>HashMap的数组长度要取2的整次幂，这样的话，n-1 正好相当于一个低位掩码。在经过与操作之后，hash值的高位全部归零，只保留低位值，用来做数组的下标。</p>
<p>但是，这就存在一个问题：就算散列值分布再松散，只取最后几位的话，碰撞也会很严重。</p>
<p>这时候扰动函数的价值就体现出来了，扰动函数的源码中将key的hashCode高16位和低16位进行异或，目的是：混合原始哈希码的高位和低位，以此来加大低位的随机性；并且，混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保存下来了。</p>
<p>在Java1.8中，做了一次扰动，之前做四次，多了可能边际效用也不大，所谓为了效率考虑就改成一次了。</p>
<h3 id="6-为什么数组长度要取2的整次幂"><a href="#6-为什么数组长度要取2的整次幂" class="headerlink" title="6. 为什么数组长度要取2的整次幂*"></a>6. 为什么数组长度要取2的整次幂*</h3><p>HashMap的数组长度要取2的整次幂，这样的话，n-1 正好相当于一个低位掩码。在经过与操作之后，hash值的高位全部归零，只保留低位值，用来做数组的下标。</p>
<p>如何保证？</p>
<p>HashMap 中的<em><strong>*tableSizeFor()方法*</strong></em></p>
<p>  static final int tableSizeFor(int cap) {</p>
<p>​    int n = cap - 1;</p>
<p>​    n |= n &gt;&gt;&gt; 1;</p>
<p>​    n |= n &gt;&gt;&gt; 2;</p>
<p>​    n |= n &gt;&gt;&gt; 4;</p>
<p>​    n |= n &gt;&gt;&gt; 8;</p>
<p>​    n |= n &gt;&gt;&gt; 16;</p>
<p>​    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</p>
<p>  }</p>
<p>返回不小于cap的最接近2的整数幂的数，比如10返回16,25返回32。</p>
<p>如何实现的？</p>
<p>​    思路：将最高位1之后的所有位全部变为1，然后加1返回即可。</p>
<p>​    右移1位，与或，前2位变为1；</p>
<p>​    右移2位，与或，前4位变为1；</p>
<p>​    右移4位，与或，前8位变为1；</p>
<p>​    …依次类推</p>
<p>​    将最终的结果+1，即为所求。</p>
<p>一开始-1，是为了避免已经是给定容量的8这样2的幂次时，返回16，比预期的8更大。</p>
<p>太强了…</p>
<h3 id="7-几个HashMap的属性"><a href="#7-几个HashMap的属性" class="headerlink" title="7.几个HashMap的属性"></a>7.几个HashMap的属性</h3><p>\1. loadFactor默认加载因子=0.75f</p>
<ol>
<li><p>=数组存放数组个数/数组长度；loadFactor越大，数组存放越密；loadFactor越小，存放越稀疏</p>
</li>
<li><p>太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。</p>
</li>
<li><p>给定的默认容量为 16，负载因子为 0.75。使用过程中不断的往HashMap里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容</p>
</li>
</ol>
<p>\2. threshold 临界值</p>
<ol>
<li>threshold = capacity * loadFactor，当 size&gt;=threshold的时候，那么就要考虑对数组的扩增了，衡量数组是否需要扩容的一个标准。</li>
</ol>
<h3 id="8-负载因子为什么是0-75？"><a href="#8-负载因子为什么是0-75？" class="headerlink" title="8.负载因子为什么是0.75？"></a>8.负载因子为什么是0.75？</h3><p>通常，加载因子需要在时间和空间成本上寻求一种折衷。</p>
<p>加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；</p>
<p>加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数。</p>
<p>选择0.75作为默认的加载因子，完全是提高空间利用率和减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小。</p>
<h3 id="9-为什么是8时转为红黑树？"><a href="#9-为什么是8时转为红黑树？" class="headerlink" title="9.为什么是8时转为红黑树？"></a>9.为什么是8时转为红黑树？</h3><p>默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想。</p>
<p>最开始使用链表的时候，空间占用是比较少的，而且由于链表短，所以查询时间也没有太大的问题。可是当链表越来越长，需要用红黑树的形式来保证查询的效率。对于何时应该从链表转化为红黑树，需要确定一个阈值，这个阈值默认为 8，并且在源码中也对选择 8 这个数字做了说明：</p>
<p>如果 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的。在理想情况下，链表长度符合泊松分布，当长度为 8 的时候，概率仅为 0.00000006，小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p>
<h3 id="10-HashMap为什么不安全"><a href="#10-HashMap为什么不安全" class="headerlink" title="10.HashMap为什么不安全**"></a>10.HashMap为什么不安全**</h3><p><a href="https://www.cnblogs.com/developer_chan/p/10450908.html">https://www.cnblogs.com/developer_chan/p/10450908.html</a></p>
<p>HashMap是线程不安全的，其主要体现：</p>
<ol>
<li><p>在jdk1.7中，在多线程环境下，扩容resize时会造成环形链或数据丢失。</p>
</li>
<li><p>在jdk1.8中，在多线程环境下，put元素时会发生数据覆盖的情况。</p>
</li>
</ol>
<h4 id="1-1-7死循环"><a href="#1-1-7死循环" class="headerlink" title="(1) 1.7死循环"></a>(1) 1.7死循环</h4><p><strong>出现在扩容的transfer函数中</strong></p>
<p>在对table扩容到newTable后，需要将原来的数据转移到newTable当中，在转移过程中，使用的是头插法，环形链表就是在这里产生。</p>
<p>举例：</p>
<p>假设地址0处有元素A和B，这时需要添加C，发现需要扩容。</p>
<p>线程1：读取到当前的hashmap情况，在准备扩容时，线程二介入</p>
<p><img src="/2021/09/10/Java/HashMap/wps1.jpg" alt="img"> </p>
<p>线程二：读取hashmap，进行扩容；扩容后变为B.next=A</p>
<p><img src="/2021/09/10/Java/HashMap/wps2.jpg" alt="img"> </p>
<p>线程一：继续执行，变为A.next=B，出现环</p>
<p><img src="/2021/09/10/Java/HashMap/wps3.jpg" alt="img"></p>
<h4 id="2-1-7数据丢失"><a href="#2-1-7数据丢失" class="headerlink" title="(2) 1.7数据丢失"></a>(2) 1.7数据丢失</h4><p>线程A、B操作如下HashMap：</p>
<p><img src="/2021/09/10/Java/HashMap/wps4.jpg" alt="img"> </p>
<p>A执行：</p>
<p><img src="/2021/09/10/Java/HashMap/wps5.jpg" alt="img"> </p>
<p>A的执行结果如下：</p>
<p><img src="/2021/09/10/Java/HashMap/wps6.jpg" alt="img"> </p>
<p>A被挂起，B继续执行：</p>
<p><img src="/2021/09/10/Java/HashMap/wps7.jpg" alt="img"> </p>
<p>B执行完了，所以现在java内存中newtable和table中的Entry都是B线程执行完的最新值即： newTable[1]=5 | 5.next=null | newTable[3]=3 | 3.next=7 | 7.next=null</p>
<p>线程A继续执行：</p>
<p><img src="/2021/09/10/Java/HashMap/wps8.jpg" alt="img"> </p>
<p>结果如下：</p>
<p><img src="/2021/09/10/Java/HashMap/wps9.jpg" alt="img"> </p>
<p>继续循环（此时e=5 由上次循环的代码可知）</p>
<p><img src="/2021/09/10/Java/HashMap/wps10.jpg" alt="img"> </p>
<p>至此e=null，循环结束</p>
<p>结果如下：</p>
<p>3元素丢失，并形成环形链表。并在后续操作hashmap时造成死循环。</p>
<p><img src="/2021/09/10/Java/HashMap/wps11.jpg" alt="img"> </p>
<p>  void transfer(Entry[] newTable, boolean rehash) {</p>
<p>​    int newCapacity = newTable.length;</p>
<p>​    for (Entry&lt;K,V&gt; e : table) {</p>
<p>​      while(null != e) {</p>
<p>​        Entry&lt;K,V&gt; next = e.next;</p>
<p>​        if (rehash) {</p>
<p>​          e.hash = null == e.key ? 0 : hash(e.key);</p>
<p>​        }</p>
<p>​        int i = indexFor(e.hash, newCapacity);</p>
<p>​        e.next = newTable[i];</p>
<p>​        <em><strong>*newTable[i] = e;*</strong></em></p>
<p>​        e = next;</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<h4 id="3-1-8-put时数据覆盖问题"><a href="#3-1-8-put时数据覆盖问题" class="headerlink" title="(3) 1.8 put时数据覆盖问题"></a>(3) 1.8 put时数据覆盖问题</h4><p>​    在jdk1.8中对HashMap进行了优化，在发生hash碰撞时，不再采用头插法方式，而是****尾插法*<em><strong>，因此不会出现环形链表的情况，但是在多线程的情况下会产生</strong>数据覆盖</em>*的问题。</p>
<p>​    在putVal源码中，在判断没有哈希碰撞后，会直接插入元素。如果线程A和线程B同时进行put操作，插入的两个元素哈希值相同，且该位置为null。线程A判断后还未插入时被挂起，线程B正常执行，插入数据，然后线程A获得时间片，此时线程A不用进行判断，直接插入数据，这时，<strong>线程A就会覆盖线程B的数据</strong>。</p>
<h3 id="11-与HashTable比较"><a href="#11-与HashTable比较" class="headerlink" title="11. 与HashTable比较"></a>11. 与HashTable比较</h3><ol>
<li><p>线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过synchronized 修饰，同一把锁效率低下。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p>
</li>
<li><p>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p>底层数据结构： JDK1.8 后 HashMap数组+链表/红黑树。Hashtable 数组+链表。</p>
</li>
<li><p>对 Null key 和 Null value 的支持： HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</p>
</li>
<li><p>初始容量大小和每次扩充容量大小的不同 ： ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。</p>
</li>
</ol>
<h3 id="12-与HashSet比较"><a href="#12-与HashSet比较" class="headerlink" title="12. 与HashSet比较"></a>12. 与HashSet比较</h3><ol>
<li><p>底层基于HashMap实现，HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
</li>
<li><p>自定义属性private transient HashMap&lt;E,Object&gt; map;存储数据</p>
</li>
</ol>
<p><strong>与HashMap区别：</strong></p>
<ol>
<li><p>HashSet</p>
<ol>
<li><p>实现Set接口</p>
</li>
<li><p>存储对象</p>
</li>
<li><p>调用add添加元素</p>
</li>
<li><p>使用对象值计算hashcode</p>
</li>
</ol>
</li>
<li><p>HashMap</p>
<ol>
<li><p>实现Map接口</p>
</li>
<li><p>存储键值对</p>
</li>
<li><p>调用put添加元素</p>
</li>
<li><p>使用key计算hashcode</p>
</li>
</ol>
</li>
</ol>
<h3 id="13-与TreeMap"><a href="#13-与TreeMap" class="headerlink" title="13. 与TreeMap"></a>13. 与TreeMap</h3><p>TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。</p>
<p>实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。</p>
<p>实现SortMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p>
<p>综上，相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p>
<h3 id="14-与CurrentHashMap的区别"><a href="#14-与CurrentHashMap的区别" class="headerlink" title="14. 与CurrentHashMap的区别"></a>14. 与CurrentHashMap的区别</h3><ol>
<li><p>HashMap线程不安全；CurrentHashMap线程安全</p>
</li>
<li><p>可以使用Collections.sychronizedMap(HashMap) 来包装HashMap作为同步容器，这时它的作用几乎与Hashtable一样,当每次对Map做修改操作的时候都会锁住这个Map对象，而ConcurrentHashMap基于CAS自旋+ volatile+synchronized实现线程安全。</p>
</li>
<li><p>ConcurrentHashMap在多线程环境下性能方面比做了同步的HashMap要好，但是在单线程环境下，HashMap会比ConcurrentHashMap好一点。</p>
</li>
<li><p>ConcurrentHashMap的key和value均不能为null，HashMap都可以</p>
</li>
</ol>
<h3 id="15-HashMap的遍历方式"><a href="#15-HashMap的遍历方式" class="headerlink" title="15 .HashMap的遍历方式"></a>15 .HashMap的遍历方式</h3><p><strong>4类方式，可细分为7种：</strong></p>
<ol>
<li><p>迭代器Iterator</p>
<ol>
<li><p>迭代器的EntrySet</p>
</li>
<li><p>迭代器的KeySet</p>
</li>
</ol>
</li>
<li><p>For each</p>
<ol>
<li><p>EntrySet</p>
</li>
<li><p>KeySet</p>
</li>
</ol>
</li>
<li><p>Lambda</p>
</li>
<li><p>Stream API</p>
<ol>
<li><p>单线程方式</p>
</li>
<li><p>多线程方式</p>
</li>
</ol>
</li>
</ol>
<p><strong>遍历比较性能：</strong></p>
<p>​    EntrySet比KeySet性能高。原因：KeySet只是得到key值，之后还需要map.get(key)获取对应的value值，2n次操作。EntrySet得到的对象包括key和value，需要n次操作。</p>
<p>安全性：</p>
<p>​    <strong>迭代器</strong>直接调用iterator.remove();在遍历中删除元素；</p>
<p>​    <strong>for each</strong>中删除map.remove(entry.getKey());抛出ConcurrentModificationException；</p>
<p>​    <strong>Lambda</strong>删除map.remove(key);抛出ConcurrentModificationException；正确：使用        map.keySet().removeIf(key -&gt; key == 1);先删除错误数据，然后遍历。</p>
<p>​    <strong>Stream</strong>删除map.remove(entry.getKey());抛出ConcurrentModificationException；正确：使用filter过滤不需要数据。</p>
<p>综上，建议使用迭代器的EntrySet遍历HashMap.</p>
<p>摘自：</p>
<p><a href="https://www.cnblogs.com/developer_chan/p/10450908.html">https://www.cnblogs.com/developer_chan/p/10450908.html</a></p>
<p><a href="https://www.cnblogs.com/bendandedaima/p/13259284.html">https://www.cnblogs.com/bendandedaima/p/13259284.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>集合容器</category>
      </categories>
  </entry>
  <entry>
    <title>联合索引生效、失效的条件</title>
    <url>/2021/09/10/MySQL/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%94%9F%E6%95%88%E3%80%81%E5%A4%B1%E6%95%88%E7%9A%84%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="1-联合索引"><a href="#1-联合索引" class="headerlink" title="1.联合索引"></a>1.联合索引</h3><p>联合索引又叫复合索引。<strong>两个或更多个列上的索引</strong>被称作复合索引。</p>
<p>对于复合索引：<strong>Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部分，但只能是最左侧部分。*<em>例如索引是key index （a,b,c）。可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 。*</em> 当最左侧字段是常量引用时，索引就十分有效。</strong></p>
<span id="more"></span>

<p><strong>eg:</strong></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&mid=2247498404&idx=2&sn=d501b955843386d69b41aef6684d5a1a&chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&scene=21#wechat_redirect">建立 姓名、年龄、性别的复合索引。</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table myTest(</span><br><span class="line">     a int,</span><br><span class="line">     b int,</span><br><span class="line">     c int,</span><br><span class="line">     KEY a(a,b,c)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">(1) select * from myTest  where a&#x3D;3 and b&#x3D;5 and c&#x3D;4;   ----  abc顺序</span><br><span class="line">abc三个索引都在where条件里面用到了，而且都发挥了作用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(2) select * from myTest  where  c&#x3D;4 and b&#x3D;6 and a&#x3D;3;</span><br><span class="line">where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(3) select * from myTest  where a&#x3D;3 and c&#x3D;7;</span><br><span class="line">a用到索引，b没有用，所以c是没有用到索引效果的</span><br><span class="line"></span><br><span class="line">(4) select * from myTest  where a&#x3D;3 and b&gt;7 and c&#x3D;3;     ---- b范围值，断点，阻塞了c的索引</span><br><span class="line">a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(5) select * from myTest  where b&#x3D;3 and c&#x3D;4;   --- 联合索引必须按照顺序使用，并且需要全部使用</span><br><span class="line">因为a索引没有使用，所以这里 bc都没有用上索引效果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(6) select * from myTest  where a&gt;4 and b&#x3D;7 and c&#x3D;9;</span><br><span class="line">a用到了  b没有使用，c没有使用</span><br><span class="line"></span><br><span class="line">(7) select * from myTest  where a&#x3D;3 order by b;</span><br><span class="line">a用到了索引，b在结果排序中也用到了索引的效果，a下面任意一段的b是排好序的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(8) select * from myTest  where a&#x3D;3 order by c;</span><br><span class="line">a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了，使用 explain 可以看到 filesort</span><br><span class="line"></span><br><span class="line">(9) select * from mytable where b&#x3D;3 order by a;</span><br><span class="line">b没有用到索引，排序中a也没有发挥索引效果</span><br></pre></td></tr></table></figure>

<h3 id="2-索引失效的条件"><a href="#2-索引失效的条件" class="headerlink" title="2. 索引失效的条件"></a>2. 索引失效的条件</h3><ul>
<li>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引范围条件右边的列]</li>
<li>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</li>
<li>mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</li>
<li>is null,is not null也无法使用索引</li>
<li>like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。]</li>
</ul>
<p>摘自：</p>
<p><a href="https://mp.weixin.qq.com/s/rG3q9jtfzGaCoSsG37YoQg">https://mp.weixin.qq.com/s/rG3q9jtfzGaCoSsG37YoQg</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么解决MySQL的死锁问题</title>
    <url>/2021/09/10/MySQL/%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3MySQL%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-什么是死锁"><a href="#1-什么是死锁" class="headerlink" title="1.什么是死锁"></a>1.什么是死锁</h3><p>两个及以上的事务，双方都在等待对方释放已经持有的锁或因为加锁顺序不一致造成<strong>循环等待</strong>锁资源，就会出现“死锁”。常见的报错信息为 <code>Deadlock found when trying to get lock...</code>。</p>
<span id="more"></span>

<p>从死锁的定义来看，MySQL 出现死锁的几个要素为：</p>
<ol>
<li>两个或者两个以上事务</li>
<li>每个事务都已经持有锁并且申请新的锁</li>
<li>锁资源同时只能被同一个事务持有或者不兼容</li>
<li>事务之间因为持有锁和申请锁导致彼此循环等待</li>
</ol>
<h3 id="2-InnoDB-锁类型"><a href="#2-InnoDB-锁类型" class="headerlink" title="2.InnoDB 锁类型"></a>2.InnoDB 锁类型</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibicysIEia6kunTYUf3KQ6bxP2QCPByG7ctyoXl7hhAzicIJcqjxE6iaXiaxiaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>MySQL InnoDB 引擎实现了标准的<code>行级别锁：共享锁( S lock ) 和排他锁 ( X lock )</code></p>
<p><img src="/2021/09/10/MySQL/%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3MySQL%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/image-20210910102143091.png" alt="image-20210910102143091"></p>
<h4 id="间隙锁-gap-lock"><a href="#间隙锁-gap-lock" class="headerlink" title="间隙锁( gap lock )"></a>间隙锁( gap lock )</h4><p>间隙锁锁住一个间隙以防止插入。假设索引列有2, 4, 8 三个值，如果对 4 加锁，那么也会同时对(2,4)和(4,8)这两个间隙加锁。其他事务无法插入索引值在这两个间隙之间的记录。但是，间隙锁有个例外:</p>
<blockquote>
<ol>
<li>如果索引列是唯一索引，那么只会锁住这条记录(只加行锁)，而不会锁住间隙。</li>
<li>对于联合索引且是唯一索引，如果 where 条件只包括联合索引的一部分，那么依然会加间隙锁。</li>
</ol>
</blockquote>
<h4 id="next-key-lock"><a href="#next-key-lock" class="headerlink" title="next-key lock"></a>next-key lock</h4><p>next-key lock 实际上就是 <strong>行锁+这条记录前面的 gap lock</strong> 的组合。假设有索引值10,11,13和 20,那么可能的 next-key lock 包括:</p>
<blockquote>
<p>(负无穷,10],(10,11],(11,13],(13,20],(20,正无穷)</p>
</blockquote>
<p>在 RR 隔离级别下，InnoDB 使用 next-key lock 主要是防止**<code>幻读</code>**问题产生。</p>
<h4 id="意向锁-Intention-lock"><a href="#意向锁-Intention-lock" class="headerlink" title="意向锁( Intention lock )"></a>意向锁( Intention lock )</h4><p>InnoDB 为了支持多粒度的加锁，允许<strong>行锁和表锁同时存在</strong>。为了支持在不同粒度上的加锁操作，InnoDB 支持了额外的一种锁方式，称之为<strong>意向锁</strong>( Intention Lock )。意向锁是<u>将锁定的对象分为多个层次</u>，意向锁意味着事务希望在更细粒度上进行加锁。意向锁分为两种:</p>
<blockquote>
<ol>
<li>意向共享锁( IS )：事务有意向对表中的某些行加共享锁</li>
<li>意向排他锁( IX )：事务有意向对表中的某些行加排他锁</li>
</ol>
</blockquote>
<p>由于 InnoDB 存储引擎支持的是<strong>行级别</strong>的锁，因此意向锁其实不会阻塞除全表扫描以外的任何请求。表级意向锁与行级锁的兼容性如下所示:<img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibicrCcP1FwRFjey2TCeicMuZp2qLF90bibGD9el0lhIW6yPhjicMibibDlKk7A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="插入意向锁-Insert-Intention-lock"><a href="#插入意向锁-Insert-Intention-lock" class="headerlink" title="插入意向锁( Insert Intention lock )"></a>插入意向锁( Insert Intention lock )</h4><p><strong>插入意向锁</strong>是在<u>插入一行记录操作之前设置的一种间隙锁</u>，这个锁释放了一种插入方式的信号，即多个事务在相同的索引间隙插入时如果不是插入间隙中相同的位置就不需要互相等待。假设某列有索引值2，6，只要两个事务插入位置不同(如事务 A 插入3，事务 B 插入4)，那么就可以同时插入。</p>
<h4 id="锁模式兼容矩阵"><a href="#锁模式兼容矩阵" class="headerlink" title="锁模式兼容矩阵"></a>锁模式兼容矩阵</h4><p>横向是已持有锁，纵向是正在请求的锁：<img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibicpCcfaPq9s5d7uF4srTfQq1eWaka2RWVXDEblK2vicObfdCiagvaOicgKA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="3-阅读死锁日志"><a href="#3-阅读死锁日志" class="headerlink" title="3.阅读死锁日志"></a>3.阅读死锁日志</h3><p>在进行具体案例分析之前，咱们先了解下如何去读懂死锁日志，尽可能地使用死锁日志里面的信息来帮助我们来解决死锁问题。</p>
<p>后面测试用例的数据库场景如下:<code>MySQL 5.7 事务隔离级别为 RR</code></p>
<p>表结构和数据如下:<img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibicrYtObLuGncGtTOMW6G1TF0twtRc0PdtImtwomLSfKtAuI96icQX2cHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>测试用例如下:<img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibicER5sibmYUK4blLnmyWCLFEvJgtaVOPMtTs4tjOXLRz5qOfBOoY6xlhg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>通过执行show engine innodb status 可以查看到最近一次死锁的日志。</p>
<h4 id="日志分析如下"><a href="#日志分析如下" class="headerlink" title="日志分析如下"></a>日志分析如下</h4><ol>
<li>***** (1) TRANSACTION: TRANSACTION 2322, ACTIVE 6 sec starting index read</li>
</ol>
<p>事务号为2322，活跃 6秒，starting index read 表示事务状态为根据索引读取数据。常见的其他状态有:<img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibicibZ6TX3se2a5KWa78YzAICxKeocwdFyAkGEGRY5gIbCsk4pHxTqrRicQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><code>mysql tables in use 1</code> 说明当前的事务使用一个表。</p>
<p><code>locked 1</code> 表示表上有一个表锁，对于 DML 语句为 LOCK_IX</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)</span><br></pre></td></tr></table></figure>

<p><code>LOCK WAIT</code> 表示正在等待锁，<code>2 lock struct(s)</code> 表示 trx-&gt;trx_locks 锁链表的长度为2，每个链表节点代表该事务持有的一个锁结构，包括表锁，记录锁以及自增锁等。本用例中 2locks 表示 IX 锁和lock_mode X (Next-key lock)</p>
<p><code>1 row lock(s)</code> 表示当前事务持有的行记录锁/ gap 锁的个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL thread id 37, OS thread handle 140445500716800, query id 1234 127.0.0.1 root updating</span><br></pre></td></tr></table></figure>

<p><code>MySQL thread id 37</code> 表示执行该事务的线程 ID 为 37 (即 show processlist; 展示的 ID )</p>
<p><code>delete from student where stuno=5</code> 表示事务1正在执行的 sql，比较难受的事情是 <code>show engine innodb status</code> 是查看不到完整的 sql 的，通常显示当前正在等待锁的 sql。</p>
<p>***** (1) WAITING FOR THIS LOCK TO BE GRANTED:</p>
<p>RECORD LOCKS space id 11 page no 5 n bits 72 index idx_stuno of table cw****.****student trx id 2322 lock_mode X waiting</p>
<p>RECORD LOCKS 表示记录锁， 此条内容表示事务 1 正在等待表 student 上的 idx_stuno 的 X 锁，本案例中其实是 Next-Key Lock 。</p>
<p>事务2的 log 和上面分析类似:</p>
<ol>
<li>***** (2) HOLDS THE LOCK(S):</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id 11 page no 5 n bits 72 index idx_stuno of table cw****.****student trx id 2321 lock_mode X</span><br></pre></td></tr></table></figure>

<p>显示事务 2 的 insert into student(stuno,score) values(2,10) 持有了 a=5 的 Lock mode X</p>
<p>| LOCK_gap，不过我们从日志里面看不到事务2执行的 delete from student where stuno=5;</p>
<p>这点也是造成 DBA 仅仅根据日志难以分析死锁的问题的根本原因。</p>
<ol>
<li>***** (2) WAITING FOR THIS LOCK TO BE GRANTED:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id 11 page no 5 n bits 72 index idx_stuno of table cw****.****student trx id 2321 lock_mode X locks gap before rec insert intention waiting</span><br></pre></td></tr></table></figure>

<p>表示事务 2 的 insert 语句正在等待插入意向锁 lock_mode X locks gap before rec insert intention waiting ( LOCK_X + LOCK_REC_gap )</p>
<h3 id="4-经典案例分析"><a href="#4-经典案例分析" class="headerlink" title="4.经典案例分析"></a>4.经典案例分析</h3><h4 id="案例一-事务并发-insert-唯一键冲突"><a href="#案例一-事务并发-insert-唯一键冲突" class="headerlink" title="案例一:事务并发 insert 唯一键冲突"></a>案例一:事务并发 insert 唯一键冲突</h4><p>表结构和数据如下所示:<img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibicw8EVmJ8BG8Khy2jYibfM5MwZMYpE5OXFlsQ9JD0rJveYJLTB8hT9Taw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibicKAW3OPoFVWYoqnlzY7Kkwx6Tuib3P5jh88V1IZWMJ3nwjoU3kZx1bCA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">测试用例如下:<img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibich9nJAgXMicgAwhLiactz1dhbM8knHhptCQdAqNFia0LK19c6mGGpw7ic4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">日志分析如下:</p>
<ol>
<li>事务 T2 insert into t7(id,a) values (26,10) 语句 insert 成功，持有 a=10 的 <code>排他行锁( Xlocks rec but no gap )</code></li>
<li>事务 T1 insert into t7(id,a) values (30,10), 因为T2的第一条 insert 已经插入 a=10 的记录,事务 T1 insert a=10 则发生唯一键冲突,需要申请对冲突的唯一索引加上S Next-key Lock( 即 lock mode S waiting ) 这是一个<code>间隙锁</code>会申请锁住(,10],(10,20]之间的 gap 区域。</li>
<li>事务 T2 insert into t7(id,a) values (40，9)该语句插入的 a=9 的值在事务 T1 申请的 <code>gap 锁4-10之间</code>， 故需事务 T2 的第二条 insert 语句要等待事务 T1 的 <code>S-Next-key Lock 锁</code>释放,在日志中显示 lock_mode X locks gap before rec insert intention waiting 。</li>
</ol>
<h4 id="案例一-先-update-再-insert-的并发死锁问题"><a href="#案例一-先-update-再-insert-的并发死锁问题" class="headerlink" title="案例一:先 update 再 insert 的并发死锁问题"></a>案例一:先 update 再 insert 的并发死锁问题</h4><p>表结构如下，无数据:<img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibicmQsgsOgYeUx4AC9hlfcXzRjFITIQ07yd3c1mbnO6f8pPHUSaDKFrKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">测试用例如下:<img src="https://mmbiz.qpic.cn/mmbiz_png/7VkkuTzAZPp08uy3ZghjeKeEiae1ooyibicVWZujhIYpkiaFzorMic6jWsVYm2lENaIwAvQKGEIicGibELibRpuTRRcJoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">死锁分析:<br>可以看到两个事务 update 不存在的记录，先后获得<code>间隙锁( gap 锁)</code>，gap 锁之间是兼容的所以在update环节不会阻塞。两者都持有 gap 锁，然后去竞争插入<code>意向锁</code>。当存在其他会话持有 gap 锁的时候，当前会话申请不了插入意向锁，导致死锁。</p>
<h3 id="5-如何尽可能避免死锁"><a href="#5-如何尽可能避免死锁" class="headerlink" title="5.如何尽可能避免死锁"></a>5.如何尽可能避免死锁</h3><ol>
<li>合理的设计索引，区分度高的列放到组合索引前面，使业务 SQL 尽可能通过索引<code>定位更少的行，减少锁竞争</code>。</li>
<li>调整业务逻辑 SQL 执行顺序， 避免 update/delete 长时间持有锁的 SQL 在事务前面。</li>
<li>避免<code>大事务</code>，尽量将大事务拆成多个小事务来处理，小事务发生锁冲突的几率也更小。</li>
<li>以<code>固定的顺序</code>访问表和行。比如两个更新数据的事务，事务 A 更新数据的顺序为 1，2;事务 B 更新数据的顺序为 2，1。这样更可能会造成死锁。</li>
<li>在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如 select … for update 语句，如果是在事务里<code>（运行了 start transaction 或设置了autocommit 等于0）</code>,那么就会锁定所查找到的记录。</li>
<li>尽量按<code>主键/索引</code>去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外额度计算工作。比如有的程序会用到 “select … where … order by rand();”这样的语句，由于类似这样的语句用不到索引，因此将导致整个表的数据都被锁住。</li>
<li>优化 SQL 和表设计，减少同时占用太多资源的情况。比如说，<code>减少连接的表</code>，将复杂 SQL <code>分解</code>为多个简单的 SQL。</li>
</ol>
<p>摘自：</p>
<p><a href="https://mp.weixin.qq.com/s/khZnxXikPOh9qoOMXZRVyw">https://mp.weixin.qq.com/s/khZnxXikPOh9qoOMXZRVyw</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存与数据库一致性问题</title>
    <url>/2021/09/10/MySQL/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1-为什么引入缓存"><a href="#1-为什么引入缓存" class="headerlink" title="1.为什么引入缓存"></a>1.为什么引入缓存</h3><p>如果你的业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OezNCibL5S9oyeYqJBQVZCo1NdGKV0ptDl4ZsCXKfwXLl1Kp35aOG1Iku9K2EJ8Y7v5bM91jK5NLQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>随着业务量的增长，你的项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有<strong>性能问题</strong>。</p>
<span id="more"></span>

<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OezNCibL5S9oyeYqJBQVZCo3lYxFg1icDgHngialHe8ibUDKCvfib4DmTMo36wJv0FeZ5ex0kId1LTOpw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当下优秀的缓存中间件，当属 <strong>Redis</strong> 莫属，它不仅<u>性能非常高，还提供了很多友好的数据类型</u>，可以很好地满足我们的业务需求。</p>
<h3 id="2-缓存怎么存"><a href="#2-缓存怎么存" class="headerlink" title="2.缓存怎么存"></a>2.缓存怎么存</h3><p>最简单直接的方案是「全量数据刷到缓存中」：</p>
<ul>
<li>数据库的数据，全量刷入缓存（不设置失效时间）</li>
<li>写请求只更新数据库，不更新缓存</li>
<li>启动一个定时任务，定时把数据库的数据，更新到缓存中</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OezNCibL5S9oyeYqJBQVZCo0jeBz8G4Kwr7ZgicicEQARCTuaFibHOf1pKzVnicVbiaxzGtKukzrEqGOOA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>优点：</strong></p>
<p>所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。</p>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>缓存利用率低</strong>：不经常访问的数据，还一直留在缓存中</li>
<li><strong>数据不一致</strong>：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）</li>
</ol>
<p>所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。</p>
<h3 id="3-缓存利用率和一致性问题"><a href="#3-缓存利用率和一致性问题" class="headerlink" title="3.缓存利用率和一致性问题"></a>3.缓存利用率和一致性问题</h3><p>优化方法：</p>
<ul>
<li>写请求依旧只写数据库</li>
<li>读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存</li>
<li>同时，写入缓存中的数据，都设置失效时间</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OezNCibL5S9oyeYqJBQVZCo8ic8WbuqDQcJ2bVyia7t9rOu9CGyJnCkWQs16WNibAwdV0GbH3q0K6ZMw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化。</p>
<p><strong>数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：</strong></p>
<ol>
<li>先更新缓存，后更新数据库</li>
<li>先更新数据库，后更新缓存</li>
</ol>
<p><strong>1) 先更新缓存，后更新数据库</strong></p>
<p>如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。</p>
<p>虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。</p>
<p>这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。</p>
<p><strong>2) 先更新数据库，后更新缓存</strong></p>
<p>如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。</p>
<p>之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。</p>
<p>这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。</p>
<p>可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？</p>
<p>别急，后面我会详细给出对应的解决方案。</p>
<p>我们继续分析，除了操作失败问题，还有什么场景会影响数据一致性？</p>
<p>这里我们还需要重点关注：<strong>并发问题</strong>。</p>
<h4 id="并发引发的一致性问题"><a href="#并发引发的一致性问题" class="headerlink" title="并发引发的一致性问题"></a>并发引发的一致性问题</h4><p>假设我们采用「先更新数据库，再更新缓存」的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？</p>
<p>有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：</p>
<ol>
<li>线程 A 更新数据库（X = 1）</li>
<li>线程 B 更新数据库（X = 2）</li>
<li>线程 B 更新缓存（X = 2）</li>
<li>线程 A 更新缓存（X = 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。</p>
<p>也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。</p>
<blockquote>
<p>同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。</p>
</blockquote>
<h4 id="删除缓存可以保证一致性吗？"><a href="#删除缓存可以保证一致性吗？" class="headerlink" title="删除缓存可以保证一致性吗？"></a>删除缓存可以保证一致性吗？</h4><p>删除缓存对应的方案也有 2 种：</p>
<ol>
<li>先删除缓存，后更新数据库</li>
<li>先更新数据库，后删除缓存</li>
</ol>
<p>经过前面的分析我们已经得知，但凡「第二步」操作失败，都会导致数据不一致。</p>
<p>这里我不再详述具体场景，你可以按照前面的思路推演一下，就可以看到依旧存在数据不一致的情况。</p>
<p>这里我们重点来看「并发」问题。</p>
<p><strong>1) 先删除缓存，后更新数据库</strong></p>
<p>如果有 2 个线程要并发「读写」数据，可能会发生以下场景：</p>
<ol>
<li>线程 A 要更新 X = 2（原值 X = 1）</li>
<li>线程 A 先删除缓存</li>
<li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li>
<li>线程 A 将新值写入数据库（X = 2）</li>
<li>线程 B 将旧值写入缓存（X = 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p>
<p>可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。</p>
<p><strong>2) 先更新数据库，后删除缓存</strong></p>
<p>依旧是 2 个线程并发「读写」数据：</p>
<ol>
<li>缓存中 X 不存在（数据库 X = 1）</li>
<li>线程 A 读取数据库，得到旧值（X = 1）</li>
<li>线程 B 更新数据库（X = 2)</li>
<li>线程 B 删除缓存</li>
<li>线程 A 将旧值写入缓存（X = 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。</p>
<p>这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？</p>
<p>其实概率「很低」，这是因为它必须满足 3 个条件：</p>
<ol>
<li>缓存刚好已失效</li>
<li>读请求 + 写请求并发</li>
<li>更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）</li>
</ol>
<p>仔细想一下，条件 3 发生的概率其实是非常低的。</p>
<p>因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。</p>
<p>这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。</p>
<p>所以，我们应该采用这种方案，来操作数据库和缓存。</p>
<p>好，解决了并发问题，我们继续来看前面遗留的，<strong>第二步执行「失败」导致数据不一致的问题</strong>。</p>
<h4 id="如何保证两步都执行成功？"><a href="#如何保证两步都执行成功？" class="headerlink" title="如何保证两步都执行成功？"></a>如何保证两步都执行成功？</h4><p>前面我们分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。</p>
<p><strong>保证第二步成功执行，就是解决问题的关键。</strong></p>
<p>想一下，程序在执行过程中发生异常，最简单的解决办法是什么？</p>
<p>答案是：<strong>重试</strong>。</p>
<p>是的，其实这里我们也可以这样做。</p>
<p>无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」。</p>
<p>那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？</p>
<p>答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：</p>
<ul>
<li>立即重试很大概率「还会失败」</li>
<li>「重试次数」设置多少才合理？</li>
<li>重试会一直「占用」这个线程资源，无法服务其它客户端请求</li>
</ul>
<p>看到了么，虽然我们想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。</p>
<p>那更好的方案应该怎么做？</p>
<p>答案是：<strong>异步重试</strong>。什么是异步重试？</p>
<p>其实就是把重试请求写到<u>「消息队列」中，然后由专门的消费者来重试，直到成功。</u></p>
<p>或者更直接的做法，为了避免第二步执行失败，我们可以把<u>操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。</u></p>
<p>到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？</p>
<p>这个问题很好，但我们思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。</p>
<p>所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：</p>
<ul>
<li><strong>消息队列保证可靠性</strong>：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）</li>
<li><strong>消息队列保证消息成功投递</strong>：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）</li>
</ul>
<p>至于写队列失败和消息队列的维护成本问题：</p>
<ul>
<li><strong>写队列失败</strong>：操作缓存和写消息队列，「同时失败」的概率其实是很小的</li>
<li><strong>维护成本</strong>：我们项目中一般都会用到消息队列，维护成本并没有新增很多</li>
</ul>
<p>所以，引入消息队列来解决这个问题，是比较合适的。这时架构模型就变成了这样：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OezNCibL5S9oyeYqJBQVZCoNNyZnraolIYC8NntRZu8R0VpQp0iaXsohT5gjf4QpV0biah4iaRiaHOcyw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>那如果你确实不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？</p>
<p>方案还是有的，这就是近几年比较流行的解决方案：<strong>订阅数据库变更日志，再操作缓存</strong>。</p>
<p>具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。</p>
<p>那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。</p>
<p>拿 MySQL 举例<u>，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存</u>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OezNCibL5S9oyeYqJBQVZCowjAarwD2g3lIfCPsvhEHGaohPHVa47GR9d1GUgj0Eta1ketClKZjfw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：</p>
<ul>
<li><strong>无需考虑写消息队列失败情况</strong>：只要写 MySQL 成功，Binlog 肯定会有</li>
<li><strong>自动投递到下游队列</strong>：canal 自动把数据库变更日志「投递」给下游的消息队列</li>
</ul>
<p>当然，与此同时，我们需要投入精力去维护 canal 的高可用和稳定性。</p>
<blockquote>
<p>如果你有留意观察很多数据库的特性，就会发现其实很多数据库都逐渐开始提供「订阅变更日志」的功能了，相信不远的将来，我们就不用通过中间件来拉取日志，自己写程序就可以订阅变更日志了，这样可以进一步简化流程。</p>
</blockquote>
<p>至此，我们可以得出结论，想要保证数据库和缓存一致性，<strong>推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做</strong>。</p>
<h4 id="主从库延迟和延迟双删问题"><a href="#主从库延迟和延迟双删问题" class="headerlink" title="主从库延迟和延迟双删问题"></a>主从库延迟和延迟双删问题</h4><p>到这里，还有 2 个问题，是我们没有重点分析过的。</p>
<p><strong>第一个问题</strong>，还记得前面讲到的「先删除缓存，再更新数据库」方案，导致不一致的场景么？</p>
<p>这里我再把例子拿过来让你复习一下：</p>
<p>2 个线程要并发「读写」数据，可能会发生以下场景：</p>
<ol>
<li>线程 A 要更新 X = 2（原值 X = 1）</li>
<li>线程 A 先删除缓存</li>
<li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li>
<li>线程 A 将新值写入数据库（X = 2）</li>
<li>线程 B 将旧值写入缓存（X = 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p>
<p><strong>第二个问题</strong>：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。</p>
<p>在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：</p>
<ol>
<li>线程 A 更新主库 X = 2（原值 X = 1）</li>
<li>线程 A 删除缓存</li>
<li>线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）</li>
<li>从库「同步」完成（主从库 X = 2）</li>
<li>线程 B 将「旧值」写入缓存（X = 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。</p>
<p>看到了么？这 2 个问题的核心在于：<strong>缓存都被回种了「旧值」</strong>。</p>
<p>那怎么解决这类问题呢？</p>
<p>最有效的办法就是，<strong>把缓存删掉</strong>。</p>
<p>但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：<strong>缓存延迟双删策略</strong>。</p>
<p>按照延时双删策略，这 2 个问题的解决方案是这样的：</p>
<p><strong>解决第一个问题</strong>：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。</p>
<p><strong>解决第二个问题</strong>：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。</p>
<p>这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。</p>
<p>但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？</p>
<ul>
<li>问题1：延迟时间要大于「主从复制」的延迟时间</li>
<li>问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间</li>
</ul>
<p>但是，<strong>这个时间在分布式和高并发场景下，其实是很难评估的****。</strong></p>
<p>很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。</p>
<p>所以你看，采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。</p>
<p>所以实际使用中，我还是建议你采用「先更新数据库，再删除缓存」的方案，同时，要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。</p>
<h4 id="可以做到强一致吗？"><a href="#可以做到强一致吗？" class="headerlink" title="可以做到强一致吗？"></a>可以做到强一致吗？</h4><p>看到这里你可能会想，这些方案还是不够完美，我就想让缓存和数据库「强一致」，到底能不能做到呢？</p>
<p>其实很难。</p>
<p>要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。</p>
<p>相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？</p>
<p>没错，<strong>性能</strong>。</p>
<p>一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。</p>
<p>而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。</p>
<p>所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。</p>
<p>虽然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。</p>
<p>所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。</p>
<p>同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、想要提高应用的性能，可以引入「缓存」来解决</p>
<p>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」</p>
<p>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生</p>
<p>4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案</p>
<p>5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性</p>
<p>6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p>
<p>原文连接：</p>
<p><a href="https://mp.weixin.qq.com/s/D4Ik6lTA_ySBOyD3waNj1w">https://mp.weixin.qq.com/s/D4Ik6lTA_ySBOyD3waNj1w</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针旋转矩阵</title>
    <url>/2021/09/04/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E9%A1%BA%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个NxN整数矩阵，请编写一个算法，将矩阵顺时针旋转90度。</p>
<p>给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵,保证N小于等于300。</p>
<p><img src="/2021/09/04/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E9%A1%BA%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/image-20210904085736614.png" alt="image-20210904085736614"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先转置再交换第i列和n-i-1列</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] rotateMatrix(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=mat[i][j];</span><br><span class="line">                mat[i][j]=mat[j][i];</span><br><span class="line">                mat[j][i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=mat[i][j];</span><br><span class="line">                mat[i][j]=mat[i][n-j-<span class="number">1</span>];</span><br><span class="line">                mat[i][n-j-<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>括号生成</title>
    <url>/2021/09/03/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p>
<p>例如，给出n=3，解集为：</p>
<p>“((()))”, “(()())”, “(())()”, “()()()”, “()(())”,</p>
<p><img src="/2021/09/03/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/image-20210903092420259.png" alt="image-20210903092420259"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">generateParenthesis</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;String&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrace(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>,n,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(String string,<span class="keyword">int</span> open,<span class="keyword">int</span> close,<span class="keyword">int</span> n,List&lt;String&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(string.length()==n&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            result.add(string);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(open&lt;n)&#123;</span><br><span class="line">            backtrace(string+<span class="string">&#x27;(&#x27;</span>,open+<span class="number">1</span>,close,n,result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close&lt;open)&#123;</span><br><span class="line">            backtrace(string+<span class="string">&#x27;)&#x27;</span>,open,close+<span class="number">1</span>,n,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>判断二叉树是否对称</title>
    <url>/2021/09/02/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：下面这棵二叉树是对称的<br>1<br>/ <br>2  2<br>/ \  / <br>3 4 4 3<br>下面这棵二叉树不对称。<br>1<br>/ <br>2  2<br>\  <br>3  3</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>方法一：递归</p>
<p>方法二：迭代</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSym(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSym</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.val==right.val&amp;&amp;isSym(left.right,right.left)&amp;&amp;isSym(left.left,right.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-迭代-队列"><a href="#2-迭代-队列" class="headerlink" title="2.迭代(队列)"></a>2.迭代(队列)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root.left);</span><br><span class="line">        q.offer(root.right);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            TreeNode left = q.poll();</span><br><span class="line">            TreeNode right = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left.val != right.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">            q.offer(left.left);</span><br><span class="line">            q.offer(right.right);</span><br><span class="line">            q.offer(left.right);</span><br><span class="line">            q.offer(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的最大路径和</title>
    <url>/2021/09/02/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，请计算节点值之和最大的路径的节点值之和是多少。<br>这个路径的开始节点和结束节点可以是二叉树中的任意节点<br>例如：<br>给出以下的二叉树，<br><img src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786349381_11531EA9352057ACF47D25928F132E96" alt="img"><br>返回的结果为6</p>
<p><img src="/2021/09/02/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/image-20210902083107573.png" alt="image-20210902083107573"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>函数 <strong>maxGain</strong>(node)：计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。空节点的最大贡献值等于 0。非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）</p>
<p>对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 maxSum 存储最大路径和，在递归过程中更新 maxSum 的值，最后得到的 maxSum 的值即为二叉树中的最大路径和。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> maxSum=Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftGrain=Math.max(maxGain(node.left),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGrain=Math.max(maxGain(node.right),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> pathSum=node.val+leftGrain+rightGrain;</span><br><span class="line">        maxSum=Math.max(maxSum,pathSum);</span><br><span class="line">        <span class="keyword">return</span> node.val+Math.max(leftGrain,rightGrain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>奇偶链表重排</title>
    <url>/2021/09/01/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%E9%87%8D%E6%8E%92/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。</p>
<p>注意是节点的编号而非节点的数值。</p>
<p><img src="/2021/09/01/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%E9%87%8D%E6%8E%92/image-20210901092916548.png" alt="image-20210901092916548"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分别初始化奇链表和偶链表（带头节点的空链表）</span></span><br><span class="line">        ListNode l1=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode l2=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur1=l1;</span><br><span class="line">        ListNode cur2=l2;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历原链表，依次将各结点使用尾插法加入对应的链表中</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                cur1.next=head;</span><br><span class="line">                cur1=cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur2.next=head;</span><br><span class="line">                cur2=cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将偶链表的最后一个元素指向空</span></span><br><span class="line">        cur2.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//连接两个链表</span></span><br><span class="line">        cur1.next=l2.next;</span><br><span class="line">        <span class="keyword">return</span> l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>数组中未出现的最小正整数</title>
    <url>/2021/09/01/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无序数组arr，找到数组中未出现的最小正整数</p>
<p>例如arr = [-1, 2, 3, 4]。返回1</p>
<p>arr = [1, 2, 3, 4]。返回5</p>
<p>[要求]</p>
<p>时间复杂度为O(n)，空间复杂度为O(1)</p>
<p><img src="/2021/09/01/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0/image-20210901092017417.png" alt="image-20210901092017417"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * return the min number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberdisappered</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            set.add(arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(arr[i]-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr[i]-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[arr.length-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵元素查找</title>
    <url>/2021/09/01/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知int一个有序矩阵<strong>mat</strong>，同时给定矩阵的大小<strong>n</strong>和<strong>m</strong>以及需要查找的元素<strong>x</strong>，且矩阵的行和列都是从小到大有序的。设计查找算法返回所查找元素的二元数组，代表该元素的行号和列号(均从零开始)。保证元素互异。</p>
<p><img src="/2021/09/01/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E6%9F%A5%E6%89%BE/image-20210901091412087.png" alt="image-20210901091412087"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findElement(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// 从左下角开始查找</span></span><br><span class="line">        <span class="keyword">int</span> i=n-<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mat[i][j]==x)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mat[i][j]&gt;x)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>反转数字</title>
    <url>/2021/09/01/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%8F%8D%E8%BD%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>你有注意到翻转后的整数可能溢出吗？因为给出的是32位整数，则其数值范围为[−2^{31}, 2^{31} − 1][−231,231−1]。翻转可能会导致溢出，如果反转后的结果会溢出就返回 0。</p>
<p><img src="/2021/09/01/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%8F%8D%E8%BD%AC%E6%95%B0%E5%AD%97/image-20210901090718063.png" alt="image-20210901090718063"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            sign=-<span class="number">1</span>;</span><br><span class="line">            x=-x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;max/<span class="number">10</span>||(sum==max/<span class="number">10</span>&amp;&amp;(x%<span class="number">10</span>&gt;max%<span class="number">10</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;min/<span class="number">10</span>||(sum==min/<span class="number">10</span>&amp;&amp;(x%<span class="number">10</span>&lt;min%<span class="number">10</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum=sum*<span class="number">10</span>+sign*x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>将字符串转化为整数</title>
    <url>/2021/09/01/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现函数 atoi 。函数的功能为将字符串转化为整数</p>
<p>提示：仔细思考所有可能的输入情况。这个问题没有给出输入的限制，你需要自己考虑所有可能的情况。</p>
<p><img src="/2021/09/01/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0/image-20210901085359409.png" alt="image-20210901085359409"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">atoi</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//去空格</span></span><br><span class="line">        str=str.trim();</span><br><span class="line">        <span class="comment">//边界条件：判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否有符号位</span></span><br><span class="line">        <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">&#x27;-&#x27;</span>||str.charAt(<span class="number">0</span>)==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            sign=str.charAt(<span class="number">0</span>)==<span class="string">&#x27;-&#x27;</span>?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">            str=str.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:str.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c-<span class="string">&#x27;0&#x27;</span>&gt;=<span class="number">0</span>&amp;&amp;c-<span class="string">&#x27;0&#x27;</span>&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">              <span class="comment">//判断是否超过整形数的最大范围</span></span><br><span class="line">              <span class="keyword">if</span>(sum&gt;max/<span class="number">10</span>||(sum==max/<span class="number">10</span>&amp;&amp;(c-<span class="string">&#x27;0&#x27;</span>)&gt;max%<span class="number">10</span>))&#123;</span><br><span class="line">                  <span class="keyword">return</span> max;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(sum&lt;min/<span class="number">10</span>||(sum==min/<span class="number">10</span>&amp;&amp;(c-<span class="string">&#x27;0&#x27;</span>)&gt;-(min%<span class="number">10</span>)))&#123;</span><br><span class="line">                  <span class="keyword">return</span> min;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//累加求和</span></span><br><span class="line">              sum=sum*<span class="number">10</span>+sign*(c-<span class="string">&#x27;0&#x27;</span>);  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>判断一棵二叉树是否为搜索二叉树和完全二叉树</title>
    <url>/2021/08/31/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，已知其中的节点没有重复值，请判断该二叉树是否为搜索二叉树和完全二叉树。</p>
<p><img src="/2021/08/31/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210831094128043.png" alt="image-20210831094128043"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 the root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">boolean</span>[] judgeIt (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">boolean</span> res[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>]=isSerachTreeBST(root);</span><br><span class="line">        res[<span class="number">1</span>]=isAllTreeBST(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中序遍历判断是否为二叉搜索树</span></span><br><span class="line">    <span class="keyword">long</span> pre=Long.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSerachTreeBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isSerachTreeBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        <span class="keyword">return</span> isSerachTreeBST(root.right);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//层次遍历判断是否为完全二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllTreeBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Deque&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                root=queue.poll();</span><br><span class="line">                TreeNode left=root.left;</span><br><span class="line">                TreeNode right=root.right;</span><br><span class="line">                <span class="keyword">if</span>((flag&amp;&amp;!(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>))||left==<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    flag=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>最长公共序列II</title>
    <url>/2021/08/31/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%BA%8F%E5%88%97II/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回”-1”。目前给出的数据，仅仅会存在一个最长的公共子序列</p>
<p><img src="/2021/08/31/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%BA%8F%E5%88%97II/image-20210831085755477.png" alt="image-20210831085755477"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * longest common subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LCS</span> <span class="params">(String s1, String s2)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> m=s1.length();</span><br><span class="line">        <span class="keyword">int</span> n=s2.length();</span><br><span class="line">        <span class="keyword">int</span> dp[][]=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m,j=n;dp[i][j]&gt;=<span class="number">1</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                sb.append(s1.charAt(i-<span class="number">1</span>));</span><br><span class="line">                i--;j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>][j]&gt;dp[i][j-<span class="number">1</span>])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String res=sb.reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> res.equals(<span class="string">&quot;&quot;</span>)? <span class="string">&quot;-1&quot;</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>合并区间</title>
    <url>/2021/08/17/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一组区间，请合并所有重叠的区间。</p>
<p>请保证合并后的区间按区间起点升序排列。</p>
<p><img src="/2021/08/17/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/image-20210817110833089.png" alt="image-20210817110833089"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">merge</span><span class="params">(ArrayList&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(intervals,<span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval interval1 ,Interval interval2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1.start-interval2.start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals.get(i).start&lt;=intervals.get(i-<span class="number">1</span>).end)&#123;</span><br><span class="line">                intervals.get(i).start= Math.min(intervals.get(i-<span class="number">1</span>).start,intervals.get(i).start);</span><br><span class="line">                intervals.get(i).end=Math.max(intervals.get(i-<span class="number">1</span>).end,intervals.get(i).end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(intervals.get(i-<span class="number">1</span>)); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(intervals.get(intervals.size()-<span class="number">1</span>)); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树根节点到叶子节点和为指定值的路径</title>
    <url>/2021/08/17/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树和一个值\ sum <em>s<strong>u</strong>m</em>，请找出所有的根节点到叶子节点的节点值之和等于\ sum <em>s<strong>u</strong>m</em> 的路径，<br>例如：<br>给出如下的二叉树，\ sum=22 <em>s<strong>u</strong>m</em>=22，</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596785952017_5396804DA19E4F091E6360FD4BD0F4A5" alt="img"></p>
<p>返回<br>[<br>[5,4,11,2],<br>[5,8,9]<br>]</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathSum (TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        DFS(root,<span class="number">0</span>,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root,<span class="keyword">int</span> num,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num+=root.val;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==sum)&#123;</span><br><span class="line">               res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path)); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            DFS(root.left,num,sum);</span><br><span class="line">            DFS(root.right,num,sum); </span><br><span class="line">        &#125;</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>判断链表是否为回文</title>
    <url>/2021/08/13/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，请判断该链表是否为回文结构。</p>
<p><img src="/2021/08/13/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87/image-20210813110359015.png" alt="image-20210813110359015"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找到链表的中间结点，将链表后半部分反转，再判断前后两部分是否一样</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPail</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        <span class="comment">//快慢指针寻找中间结点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode l1=head;</span><br><span class="line">        <span class="comment">//慢指针的next即为后半部分的第一个节点</span></span><br><span class="line">        ListNode l2=slow.next;</span><br><span class="line">        l2=reverse(l2);</span><br><span class="line">        <span class="comment">//判断两部分是否相同</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val!=l2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l1=l1.next;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next=head.next;</span><br><span class="line">            head.next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>进制转换</title>
    <url>/2021/08/13/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个十进制数 M ，以及需要转换的进制数 N 。将十进制数 M 转化为 N 进制数。</p>
<p>当 N 大于 10 以后， 应在结果中使用大写字母表示大于 10 的一位，如 ‘A’ 表示此位为 10 ， ‘B’ 表示此位为 11 。</p>
<p>若 M 为负数，应在结果中保留负号。</p>
<p><img src="/2021/08/13/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20210813100029193.png" alt="image-20210813100029193"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进制转换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> M int整型 给定整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> N int整型 转换到的进制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        StringBuffer stringbuffer=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String t = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">        <span class="comment">//char[] array=new char[]&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;;</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(M&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            flag=<span class="keyword">false</span>;</span><br><span class="line">            M=-M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(M&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num=M%N;</span><br><span class="line">            stringbuffer.append(t.charAt(num));</span><br><span class="line">            M=M/N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            stringbuffer.append(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stringbuffer.reverse();</span><br><span class="line">        <span class="keyword">return</span> stringbuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>字符串出现TopK的问题</title>
    <url>/2021/08/12/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0TopK%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串数组，再给定整数k，请返回出现次数前k名的字符串和对应的次数。</p>
<p>返回的答案应该按字符串出现频率由高到低排序。如果不同的字符串有相同出现频率，按字典序排序。</p>
<p>对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。</p>
<p>比如”ah1x”小于”ahb”，”231”&lt;”32“</p>
<p>字符仅包含数字和字母</p>
<p>思路：哈希+排序</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * return topK string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strings string字符串一维数组 strings</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 the k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串二维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String[][] topKstrings (String[] strings, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历字符串数组，将每个字符串的出现次数存放在map中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strings.length;i++)&#123;</span><br><span class="line">            map.put(strings[i],map.getOrDefault(strings[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放入集合</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String ,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            String key=entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> count=entry.getValue();</span><br><span class="line">            List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(key);</span><br><span class="line">            list.add(String.valueOf(count));</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Collections.sort(res,<span class="keyword">new</span> Comparator&lt;List&lt;String&gt;&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(List&lt;String&gt; l1,List&lt;String&gt; l2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Integer.valueOf( l2.get(<span class="number">1</span>))!=Integer.valueOf(l1.get(<span class="number">1</span>)))&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.valueOf( l2.get(<span class="number">1</span>))-Integer.valueOf(l1.get(<span class="number">1</span>));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> l1.get(<span class="number">0</span>).compareTo(l2.get(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">         String ans[][]=<span class="keyword">new</span> String[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            ans[i][<span class="number">0</span>]=res.get(i).get(<span class="number">0</span>);</span><br><span class="line">            ans[i][<span class="number">1</span>]=res.get(i).get(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵的最小路径和</title>
    <url>/2021/08/11/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]</span><br><span class="line">返回值：12</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix int整型二维数组 the matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span> <span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界条件，考虑矩阵为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][]=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//第一列的最小路径和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j-<span class="number">1</span>]+matrix[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一行的最小路径和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+matrix[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次计算到每个元素的最小路径和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j]=matrix[i][j]+Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>单链表的排序</title>
    <url>/2021/08/10/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无序单链表，实现单链表的排序(按升序排序)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,3,2,4,5]</span><br><span class="line">返回值：&#123;1,2,3,4,5&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>插入排序——建立新的链表，将原链表中结点依次插入新链表中</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortInList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode newhead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next=cur.next;</span><br><span class="line">            insertNode(newhead,cur);</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在有序的链表中插入一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(ListNode newHead,ListNode node)</span></span>&#123;</span><br><span class="line">        ListNode pre=newHead;</span><br><span class="line">        ListNode cur=newHead.next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>&amp;&amp;cur.val&lt;node.val)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next=cur;</span><br><span class="line">        pre.next=node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>岛屿数量</title>
    <url>/2021/08/09/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</p>
<p>岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,1,0,0,0],[0,1,0,1,1],[0,0,0,1,1],[0,0,0,0,0],[0,0,1,1,1]]</span><br><span class="line">返回值：3</span><br></pre></td></tr></table></figure>



<h3 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h3><p>1.visit 代表是否访问过,res为结果。</p>
<p>2.未访问过的元素进行深度优先遍历，统计以当前元素为起点，遍历到的元素个数，大于0，代表以该元素为起点可连成岛屿，res+1;</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断岛屿数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grid char字符型二维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> m=grid.length;</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][]=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> visit[][]=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(!visit[i][j])&#123;</span><br><span class="line">                   <span class="keyword">int</span> count=dfs(visit,grid,i,j,<span class="number">0</span>,m,n);</span><br><span class="line">                   <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                       res+=<span class="number">1</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span> visit[][],<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> count,<span class="keyword">int</span> m ,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前元素已访问过或者为0 ，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]-<span class="string">&#x27;0&#x27;</span>==<span class="number">0</span>||visit[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历当前元素，辨识为已访问</span></span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]-<span class="string">&#x27;0&#x27;</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            count+=<span class="number">1</span>;</span><br><span class="line">            visit[i][j]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//上</span></span><br><span class="line">        <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i-<span class="number">1</span>][j]-<span class="string">&#x27;0&#x27;</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            dfs(visit,grid,i-<span class="number">1</span>,j,count,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;grid[i+<span class="number">1</span>][j]-<span class="string">&#x27;0&#x27;</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            dfs(visit,grid,i+<span class="number">1</span>,j,count,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i][j-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            dfs(visit,grid,i,j-<span class="number">1</span>,count,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n&amp;&amp;grid[i][j+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            dfs(visit,grid,i,j+<span class="number">1</span>,count,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h5><p>看到别人写的一种解法，似乎代码更简单哦。</p>
<p>思路：</p>
<p><u>遍历数组中的每一个值，如果是1就说明是岛屿，然后把它置为0或者其他的字符都可以</u>，只要不是1就行，然后再遍历他的上下左右4个位置。如果是1，说明这两个岛屿是连着的，只能算是一个岛屿，我们还要把它置为0，然后再以它为中心遍历他的上下左右4个位置……。如果是0，就说明不是岛屿，就不在往他的上下左右4个位置遍历了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//边界条件判断</span></span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计岛屿的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//两个for循环遍历每一个格子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">//只有当前格子是1才开始计算</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//如果当前格子是1，岛屿的数量加1</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//然后通过dfs把当前格子的上下左右4</span></span><br><span class="line">                <span class="comment">//个位置为1的都要置为0，因为他们是连着</span></span><br><span class="line">                <span class="comment">//一起的算一个岛屿，</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//最后返回岛屿的数量</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这个方***把当前格子以及他邻近的为1的格子都会置为1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//边界条件判断，不能越界</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//把当前格子置为0，然后再从他的上下左右4个方向继续遍历</span></span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j);<span class="comment">//上</span></span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j);<span class="comment">//下</span></span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>);<span class="comment">//左</span></span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>);<span class="comment">//右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：BFS"><a href="#方法二：BFS" class="headerlink" title="方法二：BFS"></a>方法二：BFS</h3><p>DFS就是沿着一条路径一直走下去，当遇到终止条件的时候才会返回，而BFS就是先把当前位置附近的访问一遍，就像下面这样先访问圈内的，然后再把圈放大继续访问，就像下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//边界条件判断</span></span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计岛屿的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//两个for循环遍历每一个格子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">//只有当前格子是1才开始计算</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//如果当前格子是1，岛屿的数量加1</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//然后通过bfs把当前格子的上下左右4</span></span><br><span class="line">                <span class="comment">//个位置为1的都要置为0，因为他们是连着</span></span><br><span class="line">                <span class="comment">//一起的算一个岛屿，</span></span><br><span class="line">                bfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把当前格子先置为0</span></span><br><span class="line">    grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> n = grid.length;</span><br><span class="line">    <span class="keyword">int</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//使用队列，存储的是格子坐标转化的值</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//我们知道平面坐标是两位数字，但队列中存储的是一位数字，</span></span><br><span class="line">    <span class="comment">//所以这里是把两位数字转化为一位数字</span></span><br><span class="line">    <span class="keyword">int</span> code = x * m + y;</span><br><span class="line">    <span class="comment">//坐标转化的值存放到队列中</span></span><br><span class="line">    queue.add(code);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//出队</span></span><br><span class="line">        code = queue.poll();</span><br><span class="line">        <span class="comment">//在反转成坐标值（i，j）</span></span><br><span class="line">        <span class="keyword">int</span> i = code / m;</span><br><span class="line">        <span class="keyword">int</span> j = code % m;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;<span class="comment">//上</span></span><br><span class="line">            <span class="comment">//如果上边格子为1，把它置为0，然后加入到队列中</span></span><br><span class="line">            <span class="comment">//下面同理</span></span><br><span class="line">            grid[i - <span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            queue.add((i - <span class="number">1</span>) * m + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;<span class="comment">//下</span></span><br><span class="line">            grid[i + <span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            queue.add((i + <span class="number">1</span>) * m + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">//左</span></span><br><span class="line">            grid[i][j - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            queue.add(i * m + j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; m - <span class="number">1</span> &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;<span class="comment">//右</span></span><br><span class="line">            grid[i][j + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            queue.add(i * m + j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>输出二叉树的右视图</title>
    <url>/2021/08/09/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请根据二叉树的前序遍历，中序遍历恢复二叉树，并打印出二叉树的右视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,4,5,3],[4,2,5,1,3]</span><br><span class="line">返回值：[1,3,5]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>1.构造二叉树</p>
<p>迭代构造二叉树，用map存放中序遍历的值及其索引，方便定位中序遍历中根节点位置。</p>
<p>2.输出右视图</p>
<p>结合队列，使用层次遍历，每一层最右边的结点集合即为右视图。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 求二叉树的右视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xianxu int整型一维数组 先序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zhongxu int整型一维数组 中序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solve (<span class="keyword">int</span>[] xianxu, <span class="keyword">int</span>[] zhongxu) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;zhongxu.length;i++)&#123;</span><br><span class="line">            map.put(zhongxu[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = build(xianxu,<span class="number">0</span>,xianxu.length-<span class="number">1</span>,zhongxu,<span class="number">0</span>,zhongxu.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res[]=getRightView(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getRightView(TreeNode root)&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()||size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//用sum统计每一层节点数</span></span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i==size-<span class="number">1</span>)&#123;</span><br><span class="line">                    array.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;</span><br><span class="line">            size=sum;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] xianxu,<span class="keyword">int</span> xstart,<span class="keyword">int</span> xend,<span class="keyword">int</span>[] zhongxu,<span class="keyword">int</span> zstart,<span class="keyword">int</span> zend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xstart&gt;xend)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootval=xianxu[xstart];</span><br><span class="line">        <span class="comment">//定位中序中根节点所在位置</span></span><br><span class="line">        <span class="keyword">int</span> zroot_index=map.get(rootval);</span><br><span class="line">        TreeNode node=<span class="keyword">new</span> TreeNode(rootval);</span><br><span class="line">        <span class="comment">//计算左子树长度</span></span><br><span class="line">        <span class="keyword">int</span> left_length=zroot_index-zstart;</span><br><span class="line">        node.left=build(xianxu,xstart+<span class="number">1</span>,xstart+left_length,zhongxu,zstart,zroot_index-<span class="number">1</span>);</span><br><span class="line">        node.right=build(xianxu,xstart+left_length+<span class="number">1</span>,xend,zhongxu,zroot_index+<span class="number">1</span>,zend);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>字符串的排列</title>
    <url>/2021/08/05/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<h5 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h5><p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;ab&quot;</span><br><span class="line">返回值：[&quot;ab&quot;,&quot;ba&quot;]</span><br><span class="line">说明：返回[&quot;ba&quot;,&quot;ab&quot;]也是正确的</span><br></pre></td></tr></table></figure>

<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;aab&quot;</span><br><span class="line">返回值：[&quot;aab&quot;,&quot;aba&quot;,&quot;baa&quot;]</span><br></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span>[] array=str.toCharArray();</span><br><span class="line">       <span class="keyword">boolean</span> visit[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[array.length]; </span><br><span class="line">       dfs(<span class="number">0</span>,array.length,array,<span class="keyword">new</span> StringBuffer(),visit);</span><br><span class="line">        ArrayList&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(String s:set)&#123;</span><br><span class="line">           res.add(s);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> n,<span class="keyword">char</span>[] array,StringBuffer stringbuffer,<span class="keyword">boolean</span> visit[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==n)&#123;</span><br><span class="line">            set.add(stringbuffer.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i])&#123;</span><br><span class="line">                stringbuffer.append(array[i]);</span><br><span class="line">                visit[i]=<span class="keyword">true</span>;</span><br><span class="line">                dfs(index+<span class="number">1</span>,n,array,stringbuffer,visit);</span><br><span class="line">                visit[i]=<span class="keyword">false</span>;</span><br><span class="line">                stringbuffer.deleteCharAt(stringbuffer.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>买卖股票的最好时机</title>
    <url>/2021/08/05/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你有一个数组，其中第\ i <em>i</em> 个元素是股票在第\ i <em>i</em> 天的价格。<br>你有一次买入和卖出的机会。（只有买入了股票以后才能卖出）。请你设计一个算法来计算可以获得的最大收益。</p>
<p><img src="/2021/08/05/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/image-20210805090802999.png" alt="image-20210805090802999"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> min=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            min=Math.min(min,prices[i]);</span><br><span class="line">            ans=Math.max(ans,prices[i]-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>在旋转过的有序数组中寻找目标值</title>
    <url>/2021/07/29/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%9C%A8%E6%97%8B%E8%BD%AC%E8%BF%87%E7%9A%84%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AF%BB%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组nums，按升序排序，数组中的元素各不相同。</p>
<p>nums数组在传递给search函数之前，会在预先未知的某个下标 t（0 &lt;= t &lt;= nums.length-1）上进行旋转，让数组变为[nums[t], nums[t+1], …, nums[nums.length-1], nums[0], nums[1], …, nums[t-1]]。</p>
<p>比如，数组[0,2,4,6,8,10]在下标3处旋转之后变为[6,8,10,0,2,4]</p>
<p>现在给定一个旋转后的数组nums和一个整数target，请你查找这个数组是不是存在这个target，如果存在，那么返回它的下标，如果不存在，返回-1</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(right-left)/<span class="number">2</span>+left;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    </span><br><span class="line">                    right=mid-<span class="number">1</span>;</span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&lt;=nums[right]&amp;&amp;target&gt;nums[mid])&#123;</span><br><span class="line">                    </span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>最长递增子序列</title>
    <url>/2021/07/29/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中 按数值(注：区别于按单个字符的ASCII码值)进行比较的 字典序最小的那个）</p>
<p><img src="/2021/07/29/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/image-20210729094433184.png" alt="image-20210729094433184"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>*<strong>下面的“标号”讲的过于抽象，我推荐*</strong><a href="https://www.cnblogs.com/kyoner/p/11216871.html">《最长递增子序列 - murphy_gb - 博客园》</a> *<strong>这篇文章，里面的动图很形象。*</strong></p>
<ol>
<li>我们将大问题拆分为小问题，把数组缩短，再慢慢加长直到完整。如示例 1 中 原数组 arr = [2, 1, 5, 3, 6, 4, 8, 9, 7] 我们把最初的子问题定为 [2, 1]，下一个子问题既往后加长一位 [2, 1, 5]，以此类推。</li>
<li>为了能在遍历完子问题后精确地在原数组 arr 中找出组成最长递增子序列 LCS 的元素，我们可以使用“标号”的方法，在 arr 中组成 LCS 的元素上标上序号，比如示例 1 中 arr = [2, 1, 5, 3, 6, 4, 8, 9, 7]， LCS = [1, 3, 4, 8, 9]，LCS[<strong>0</strong>] = arr[1]，LCS[<strong>1</strong>] = arr[3]，LCS[<strong>2</strong>] = arr[5]。所以如何标号就是这个问题的关键。<br><img src="https://uploadfiles.nowcoder.com/images/20210128/407335859_1611800854641/8A5F006FFD4CE801C8E888EC3BC68361" alt="图片说明"></li>
<li>如何标号呢？我们需要新增一个数组 temp，每当子问题增加一个元素 e 时，e 就与 temp 最后一个元素就进行比较，如果 e 比 temp 的最后一个元素大，则直接在 temp 最后面添加 e；反之，则在 temp 中从左往右寻找第一个比 e 大的数，并用 e 替换之。然后 e 在 temp 中的索引就是我们要找的标号，我们将标号存起来，继续下一个子问题。<br><img src="https://uploadfiles.nowcoder.com/images/20210128/407335859_1611805192096/8A5F006FFD4CE801C8E888EC3BC68361" alt="图片说明"></li>
<li>在 nums 中标完号后，为了满足题目要求的字典序最小，我们需要从后往前遍历，标号从大到小，倒着填入 LCS 中，最后我们获得结果 LCS。<br><img src="https://uploadfiles.nowcoder.com/images/20210128/407335859_1611805550455/8A5F006FFD4CE801C8E888EC3BC68361" alt="图片说明"></li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * retrun the longest increasing subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LIS (<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">int</span> nums[]=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        nums[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempIndex=<span class="number">0</span>;</span><br><span class="line">        temp[tempIndex]=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;temp[tempIndex])&#123;</span><br><span class="line">                ++tempIndex;</span><br><span class="line">                nums[i]=tempIndex;</span><br><span class="line">                temp[tempIndex]=arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> l=<span class="number">0</span>,r=tempIndex;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(temp[mid]&gt;=arr[i])&#123;</span><br><span class="line">                        r=mid-<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        l=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                temp[l]=arr[i];</span><br><span class="line">                nums[i]=l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res[]=<span class="keyword">new</span> <span class="keyword">int</span>[tempIndex+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==tempIndex)&#123;</span><br><span class="line">                res[tempIndex]=arr[i];</span><br><span class="line">                tempIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>数组中相加和为0的三元组</title>
    <url>/2021/07/29/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E5%8A%A0%E5%92%8C%E4%B8%BA0%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。</p>
<p>注意：</p>
<ol>
<li>三元组（a、b、c）中的元素必须按非降序排列。（即a≤b≤c）</li>
<li>解集中不能包含重复的三元组。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定的数组 S &#x3D; &#123;-10 0 10 20 -10 -40&#125;,解集为(-10, -10, 20),(-10, 0, 10) </span><br><span class="line">0 &lt;&#x3D; S.length &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>（1）首先对数组进行排序（从小到大）<br>（2）依次取出第 i 个数（i从0开始），并且不重复的选取（跳过重复的数）<br>（3）这样问题就转换为 2 个数求和的问题（可以用双指针解决方法）<br>==》数求和问题<br>（4）定义两个指针：左指针（left） 和 右指针（right）<br>（5）找出固定 left， 此时left所指的位置为数组中最小数，再找到两个数和 不大于 target 的最大 right 的位置<br>（6）调整 left 的位置（后移），求解和是否为 target O(n)<br>==》时间复杂度：O(nlogn) + O(n)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span>||num.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;num[i]==num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> L=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R=num.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=num[i]+num[L]+num[R];</span><br><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(num[i]);</span><br><span class="line">                    list.add(num[L]);</span><br><span class="line">                    list.add(num[R]);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R&amp;&amp;num[L]==num[L+<span class="number">1</span>])&#123;</span><br><span class="line">                        L++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R&amp;&amp;num[R]==num[R-<span class="number">1</span>])&#123;</span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    L++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>重建二叉树</title>
    <url>/2021/07/28/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定某二叉树的前序遍历和中序遍历，请重建出该二叉树并返回它的头结点。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length==<span class="number">0</span>||in.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;in.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==pre[<span class="number">0</span>])&#123;</span><br><span class="line">                root.left=reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="number">1</span>,i+<span class="number">1</span>),</span><br><span class="line">                                               Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">                root.right=reConstructBinaryTree(Arrays.copyOfRange(pre,i+<span class="number">1</span>,pre.length),</span><br><span class="line">                                               Arrays.copyOfRange(in,i+<span class="number">1</span>,in.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2021/07/28/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/07/28/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/image-20210728085557296.png" alt="image-20210728085557296"></p>
<h3 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h3><p>定义二维数组<code>dp[length][length]</code>，如果<code>dp[left][right]</code>为true，则表示字符串从left到right是回文子串，如果<code>dp[left][right]</code>为false，则表示字符串从<code>left</code>到<code>right</code>不是回文子串。</p>
<p>如果<code>dp[left+1][right-1]</code>为true，我们判断<code>s.charAt(left)</code>和<code>s.charAt(right)</code>是否相等，如果相等，那么<code>dp[left][right]</code>肯定也是回文子串，否则<code>dp[left][right]</code>一定不是回文子串。</p>
<p>所以我们可以找出递推公式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[left][right]&#x3D;s.charAt(left)&#x3D;&#x3D;s.charAt(right)&amp;&amp;dp[left+&#96;&#96;1&#96;&#96;][right-&#96;&#96;1&#96;&#96;]</span><br></pre></td></tr></table></figure>

<p>有了递推公式，还要确定边界条件：</p>
<p>**如果s.charAt(left)！=s.charAt(right)**，那么字符串从left到right是不可能构成子串的，直接跳过即可。</p>
<p>**如果s.charAt(left)==s.charAt(right)**，字符串从left到right能不能构成回文子串还需要进一步判断</p>
<ul>
<li>如果<code>left==right</code>，也就是说只有一个字符，我们认为他是回文子串。即<code>dp[left][right]=true（left==right）</code></li>
<li>如果<code>right-left&lt;=2</code>，类似于<code>&quot;aa&quot;</code>，或者<code>&quot;aba&quot;</code>，我们认为他是回文子串。即<code>dp[left][right]=true（right-left&lt;=2）</code></li>
<li>如果<code>right-left&gt;2</code>，我们只需要判断<code>dp[left+1][right-1]</code>是否是回文子串，才能确定<code>dp[left][right]</code>是否为true还是false。即<code>dp[left][right]=dp[left+1][right-1]</code></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLongestPalindrome</span><span class="params">(String A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> A.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> dp[][]=<span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=<span class="number">1</span>;right&lt;n;right++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>;left&lt;right;left++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A.charAt(left)!=A.charAt(right))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right==left)&#123;</span><br><span class="line">                    dp[left][right]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right-left&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                    dp[left][right]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[left][right]=dp[left+<span class="number">1</span>][right-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[left][right]&amp;&amp;right-left+<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">                    maxLen=right-left+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-中心扩散"><a href="#2-中心扩散" class="headerlink" title="2. 中心扩散"></a>2. 中心扩散</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLongestPalindrome</span><span class="params">(String A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//边界条件判断</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> A.length();</span><br><span class="line">    <span class="comment">//maxLen表示最长回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">        <span class="comment">//如果剩余子串长度小于目前查找到的最长回文子串的长度，直接终止循环</span></span><br><span class="line">        <span class="comment">// （因为即使他是回文子串，也不是最长的，所以直接终止循环，不再判断）</span></span><br><span class="line">        <span class="keyword">if</span> (n - i &lt;= maxLen / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> left = i;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n - <span class="number">1</span> &amp;&amp; A.charAt(right + <span class="number">1</span>) == A.charAt(right))</span><br><span class="line">            ++right; <span class="comment">//过滤掉重复的</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//下次在判断的时候从重复的下一个字符开始判断</span></span><br><span class="line">        i = right + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//然后往两边判断，找出回文子串的长度</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n - <span class="number">1</span> &amp;&amp; left &gt; <span class="number">0</span> &amp;&amp; A.charAt(right + <span class="number">1</span>) == A.charAt(left - <span class="number">1</span>)) &#123;</span><br><span class="line">            ++right;</span><br><span class="line">            --left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保留最长的</span></span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">            maxLen = right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//截取回文子串</span></span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2021/07/27/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/07/27/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/image-20210727091534175.png" alt="image-20210727091534175"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> top=<span class="number">0</span>,bottom=matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(top&lt;=bottom&amp;&amp;left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">                array.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;=bottom;i++)&#123;</span><br><span class="line">                array.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right-<span class="number">1</span>;i&gt;=left&amp;&amp;top&lt;bottom;i--)&#123;</span><br><span class="line">                array.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom-<span class="number">1</span>;i&gt;top&amp;&amp;left&lt;right;i--)&#123;</span><br><span class="line">                array.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            </span><br><span class="line">            bottom--;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>在二叉树中找到两个节点的最近公共祖先</title>
    <url>/2021/07/27/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/07/27/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210727084836876.png" alt="image-20210727084836876"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> CommonAncester(root,o1,o2).val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">CommonAncester</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>||root.val==o1||root.val==o2) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left=CommonAncester(root.left,o1,o2);</span><br><span class="line">        TreeNode right=CommonAncester(root.right,o1,o2);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>课程表</title>
    <url>/2021/06/21/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/21/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E8%AF%BE%E7%A8%8B%E8%A1%A8/image-20210621211048611.png" alt="image-20210621211048611"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h4><p><img src="/2021/06/21/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E8%AF%BE%E7%A8%8B%E8%A1%A8/image-20210621211138828.png" alt="image-20210621211138828"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/21/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E8%AF%BE%E7%A8%8B%E8%A1%A8/image-20210621211216853.png" alt="image-20210621211216853"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>拓扑排序</category>
      </categories>
  </entry>
  <entry>
    <title>经典算法</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-LRU缓存机制"><a href="#1-LRU缓存机制" class="headerlink" title="1.LRU缓存机制"></a>1.LRU缓存机制</h2><p><img src="/2021/06/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/image-20210619214356269.png" alt="image-20210619214356269"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value)</span> </span>&#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode newNode = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode tail = removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DLinkedNode <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode res = tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-手写单例模式"><a href="#2-手写单例模式" class="headerlink" title="2.手写单例模式"></a>2.手写单例模式</h2><h4 id="饿汉式：（线程安全）"><a href="#饿汉式：（线程安全）" class="headerlink" title="饿汉式：（线程安全）"></a>饿汉式：（线程安全）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="懒汉式：-线程不安全，可加同步锁变成线程安全"><a href="#懒汉式：-线程不安全，可加同步锁变成线程安全" class="headerlink" title="懒汉式：(线程不安全，可加同步锁变成线程安全)"></a>懒汉式：(线程不安全，可加同步锁变成线程安全)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法总结</category>
        <category>经典算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p><img src="/2021/06/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210619211516079.png" alt="image-20210619211516079"></p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始时 swapped 为 true，否则排序过程无法启动</span></span><br><span class="line">    <span class="keyword">boolean</span> swapped = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果没有发生过交换，说明剩余部分已经有序，排序完成</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 设置 swapped 为 false，如果发生交换，则将其置为 true</span></span><br><span class="line">        swapped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 表示发生了交换</span></span><br><span class="line">                swapped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] </span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><img src="/2021/06/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210619211709752.png" alt="image-20210619211709752"></p>
<h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h2><p><img src="/2021/06/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210619211806246.png" alt="image-20210619211806246"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果区域内的数字少于 2 个，退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="keyword">int</span> middle = partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第一个数为基数</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">    <span class="comment">// 从第二个数开始分区</span></span><br><span class="line">    <span class="keyword">int</span> left = start + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右边界</span></span><br><span class="line">    <span class="keyword">int</span> right = end;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于基数的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;</span><br><span class="line">        <span class="comment">// 找到第一个小于基数的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) right--;</span><br><span class="line">        <span class="comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            exchange(arr, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span></span><br><span class="line">    <span class="keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;</span><br><span class="line">    <span class="comment">// 将基数和轴交换</span></span><br><span class="line">    exchange(arr, start, right);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><img src="/2021/06/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210619212108647.png" alt="image-20210619212108647"></p>
<h2 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3. 堆排序"></a>3. 堆排序</h2><p><img src="/2021/06/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210619212203578.png" alt="image-20210619212203578"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建初始大顶堆</span></span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将最大值交换到数组最后</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">// 调整剩余数组，使其满足大顶堆</span></span><br><span class="line">        maxHeapify(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建初始大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxHeapify(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子结点下标</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右子结点下标</span></span><br><span class="line">    <span class="keyword">int</span> r = l + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 记录根结点、左子树结点、右子树结点三者中的最大值下标</span></span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="comment">// 与左子树结点比较</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与右子树结点比较</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="comment">// 将最大值交换为根结点</span></span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        <span class="comment">// 再次调整交换数字后的大顶堆</span></span><br><span class="line">        maxHeapify(arr, largest, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210619212256351.png" alt="image-20210619212256351"></p>
]]></content>
      <categories>
        <category>算法总结</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title>根据字符出现频率排序</title>
    <url>/2021/06/12/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/12/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/image-20210612092613306.png" alt="image-20210612092613306"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><p><strong>思路一：直接排序</strong></p>
<p>首先遍历字符串，用哈希表记录每个字符出现的次数<br>然后获取哈希表中的键值对，根据value进行降序排列<br>遍历排列后的结果，将字符根据其出现次数加到最终结果res中去</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            count.put(c, count.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Map.Entry&lt;Character, Integer&gt;&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;(count.entrySet());</span><br><span class="line">        items.sort((o1, o2) -&gt; o2.getValue() - o1.getValue());</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Integer&gt; item : items)&#123;</span><br><span class="line">            <span class="keyword">char</span> key = item.getKey();</span><br><span class="line">            <span class="keyword">int</span> val = item.getValue();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val; i++)&#123;</span><br><span class="line">                res.append(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/12/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/image-20210612092731750.png" alt="image-20210612092731750"></p>
<h4 id="思路二：最大堆"><a href="#思路二：最大堆" class="headerlink" title="思路二：最大堆"></a>思路二：最大堆</h4><p>首先遍历字符串，用哈希表记录每个字符出现的次数<br>然后把哈希表中的键值对加到堆中，按照value形成最大堆<br>循环弹出堆中的value最大的字符，将字符根据其出现次数加到res中</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            count.put(c, count.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; items = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2.getValue() - o1.getValue());</span><br><span class="line">        items.addAll(count.entrySet());</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!items.isEmpty())&#123;</span><br><span class="line">            Map.Entry&lt;Character, Integer&gt; item = items.poll();</span><br><span class="line">            <span class="keyword">char</span> key = item.getKey();</span><br><span class="line">            <span class="keyword">int</span> val = item.getValue();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val; i++)&#123;</span><br><span class="line">                res.append(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/12/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/image-20210612092829548.png" alt="image-20210612092829548"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title>前K个高频元素</title>
    <url>/2021/06/11/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/11/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/image-20210611093639659.png" alt="image-20210611093639659"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：堆"><a href="#方法一：堆" class="headerlink" title="方法一：堆"></a>方法一：堆</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/06/11/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/image-20210611093701091.png" alt="image-20210611093701091"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; occurrences = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            occurrences.put(num, occurrences.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] m, <span class="keyword">int</span>[] n)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> m[<span class="number">1</span>] - n[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = entry.getKey(), count = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (queue.size() == k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek()[<span class="number">1</span>] &lt; count) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ret[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/11/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/image-20210611093741883.png" alt="image-20210611093741883"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title>数组中的第K个最大元素</title>
    <url>/2021/06/11/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/11/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/image-20210611091015473.png" alt="image-20210611091015473"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法二：基于堆排序的选择方法"><a href="#方法二：基于堆排序的选择方法" class="headerlink" title="方法二：基于堆排序的选择方法"></a>方法二：基于堆排序的选择方法</h4><p><strong>思路和算法</strong></p>
<p><img src="/2021/06/11/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/image-20210611091049099.png" alt="image-20210611091049099"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heapSize = nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/11/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%8E%92%E5%BA%8F/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/image-20210611091126932.png" alt="image-20210611091126932"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>不同的二叉搜索树II</title>
    <url>/2021/06/10/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/10/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/image-20210610091602869.png" alt="image-20210610091602869"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/06/10/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/image-20210610091625083.png" alt="image-20210610091625083"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            allTrees.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode left : leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode right : rightTrees) &#123;</span><br><span class="line">                    TreeNode currTree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    currTree.left = left;</span><br><span class="line">                    currTree.right = right;</span><br><span class="line">                    allTrees.add(currTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/10/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/image-20210610091704693.png" alt="image-20210610091704693"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>分治</category>
      </categories>
  </entry>
  <entry>
    <title>为运算表达式设计优先级</title>
    <url>/2021/06/10/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/10/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/image-20210610090107953.png" alt="image-20210610090107953"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; curRes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = input.length();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = input.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> aChar = charArray[i];</span><br><span class="line">            <span class="keyword">if</span> (aChar == <span class="string">&#x27;+&#x27;</span> || aChar == <span class="string">&#x27;-&#x27;</span> || aChar == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// 当前字符为 操作符</span></span><br><span class="line">                List&lt;Integer&gt; leftList = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; rightList = diffWaysToCompute(input.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> leftNum : leftList) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> rightNum : rightList) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (aChar == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                            curRes.add(leftNum + rightNum);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aChar == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                            curRes.add(leftNum - rightNum);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            curRes.add(leftNum * rightNum);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curRes.isEmpty()) &#123;</span><br><span class="line">            curRes.add(Integer.valueOf(input));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>分治</category>
      </categories>
  </entry>
  <entry>
    <title>两个字符串的删除操作</title>
    <url>/2021/06/09/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>[力扣]:</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>买卖股票的最佳时机IV</title>
    <url>/2021/06/08/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/08/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/image-20210608091147505.png" alt="image-20210608091147505"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/06/08/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/image-20210608091210204.png" alt="image-20210608091210204"></p>
<p><img src="/2021/06/08/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/image-20210608091217881.png" alt="image-20210608091217881"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        k = Math.min(k, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span>[][] buy = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] sell = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        buy[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sell[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            buy[<span class="number">0</span>][i] = sell[<span class="number">0</span>][i] = Integer.MIN_VALUE / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy[i][<span class="number">0</span>] = Math.max(buy[i - <span class="number">1</span>][<span class="number">0</span>], sell[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                buy[i][j] = Math.max(buy[i - <span class="number">1</span>][j], sell[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                sell[i][j] = Math.max(sell[i - <span class="number">1</span>][j], buy[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(sell[n - <span class="number">1</span>]).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/08/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/image-20210608091259063.png" alt="image-20210608091259063"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>买卖股票的最佳时机含手续费</title>
    <url>/2021/06/08/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/08/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/image-20210608083118637.png" alt="image-20210608083118637"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/06/08/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/image-20210608083141375.png" alt="image-20210608083141375"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/08/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/image-20210608083222965.png" alt="image-20210608083222965"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>组合总数Ⅳ</title>
    <url>/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0%E2%85%A3/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0%E2%85%A3/image-20210605093752515.png" alt="image-20210605093752515"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0%E2%85%A3/image-20210605093817994.png" alt="image-20210605093817994"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= i) &#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0%E2%85%A3/image-20210605093856804.png" alt="image-20210605093856804"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>单词拆分</title>
    <url>/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/image-20210605092516594.png" alt="image-20210605092516594"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路和算法</strong></p>
<p><img src="/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/image-20210605092543323.png" alt="image-20210605092543323"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/image-20210605092614701.png" alt="image-20210605092614701"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>零钱兑换</title>
    <url>/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/image-20210605090454683.png" alt="image-20210605090454683"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h4><p><strong>算法</strong></p>
<p><img src="/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/image-20210605090528660.png" alt="image-20210605090528660"></p>
<p><img src="/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/image-20210605090541687.png" alt="image-20210605090541687"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/05/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/image-20210605090614125.png" alt="image-20210605090614125"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>零钱兑换II</title>
    <url>/2021/06/04/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/04/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%9B%AE%E6%A0%87%E5%92%8C/image-20210604095223762.png" alt="image-20210604095223762"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法：动态规划"><a href="#方法：动态规划" class="headerlink" title="方法：动态规划"></a>方法：动态规划</h4><p><strong>算法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = coin; x &lt; amount + <span class="number">1</span>; ++x) &#123;</span><br><span class="line">        dp[x] += dp[x - coin];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/04/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%9B%AE%E6%A0%87%E5%92%8C/image-20210604095322937.png" alt="image-20210604095322937"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>零钱兑换II</title>
    <url>/2021/06/04/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II/</url>
    <content><![CDATA[<p>[力扣]:</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>一和零</title>
    <url>/2021/06/04/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%80%E5%92%8C%E9%9B%B6/</url>
    <content><![CDATA[<p>[力扣]:</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>分割等和子集</title>
    <url>/2021/06/03/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/03/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/image-20210603093014930.png" alt="image-20210603093014930"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/06/03/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/image-20210603093056516.png" alt="image-20210603093056516"></p>
<p><img src="/2021/06/03/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/image-20210603093111187.png" alt="image-20210603093111187"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = Math.max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= num) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/03/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/image-20210603093155201.png" alt="image-20210603093155201"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2021/06/03/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/03/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/image-20210603085616934.png" alt="image-20210603085616934"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="/2021/06/03/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/image-20210603085655251.png" alt="image-20210603085655251"></p>
<p><img src="/2021/06/03/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/image-20210603085719629.png" alt="image-20210603085719629"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = text1.charAt(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = text2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/03/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/image-20210603085755636.png" alt="image-20210603085755636"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>摆动序列</title>
    <url>/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/image-20210602101440051.png" alt="image-20210602101440051"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><p><img src="/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/image-20210602101818554.png" alt="image-20210602101818554"></p>
<h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路及解法</strong></p>
<p><img src="/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/image-20210602101852274.png" alt="image-20210602101852274"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        up[<span class="number">0</span>] = down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up[i] = Math.max(up[i - <span class="number">1</span>], down[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = Math.max(up[i - <span class="number">1</span>] + <span class="number">1</span>, down[i - <span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up[n - <span class="number">1</span>], down[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/image-20210602101931068.png" alt="image-20210602101931068"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>最长数对链</title>
    <url>/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/image-20210602092544257.png" alt="image-20210602092544257"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路</strong></p>
<p><img src="/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/image-20210602092609892.png" alt="image-20210602092609892"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(pairs, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> N = pairs.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pairs[i][<span class="number">1</span>] &lt; pairs[j][<span class="number">0</span>])</span><br><span class="line">                    dp[j] = Math.max(dp[j], dp[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: dp) <span class="keyword">if</span> (x &gt; ans) ans = x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/image-20210602092652639.png" alt="image-20210602092652639"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>最长递增子序列</title>
    <url>/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/image-20210602085549012.png" alt="image-20210602085549012"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/image-20210602085759005.png" alt="image-20210602085759005"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/06/02/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/image-20210602085849141.png" alt="image-20210602085849141"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>解码方法</title>
    <url>/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/image-20210531094134693.png" alt="image-20210531094134693"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/image-20210531094213318.png" alt="image-20210531094213318"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;0&#x27;</span> &amp;&amp; ((s.charAt(i - <span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>)) &#123;</span><br><span class="line">                f[i] += f[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)O(n)，其中 nn 是字符串 ss 的长度。</p>
<p>空间复杂度：O(n)O(n) 或 O(1)O(1)。如果使用数组进行状态转移，空间复杂度为 O(n)O(n)；如果仅使用三个变量，空间复杂度为 O(1)O(1)。</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>完全平方数</title>
    <url>/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/image-20210531091406973.png" alt="image-20210531091406973"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/image-20210531091506143.png" alt="image-20210531091506143"></p>
<p><img src="/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/image-20210531091523823.png" alt="image-20210531091523823"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// bottom case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pre-calculate the square numbers.</span></span><br><span class="line">    <span class="keyword">int</span> max_square_index = (<span class="keyword">int</span>) Math.sqrt(n) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> square_nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[max_square_index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max_square_index; ++i) &#123;</span><br><span class="line">      square_nums[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; max_square_index; ++s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; square_nums[s])</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        dp[i] = Math.min(dp[i], dp[i - square_nums[s]] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/image-20210531091601585.png" alt="image-20210531091601585"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>整数拆分</title>
    <url>/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/image-20210531083650429.png" alt="image-20210531083650429"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/image-20210531083750652.png" alt="image-20210531083750652"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = curMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/31/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/image-20210531083829052.png" alt="image-20210531083829052"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>等差数列划分</title>
    <url>/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/image-20210528092443971.png" alt="image-20210528092443971"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：-暴力"><a href="#方法一：-暴力" class="headerlink" title="方法一： 暴力"></a>方法一： 暴力</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; A.length - <span class="number">2</span>; s++) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = A[s + <span class="number">1</span>] - A[s];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = s + <span class="number">2</span>; e &lt; A.length; e++) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = s + <span class="number">1</span>; i &lt;= e; i++)</span><br><span class="line">                    <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] != d)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; e)</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/image-20210528092526709.png" alt="image-20210528092526709"></p>
<h4 id="方法二：-动态规划"><a href="#方法二：-动态规划" class="headerlink" title="方法二： 动态规划"></a>方法二： 动态规划</h4><p><strong>算法</strong></p>
<p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/image-20210528092646390.png" alt="image-20210528092646390"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span> + dp[i - <span class="number">1</span>];</span><br><span class="line">                sum += dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/image-20210528092717236.png" alt="image-20210528092717236"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>区域和检索-数组不可变</title>
    <url>/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/image-20210528085250220.png" alt="image-20210528085250220"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：前缀和"><a href="#方法一：前缀和" class="headerlink" title="方法一：前缀和"></a>方法一：前缀和</h4><p><strong>思路</strong></p>
<p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/image-20210528085323437.png" alt="image-20210528085323437"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/image-20210528085411834.png" alt="image-20210528085411834"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>最小路径和</title>
    <url>/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/image-20210528083651458.png" alt="image-20210528083651458"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/image-20210528083717923.png" alt="image-20210528083717923"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/image-20210528083748908.png" alt="image-20210528083748908"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>最小路径和</title>
    <url>/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/image-20210528082930254.png" alt="image-20210528082930254"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/image-20210528082954475.png" alt="image-20210528082954475"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length, columns = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][columns - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/28/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/image-20210528083030646.png" alt="image-20210528083030646"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>打家劫舍II</title>
    <url>/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/image-20210527091806357.png" alt="image-20210527091806357"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/image-20210527091839740.png" alt="image-20210527091839740"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robRange(nums, <span class="number">0</span>, length - <span class="number">2</span>), robRange(nums, <span class="number">1</span>, length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = nums[start], second = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = Math.max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/image-20210527091920719.png" alt="image-20210527091920719"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>打家劫舍</title>
    <url>/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/image-20210527085942241.png" alt="image-20210527085942241"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/image-20210527090010450.png" alt="image-20210527090010450"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = Math.max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/image-20210527090139366.png" alt="image-20210527090139366"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>算法思想</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20210527083449424.png" alt="image-20210527083449424"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路和算法</strong></p>
<p><img src="/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20210527083529753.png" alt="image-20210527083529753"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/27/%E5%8A%9B%E6%89%A3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20210527083604063.png" alt="image-20210527083604063"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>位运算</category>
      </categories>
  </entry>
  <entry>
    <title>只出现一次的数字III</title>
    <url>/2021/05/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E8%BF%90%E7%AE%97/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E8%BF%90%E7%AE%97/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/image-20210526084655213.png" alt="image-20210526084655213"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：分组异或"><a href="#方法一：分组异或" class="headerlink" title="方法一：分组异或"></a>方法一：分组异或</h4><p><strong>思路</strong></p>
<p><img src="/2021/05/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E8%BF%90%E7%AE%97/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/image-20210526084724468.png" alt="image-20210526084724468"></p>
<p><strong>算法</strong></p>
<p>先对所有数字进行一次异或，得到两个出现一次的数字的异或值。</p>
<p>在异或结果中找到任意为 11 的位。</p>
<p>根据这一位对所有的数字进行分组。</p>
<p>在每个组内进行异或操作，得到两个数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            ret ^= n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>) &#123;</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((div &amp; n) != <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E8%BF%90%E7%AE%97/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/image-20210526084805641.png" alt="image-20210526084805641"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>位运算</category>
      </categories>
  </entry>
  <entry>
    <title>只出现一次的数字</title>
    <url>/2021/05/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E8%BF%90%E7%AE%97/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E8%BF%90%E7%AE%97/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/image-20210526082604529.png" alt="image-20210526082604529"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><p>数组中的全部元素的异或运算结果即为数组中只出现一次的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E8%BF%90%E7%AE%97/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/image-20210526082655618.png" alt="image-20210526082655618"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>计数二进制子串</title>
    <url>/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/image-20210525090503365.png" alt="image-20210525090503365"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：按字符分组"><a href="#方法一：按字符分组" class="headerlink" title="方法一：按字符分组"></a>方法一：按字符分组</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/image-20210525090523900.png" alt="image-20210525090523900"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; counts = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(ptr);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (ptr &lt; n &amp;&amp; s.charAt(ptr) == c) &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            counts.add(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.size(); ++i) &#123;</span><br><span class="line">            ans += Math.min(counts.get(i), counts.get(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/image-20210525090604870.png" alt="image-20210525090604870"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>, n = s.length(), last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(ptr);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (ptr &lt; n &amp;&amp; s.charAt(ptr) == c) &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Math.min(count, last);</span><br><span class="line">            last = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/image-20210525090633007.png" alt="image-20210525090633007"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>回文数</title>
    <url>/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E6%95%B0/image-20210525083459896.png" alt="image-20210525083459896"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：反转一半数字"><a href="#方法一：反转一半数字" class="headerlink" title="方法一：反转一半数字"></a>方法一：反转一半数字</h4><p><strong>思路</strong></p>
<p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E6%95%B0/image-20210525083544747.png" alt="image-20210525083544747"></p>
<p><strong>算法</strong></p>
<p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E6%95%B0/image-20210525083603936.png" alt="image-20210525083603936"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E6%95%B0/image-20210525083633604.png" alt="image-20210525083633604"></p>
<p>我的代码：将整数转为字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s=String.valueOf(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=s.charAt(s.length()-i-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>回文子串</title>
    <url>/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/image-20210525082337552.png" alt="image-20210525082337552"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：中心拓展"><a href="#方法一：中心拓展" class="headerlink" title="方法一：中心拓展"></a>方法一：中心拓展</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/image-20210525082553281.png" alt="image-20210525082553281"></p>
<p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/image-20210525082606925.png" alt="image-20210525082606925"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i / <span class="number">2</span>, r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/image-20210525082643854.png" alt="image-20210525082643854"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>同构字符串</title>
    <url>/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20210524091610021.png" alt="image-20210524091610021"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20210524091630555.png" alt="image-20210524091630555"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Character&gt; s2t = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">        Map&lt;Character, Character&gt; t2s = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = s.charAt(i), y = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> ((s2t.containsKey(x) &amp;&amp; s2t.get(x) != y) || (t2s.containsKey(y) &amp;&amp; t2s.get(y) != x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s2t.put(x, y);</span><br><span class="line">            t2s.put(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20210524091656217.png" alt="image-20210524091656217"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>最长回文串</title>
    <url>/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/image-20210524085856225.png" alt="image-20210524085856225"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h4><p><strong>思路</strong></p>
<p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/image-20210524085918412.png" alt="image-20210524085918412"></p>
<p><strong>算法</strong></p>
<p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/image-20210524085932914.png" alt="image-20210524085932914"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: count) &#123;</span><br><span class="line">            ans += v / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; ans % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/image-20210524090011162.png" alt="image-20210524090011162"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>有效的字母异位词</title>
    <url>/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/image-20210524082844998.png" alt="image-20210524082844998"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h4><p>t 是 ss 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 ss 和 tt 分别排序，看排序后的字符串是否相等即可判断。此外，如果 ss 和 tt 的长度不同，tt 必然不是 ss 的异位词。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/image-20210524082948706.png" alt="image-20210524082948706"></p>
<h4 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h4><p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/image-20210524083007781.png" alt="image-20210524083007781"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            table[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            table[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (table[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用哈希表维护对应字符的频次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; table = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            table.put(ch, table.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = t.charAt(i);</span><br><span class="line">            table.put(ch, table.getOrDefault(ch, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (table.get(ch) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/image-20210524083129138.png" alt="image-20210524083129138"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>最长连续序列</title>
    <url>/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/image-20210522092709526.png" alt="image-20210522092709526"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><p><strong>思路和算法</strong></p>
<p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/image-20210522092747450.png" alt="image-20210522092747450"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; num_set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            num_set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num_set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (num_set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/image-20210522092820912.png" alt="image-20210522092820912"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>哈希表</category>
      </categories>
  </entry>
  <entry>
    <title>最长和谐子序列</title>
    <url>/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/image-20210522091644467.png" alt="image-20210522091644467"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h4><p>我们可以枚举数组中的每一个元素，对于当前枚举的元素 x，它可以和 x + 1 组成和谐子序列。我们再遍历一遍整个数组，找出等于 x 或 x + 1 的元素个数，就可以得到以 x 为最小值的和谐子序列的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == nums[i])</span><br><span class="line">                    count++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[j] + <span class="number">1</span> == nums[i]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                res = Math.max(count, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/image-20210522091735299.png" alt="image-20210522091735299"></p>
<h4 id="方法二：哈希映射"><a href="#方法二：哈希映射" class="headerlink" title="方法二：哈希映射"></a>方法二：哈希映射</h4><p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/image-20210522091749229.png" alt="image-20210522091749229"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap &lt; Integer, Integer &gt; map = <span class="keyword">new</span> HashMap &lt; &gt; ();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key: map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key + <span class="number">1</span>))</span><br><span class="line">                res = Math.max(res, map.get(key) + map.get(key + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/image-20210522091826109.png" alt="image-20210522091826109"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>哈希表</category>
      </categories>
  </entry>
  <entry>
    <title>存在重复元素</title>
    <url>/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20210522085028214.png" alt="image-20210522085028214"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h4><p>在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20210522085127991.png" alt="image-20210522085127991"></p>
<h4 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h4><p>对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20210522085200448.png" alt="image-20210522085200448"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>哈希表</category>
      </categories>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/image-20210522082745175.png" alt="image-20210522082745175"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h4><p><strong>思路及算法</strong></p>
<p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/image-20210522084133641.png" alt="image-20210522084133641"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/image-20210522084213241.png" alt="image-20210522084213241"></p>
<h4 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h4><p><strong>思路及算法</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/22/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/image-20210522084250397.png" alt="image-20210522084250397"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>哈希表</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/05/21/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E9%94%AE%E5%80%BC%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>title: 键值映射<br>categories:</p>
<ul>
<li>力扣</li>
<li>数据结构</li>
<li>树</li>
<li>前缀树<br>date: 2021-05-21 09:24:42<br>tags:</li>
</ul>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/21/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E9%94%AE%E5%80%BC%E6%98%A0%E5%B0%84/image-20210521092606143.png" alt="image-20210521092606143"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="键值映射-前缀树（字典树）变种问题"><a href="#键值映射-前缀树（字典树）变种问题" class="headerlink" title="键值映射-前缀树（字典树）变种问题"></a>键值映射-前缀树（字典树）变种问题</h4><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><img src="/2021/05/21/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E9%94%AE%E5%80%BC%E6%98%A0%E5%B0%84/image-20210521092623094.png" alt="image-20210521092623094"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> MapSum[] next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     sum=<span class="number">0</span>;</span><br><span class="line">     next=<span class="keyword">new</span> MapSum[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        MapSum node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> op = val;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            op=val-map.get(key);</span><br><span class="line">            map.put(key,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(key,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;key.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=key.charAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.next[index]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                node.next[index]=<span class="keyword">new</span> MapSum();</span><br><span class="line">                node=node.next[index];</span><br><span class="line">                node.sum+=op;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node=node.next[index];</span><br><span class="line">                node.sum+=op;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        MapSum node=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prefix.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=prefix.charAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.next[index]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node=node.next[index];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>实现Trie-前缀树</title>
    <url>/2021/05/21/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/21/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/image-20210521084454866.png" alt="image-20210521084454866"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：字典树"><a href="#方法一：字典树" class="headerlink" title="方法一：字典树"></a>方法一：字典树</h4><p><img src="/2021/05/21/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/image-20210521084517656.png" alt="image-20210521084517656"></p>
<p><img src="/2021/05/21/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/image-20210521084532707.png" alt="image-20210521084532707"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Trie <span class="title">searchPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/21/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/image-20210521084622352.png" alt="image-20210521084622352"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>二叉查找树</category>
      </categories>
  </entry>
  <entry>
    <title>实现Trie-前缀树</title>
    <url>/2021/05/21/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<p>[力扣]: </p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3>]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>二叉查找树</category>
      </categories>
  </entry>
  <entry>
    <title>二叉搜索树的最小绝对差</title>
    <url>/2021/05/20/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/20/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/image-20210520091329538.png" alt="image-20210520091329538"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：中序遍历"><a href="#方法一：中序遍历" class="headerlink" title="方法一：中序遍历"></a>方法一：中序遍历</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/20/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/image-20210520091355215.png" alt="image-20210520091355215"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -<span class="number">1</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre == -<span class="number">1</span>) &#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = Math.min(ans, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/20/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/image-20210520091436747.png" alt="image-20210520091436747"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>二叉查找树</category>
      </categories>
  </entry>
  <entry>
    <title>两数之和IV-输入BST</title>
    <url>/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST/image-20210519093224010.png" alt="image-20210519093224010"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：使用-HashSet【通过】"><a href="#方法一：使用-HashSet【通过】" class="headerlink" title="方法一：使用 HashSet【通过】"></a>方法一：使用 HashSet【通过】</h4><p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST/image-20210519093244351.png" alt="image-20210519093244351"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Set &lt; Integer &gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">return</span> find(root, k, set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(TreeNode root, <span class="keyword">int</span> k, Set &lt; Integer &gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(k - root.val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> find(root.left, k, set) || find(root.right, k, set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST/image-20210519093323139.png" alt="image-20210519093323139"></p>
<h4 id="方法二：使用-BFS-和-HashSet【通过】"><a href="#方法二：使用-BFS-和-HashSet【通过】" class="headerlink" title="方法二：使用 BFS 和 HashSet【通过】"></a>方法二：使用 BFS 和 HashSet【通过】</h4><p><strong>算法</strong></p>
<p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST/image-20210519093339416.png" alt="image-20210519093339416"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Set &lt; Integer &gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Queue &lt; TreeNode &gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peek() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode node = queue.remove();</span><br><span class="line">                <span class="keyword">if</span> (set.contains(k - node.val))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                set.add(node.val);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST/image-20210519093429172.png" alt="image-20210519093429172"></p>
<h4 id="方法三：使用-BST【通过】"><a href="#方法三：使用-BST【通过】" class="headerlink" title="方法三：使用 BST【通过】"></a>方法三：使用 BST【通过】</h4><p><strong>算法</strong></p>
<p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST/image-20210519093530835.png" alt="image-20210519093530835"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List &lt; Integer &gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        inorder(root, list);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = list.get(l) + list.get(r);</span><br><span class="line">            <span class="keyword">if</span> (sum == k)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; k)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List &lt; Integer &gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST/image-20210519093558264.png" alt="image-20210519093558264"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>二叉查找树</category>
      </categories>
  </entry>
  <entry>
    <title>有序链表转换二叉搜索树</title>
    <url>/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20210519091321357.png" alt="image-20210519091321357"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：分治"><a href="#方法一：分治" class="headerlink" title="方法一：分治"></a>方法一：分治</h4><p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20210519091409702.png" alt="image-20210519091409702"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode globalHead;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        globalHead = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.left = buildTree(left, mid - <span class="number">1</span>);</span><br><span class="line">        root.val = globalHead.val;</span><br><span class="line">        globalHead = globalHead.next;</span><br><span class="line">        root.right = buildTree(mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20210519091538468.png" alt="image-20210519091538468"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>二叉查找树</category>
      </categories>
  </entry>
  <entry>
    <title>将有序数组转换为二叉搜索树</title>
    <url>/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20210519085138563.png" alt="image-20210519085138563"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：中序遍历，总是选择中间位置左边的数字作为根节点"><a href="#方法一：中序遍历，总是选择中间位置左边的数字作为根节点" class="headerlink" title="方法一：中序遍历，总是选择中间位置左边的数字作为根节点"></a>方法一：中序遍历，总是选择中间位置左边的数字作为根节点</h4><p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20210519085224511.png" alt="image-20210519085224511"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/19/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20210519085252577.png" alt="image-20210519085252577"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>二叉查找树</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先</title>
    <url>/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210518093847152.png" alt="image-20210518093847152"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p><strong>思路和算法</strong></p>
<p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210518093912424.png" alt="image-20210518093912424"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ans = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> lson = dfs(root.left, p, q);</span><br><span class="line">        <span class="keyword">boolean</span> rson = dfs(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root.val == p.val || root.val == q.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210518094003627.png" alt="image-20210518094003627"></p>
<h4 id="方法二：存储父节点"><a href="#方法二：存储父节点" class="headerlink" title="方法二：存储父节点"></a>方法二：存储父节点</h4><p><strong>思路</strong></p>
<p>我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。</p>
<p><strong>算法</strong></p>
<p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210518094040215.png" alt="image-20210518094040215"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, TreeNode&gt; parent = <span class="keyword">new</span> HashMap&lt;Integer, TreeNode&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.put(root.left.val, root);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.put(root.right.val, root);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            visited.add(p.val);</span><br><span class="line">            p = parent.get(p.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(q.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            q = parent.get(q.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210518094113987.png" alt="image-20210518094113987"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>二叉查找树</category>
      </categories>
  </entry>
  <entry>
    <title>二叉搜索树的最近公共祖先</title>
    <url>/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210518090000681.png" alt="image-20210518090000681"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：两次遍历"><a href="#方法一：两次遍历" class="headerlink" title="方法一：两次遍历"></a>方法一：两次遍历</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210518090033907.png" alt="image-20210518090033907"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; path_p = getPath(root, p);</span><br><span class="line">        List&lt;TreeNode&gt; path_q = getPath(root, q);</span><br><span class="line">        TreeNode ancestor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path_p.size() &amp;&amp; i &lt; path_q.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path_p.get(i) == path_q.get(i)) &#123;</span><br><span class="line">                ancestor = path_p.get(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">getPath</span><span class="params">(TreeNode root, TreeNode target)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; path = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != target) &#123;</span><br><span class="line">            path.add(node);</span><br><span class="line">            <span class="keyword">if</span> (target.val &lt; node.val) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(node);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210518090122662.png" alt="image-20210518090122662"></p>
<h4 id="方法二：一次遍历"><a href="#方法二：一次遍历" class="headerlink" title="方法二：一次遍历"></a>方法二：一次遍历</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210518090158314.png" alt="image-20210518090158314"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode ancestor = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;</span><br><span class="line">                ancestor = ancestor.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;</span><br><span class="line">                ancestor = ancestor.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210518090315388.png" alt="image-20210518090315388"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>二叉查找树</category>
      </categories>
  </entry>
  <entry>
    <title>把二叉搜索树转换为累加树</title>
    <url>/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/image-20210518084055499.png" alt="image-20210518084055499"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：反序中序遍历"><a href="#方法一：反序中序遍历" class="headerlink" title="方法一：反序中序遍历"></a>方法一：反序中序遍历</h4><p><strong>思路及算法</strong></p>
<p>本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            convertBST(root.right);</span><br><span class="line">            sum += root.val;</span><br><span class="line">            root.val = sum;</span><br><span class="line">            convertBST(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/18/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/image-20210518084156229.png" alt="image-20210518084156229"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>二叉查找树</category>
      </categories>
  </entry>
  <entry>
    <title>修剪二叉搜索树</title>
    <url>/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20210517091334450.png" alt="image-20210517091334450"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法：递归"><a href="#方法：递归" class="headerlink" title="方法：递归"></a>方法：递归</h4><p><strong>思路</strong></p>
<p>令 <code>trim(node)</code> 作为该节点上的子树的理想答案。我们可以递归地构建该答案。</p>
<p><strong>算法</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20210517091409597.png" alt="image-20210517091409597"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; R) <span class="keyword">return</span> trimBST(root.left, L, R);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; L) <span class="keyword">return</span> trimBST(root.right, L, R);</span><br><span class="line"></span><br><span class="line">        root.left = trimBST(root.left, L, R);</span><br><span class="line">        root.right = trimBST(root.right, L, R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20210517091451365.png" alt="image-20210517091451365"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>二叉查找树</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517090241341.png" alt="image-20210517090241341"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517090259836.png" alt="image-20210517090259836"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517090336488.png" alt="image-20210517090336488"></p>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p><strong>思路与算法</strong></p>
<p>方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517090427918.png" alt="image-20210517090427918"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>遍历</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的后序遍历</title>
    <url>/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517085433479.png" alt="image-20210517085433479"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517085500205.png" alt="image-20210517085500205"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, res);</span><br><span class="line">        postorder(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517085549603.png" alt="image-20210517085549603"></p>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p><strong>思路与算法</strong></p>
<p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面的代码。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == nullptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = nullptr;</span><br><span class="line">        <span class="keyword">while</span> (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != nullptr) &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == nullptr || root-&gt;right == prev) &#123;</span><br><span class="line">                res.emplace_back(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = nullptr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;j</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517085639111.png" alt="image-20210517085639111"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>遍历</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的前序遍历</title>
    <url>/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517083700826.png" alt="image-20210517083700826"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517083731469.png" alt="image-20210517083731469"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorder(root.left, res);</span><br><span class="line">        preorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517083816480.png" alt="image-20210517083816480"></p>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p><strong>思路与算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/17/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210517083900590.png" alt="image-20210517083900590"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>遍历</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的层平均值</title>
    <url>/2021/05/16/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/16/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/image-20210516085022961.png" alt="image-20210516085022961"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h4><p><img src="/2021/05/16/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/image-20210516085107771.png" alt="image-20210516085107771"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; averages = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                sum += node.val;</span><br><span class="line">                TreeNode left = node.left, right = node.right;</span><br><span class="line">                <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            averages.add(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> averages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/16/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/image-20210516085142324.png" alt="image-20210516085142324"></p>
<h4 id="方法二：深度优先搜索"><a href="#方法二：深度优先搜索" class="headerlink" title="方法二：深度优先搜索"></a>方法二：深度优先搜索</h4><p><img src="/2021/05/16/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/image-20210516090105371.png" alt="image-20210516090105371"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; counts = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Double&gt; sums = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        dfs(root, <span class="number">0</span>, counts, sums);</span><br><span class="line">        List&lt;Double&gt; averages = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = sums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            averages.add(sums.get(i) / counts.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> averages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, List&lt;Integer&gt; counts, List&lt;Double&gt; sums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (level &lt; sums.size()) &#123;</span><br><span class="line">            sums.set(level, sums.get(level) + root.val);</span><br><span class="line">            counts.set(level, counts.get(level) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sums.add(<span class="number">1.0</span> * root.val);</span><br><span class="line">            counts.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, level + <span class="number">1</span>, counts, sums);</span><br><span class="line">        dfs(root.right, level + <span class="number">1</span>, counts, sums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/16/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/image-20210516090140222.png" alt="image-20210516090140222"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>层次遍历</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树中第二小的节点</title>
    <url>/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a><img src="/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/image-20210514094819120.png" alt="image-20210514094819120">文字题解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> left=root.left.val;</span><br><span class="line">        <span class="keyword">int</span> right=root.right.val;</span><br><span class="line">        <span class="keyword">if</span>(root.val==left)&#123;</span><br><span class="line">            left=findSecondMinimumValue(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val==right)&#123;</span><br><span class="line">            right=findSecondMinimumValue(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left!=-<span class="number">1</span>&amp;&amp;right!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(left,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>打家劫舍III</title>
    <url>/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/image-20210514093301718.png" alt="image-20210514093301718"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/image-20210514093332065.png" alt="image-20210514093332065"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; f = <span class="keyword">new</span> HashMap&lt;TreeNode, Integer&gt;();</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; g = <span class="keyword">new</span> HashMap&lt;TreeNode, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(f.getOrDefault(root, <span class="number">0</span>), g.getOrDefault(root, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left);</span><br><span class="line">        dfs(node.right);</span><br><span class="line">        f.put(node, node.val + g.getOrDefault(node.left, <span class="number">0</span>) + g.getOrDefault(node.right, <span class="number">0</span>));</span><br><span class="line">        g.put(node, Math.max(f.getOrDefault(node.left, <span class="number">0</span>), g.getOrDefault(node.left, <span class="number">0</span>)) + Math.max(f.getOrDefault(node.right, <span class="number">0</span>), g.getOrDefault(node.right, <span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设二叉树的节点个数为 nn。</p>
<p>我们可以看出，以上的算法对二叉树做了一次后序遍历，时间复杂度是 O(n)O(n)；由于递归会使用到栈空间，空间代价是 O(n)O(n)，哈希表的空间代价也是 O(n)O(n)，故空间复杂度也是 O(n)O(n)。</p>
<p>我们可以做一个小小的优化，我们发现无论是 f(o)f(o) 还是 g(o)g(o)，他们最终的值只和 f(l)f(l)、g(l)g(l)、f(r)f(r)、g(r)g(r) 有关，所以对于每个节点，我们只关心它的孩子节点们的 ff 和 gg 是多少。我们可以设计一个结构，表示某个节点的 ff 和 gg 值，在每次递归返回的时候，都把这个点对应的 ff 和 gg 返回给上一级调用，这样可以省去哈希表的空间。</p>
<p>代码如下。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] rootStatus = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rootStatus[<span class="number">0</span>], rootStatus[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dfs(TreeNode node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] l = dfs(node.left);</span><br><span class="line">        <span class="keyword">int</span>[] r = dfs(node.right);</span><br><span class="line">        <span class="keyword">int</span> selected = node.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> notSelected = Math.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + Math.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/image-20210514093505994.png" alt="image-20210514093505994"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>最长同值路径</title>
    <url>/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/image-20210514090410209.png" alt="image-20210514090410209"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法：递归"><a href="#方法：递归" class="headerlink" title="方法：递归"></a>方法：递归</h4><p><strong>思路</strong></p>
<p>我们可以将任何路径（具有相同值的节点）看作是最多两个从其根延伸出的箭头。</p>
<p>具体地说，路径的根将是唯一节点，因此该节点的父节点不会出现在该路径中，而箭头将是根在该路径中只有一个子节点的路径。</p>
<p>然后，对于每个节点，我们想知道向左延伸的最长箭头和向右延伸的最长箭头是什么？我们可以用递归来解决这个问题。</p>
<p><strong>算法</strong></p>
<p>令 arrow_length(node) 为从节点 node 延伸出的最长箭头的长度。如果 node.Left 存在且与节点 node 具有相同的值，则该值就会是 1 + arrow_length(node.left)。在 node.right 存在的情况下也是一样。</p>
<p>当我们计算箭头长度时，候选答案将是该节点在两个方向上的箭头之和。我们将这些候选答案记录下来，并返回最佳答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        arrowLength(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrowLength</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = arrowLength(node.left);</span><br><span class="line">        <span class="keyword">int</span> right = arrowLength(node.right);</span><br><span class="line">        <span class="keyword">int</span> arrowLeft = <span class="number">0</span>, arrowRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.left.val == node.val) &#123;</span><br><span class="line">            arrowLeft += left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span> &amp;&amp; node.right.val == node.val) &#123;</span><br><span class="line">            arrowRight += right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, arrowLeft + arrowRight);</span><br><span class="line">        <span class="keyword">return</span> Math.max(arrowLeft, arrowRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/image-20210514090545811.png" alt="image-20210514090545811"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>左叶子之和</title>
    <url>/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/image-20210514083111054.png" alt="image-20210514083111054"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="keyword">null</span> ? dfs(root) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans += isLeafNode(node.left) ? node.left.val : dfs(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span> &amp;&amp; !isLeafNode(node.right)) &#123;</span><br><span class="line">            ans += dfs(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeafNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/image-20210514083446826.png" alt="image-20210514083446826"></p>
<h4 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isLeafNode(node.left)) &#123;</span><br><span class="line">                    ans += node.left.val;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isLeafNode(node.right)) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeafNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/14/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/image-20210514083537358.png" alt="image-20210514083537358"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的最小深度</title>
    <url>/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/image-20210513093821340.png" alt="image-20210513093821340"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h4><p><strong>思路及解法</strong></p>
<p>首先可以想到使用深度优先搜索的方法，遍历整棵树，记录最小深度。</p>
<p>对于每一个非叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_depth = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/image-20210513093916228.png" alt="image-20210513093916228"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>对称二叉树</title>
    <url>/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210513091534811.png" alt="image-20210513091534811"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p><strong>思路和算法</strong></p>
<p><img src="/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210513091604196.png" alt="image-20210513091604196"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210513091637564.png" alt="image-20210513091637564"></p>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p><strong>思路和算法</strong></p>
<p>「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(u);</span><br><span class="line">        q.offer(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            u = q.poll();</span><br><span class="line">            v = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="keyword">null</span> &amp;&amp; v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((u == <span class="keyword">null</span> || v == <span class="keyword">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.offer(u.left);</span><br><span class="line">            q.offer(v.right);</span><br><span class="line"></span><br><span class="line">            q.offer(u.right);</span><br><span class="line">            q.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210513092552386.png" alt="image-20210513092552386"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>另一个树的子树</title>
    <url>/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/image-20210513090051513.png" alt="image-20210513090051513"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：深度优先搜索暴力匹配"><a href="#方法一：深度优先搜索暴力匹配" class="headerlink" title="方法一：深度优先搜索暴力匹配"></a>方法一：深度优先搜索暴力匹配</h4><p><strong>思路和算法</strong></p>
<p>这是一种最朴素的方法——深度优先搜索枚举 ss 中的每一个节点，判断这个点的子树是否和 tt 相等。如何判断一个节点的子树是否和 tt 相等呢，我们又需要做一次深度优先搜索来检查，即让两个指针一开始先指向该节点和 tt 的根，然后「同步移动」两根指针来「同步遍历」这两棵树，判断对应位置是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(s, t) || dfs(s.left, t) || dfs(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.val != t.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(s.left, t.left) &amp;&amp; check(s.right, t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/image-20210513090143568.png" alt="image-20210513090143568"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>路径总和_III</title>
    <url>/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/13/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III/image-20210513084532750.png" alt="image-20210513084532750"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h4><p>这道题用到了一个概念，叫前缀和。就是到达当前元素的路径上，之前所有元素的和。</p>
<p>前缀和怎么应用呢？</p>
<p>在同一个路径之下（可以理解成二叉树从root节点出发，到叶子节点的某一条路径），如果两个数的前缀总和是相同的，那么这些节点之间的元素总和为零。进一步扩展相同的想法，如果前缀总和currSum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target。</p>
<p>因为本题中的路径是一棵树，从根往任一节点的路径上(不走回头路)，有且仅有一条路径，因为不存在环。(如果存在环，前缀和就不能用了，需要改造算法)</p>
<p>抵达当前节点(即B节点)后，将前缀和累加，然后查找在前缀和上，有没有前缀和currSum-target的节点(即A节点)，存在即表示从A到B有一条路径之和满足条件的情况。结果加上满足前缀和currSum-target的节点的数量。然后递归进入左右子树。</p>
<p>左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// key是前缀和, value是大小为key的前缀和出现的次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 前缀和为0的一条路径</span></span><br><span class="line">        prefixSumCount.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 前缀和的递归回溯思路</span></span><br><span class="line">        <span class="keyword">return</span> recursionPathSum(root, prefixSumCount, sum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前缀和的递归回溯思路</span></span><br><span class="line"><span class="comment">     * 从当前节点反推到根节点(反推比较好理解，正向其实也只有一条)，有且仅有一条路径，因为这是一棵树</span></span><br><span class="line"><span class="comment">     * 如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了</span></span><br><span class="line"><span class="comment">     * 所以前缀和对于当前路径来说是唯一的，当前记录的前缀和，在回溯结束，回到本层时去除，保证其不影响其他分支的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 树节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefixSumCount 前缀和Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currSum 当前路径和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 满足题意的解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recursionPathSum</span><span class="params">(TreeNode node, Map&lt;Integer, Integer&gt; prefixSumCount, <span class="keyword">int</span> target, <span class="keyword">int</span> currSum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.本层要做的事情</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前路径上的和</span></span><br><span class="line">        currSum += node.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---核心代码</span></span><br><span class="line">        <span class="comment">// 看看root到当前节点这条路上是否存在节点前缀和加target为currSum的路径</span></span><br><span class="line">        <span class="comment">// 当前节点-&gt;root节点反推，有且仅有一条路径，如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了</span></span><br><span class="line">        <span class="comment">// currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target</span></span><br><span class="line">        res += prefixSumCount.getOrDefault(currSum - target, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 更新路径上当前节点前缀和的个数</span></span><br><span class="line">        prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//---核心代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进入下一层</span></span><br><span class="line">        res += recursionPathSum(node.left, prefixSumCount, target, currSum);</span><br><span class="line">        res += recursionPathSum(node.right, prefixSumCount, target, currSum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.回到本层，恢复状态，去除当前节点的前缀和数量</span></span><br><span class="line">        prefixSumCount.put(currSum, prefixSumCount.get(currSum) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：每个节点只遍历一次,O(N).</p>
<p><strong>空间复杂度</strong>：开辟了一个hashMap,O(N).</p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>路径总和</title>
    <url>/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/image-20210512094645438.png" alt="image-20210512094645438"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h4><p><strong>思路及算法</strong></p>
<p>首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。</p>
<p>这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queNode = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queVal = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queNode.offer(root);</span><br><span class="line">        queVal.offer(root.val);</span><br><span class="line">        <span class="keyword">while</span> (!queNode.isEmpty()) &#123;</span><br><span class="line">            TreeNode now = queNode.poll();</span><br><span class="line">            <span class="keyword">int</span> temp = queVal.poll();</span><br><span class="line">            <span class="keyword">if</span> (now.left == <span class="keyword">null</span> &amp;&amp; now.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp == sum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queNode.offer(now.left);</span><br><span class="line">                queVal.offer(now.left.val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queNode.offer(now.right);</span><br><span class="line">                queVal.offer(now.right.val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/image-20210512101130533.png" alt="image-20210512101130533"></p>
<h4 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h4><p><strong>思路及算法</strong></p>
<p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p>
<p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p>
<p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/image-20210512101229394.png" alt="image-20210512101229394"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>归并两棵树</title>
    <url>/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%BD%92%E5%B9%B6%E4%B8%A4%E6%A3%B5%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%BD%92%E5%B9%B6%E4%B8%A4%E6%A3%B5%E6%A0%91/image-20210512092556159.png" alt="image-20210512092556159"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h4><p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p>
<p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p>
<p>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p>
<p>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</p>
<p>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</p>
<p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode merged = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">        merged.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        merged.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%BD%92%E5%B9%B6%E4%B8%A4%E6%A3%B5%E6%A0%91/image-20210512092700730.png" alt="image-20210512092700730"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>翻转二叉树</title>
    <url>/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210512083522378.png" alt="image-20210512083522378"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p><strong>思路与算法</strong></p>
<p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子结点先开始翻转。如果当前遍历到的节点 \textit{root}root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 \textit{root}root 为根节点的整棵子树的翻转。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210512083627844.png" alt="image-20210512083627844"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>两节点的最长路径</title>
    <url>/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>[力扣]: </p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/image-20210512082928449.png" alt="image-20210512082928449"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h4><p>首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</p>
<p>而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/image-20210512083135613.png" alt="image-20210512083135613"><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/image-20210512083151683.png" alt="image-20210512083151683"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> L = depth(node.left); <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> R = depth(node.right); <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        ans = Math.max(ans, L+R+<span class="number">1</span>); <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(L, R) + <span class="number">1</span>; <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/image-20210512083209990.png" alt="image-20210512083209990"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>平衡树</title>
    <url>/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20210512082158470.png" alt="image-20210512082158470"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：自顶向下的递归"><a href="#方法一：自顶向下的递归" class="headerlink" title="方法一：自顶向下的递归"></a>方法一：自顶向下的递归</h4><p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20210512082229420.png" alt="image-20210512082229420"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(height(root.left), height(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20210512082309448.png" alt="image-20210512082309448"></p>
<h4 id="方法二：自底向上的递归"><a href="#方法二：自底向上的递归" class="headerlink" title="方法二：自底向上的递归"></a>方法二：自底向上的递归</h4><p>方法一由于是自顶向下递归，因此对于同一个节点，函数 \texttt{height}height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 \texttt{height}height 只会被调用一次。</p>
<p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = height(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = height(root.right);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20210512082504991.png" alt="image-20210512082504991"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>树的高度</title>
    <url>/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6/image-20210512081633061.png" alt="image-20210512081633061"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6/image-20210512081659630.png" alt="image-20210512081659630"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> leftHeight = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> rightHeight = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6/image-20210512081745349.png" alt="image-20210512081745349"></p>
<h4 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h4><p><strong>思路与算法</strong></p>
<p>我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 \textit{ans}ans 来维护拓展的次数，该二叉树的最大深度即为 \textit{ans}ans。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/12/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6/image-20210512081858180.png" alt="image-20210512081858180"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>树</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title>最小的k个数</title>
    <url>/2021/05/10/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>[力扣]: </p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3>]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
  </entry>
  <entry>
    <title>滑动窗口的最大值</title>
    <url>/2021/05/10/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/10/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/image-20210510083815451.png" alt="image-20210510083815451"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p><img src="/2021/05/10/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/image-20210510083905323.png" alt="image-20210510083905323"></p>
<p><img src="/2021/05/10/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/image-20210510083836875.png" alt="image-20210510083836875"></p>
<p><img src="/2021/05/10/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/image-20210510083921401.png" alt="image-20210510083921401"></p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">1</span> - k; j &lt; nums.length; i++, j++) &#123;</span><br><span class="line">            <span class="comment">// 删除 deque 中对应的 nums[i-1]</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; deque.peekFirst() == nums[i - <span class="number">1</span>])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            <span class="comment">// 保持 deque 递减</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[j]);</span><br><span class="line">            <span class="comment">// 记录窗口最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">                res[i] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><p><img src="/2021/05/10/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/image-20210510084002763.png" alt="image-20210510084002763"></p>
<p>可以将 “未形成窗口” 和 “形成窗口后” 两个阶段拆分到两个循环里实现。代码虽变长，但减少了冗余的判断操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 未形成窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = deque.peekFirst();</span><br><span class="line">        <span class="comment">// 形成窗口后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(deque.peekFirst() == nums[i - k])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">            res[i - k + <span class="number">1</span>] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>队列</category>
      </categories>
  </entry>
  <entry>
    <title>每日温度</title>
    <url>/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<p>[力扣]: </p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/image-20210509085341274.png" alt="image-20210509085341274"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h4><p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/image-20210509085409806.png" alt="image-20210509085409806"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        Arrays.fill(next, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> warmerIndex = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = T[i] + <span class="number">1</span>; t &lt;= <span class="number">100</span>; ++t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next[t] &lt; warmerIndex) &#123;</span><br><span class="line">                    warmerIndex = next[t];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (warmerIndex &lt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                ans[i] = warmerIndex - i;</span><br><span class="line">            &#125;</span><br><span class="line">            next[T[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/image-20210509085439167.png" alt="image-20210509085439167"></p>
<h4 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h4><p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/image-20210509085457190.png" alt="image-20210509085457190"></p>
<p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/image-20210509085515194.png" alt="image-20210509085515194"></p>
<p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/image-20210509085539403.png" alt="image-20210509085539403"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temperature = T[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperature &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> prevIndex = stack.pop();</span><br><span class="line">                ans[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/image-20210509085609425.png" alt="image-20210509085609425"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>[力扣]: </p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210509083105785.png" alt="image-20210509083105785"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210509083212390.png" alt="image-20210509083212390"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210509083309872.png" alt="image-20210509083309872"></p>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p><strong>思路与算法</strong></p>
<p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210509083346060.png" alt="image-20210509083346060"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2021/05/09/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/image-20210509083429317.png" alt="image-20210509083429317"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
  </entry>
  <entry>
    <title>用队列实现栈</title>
    <url>/2021/04/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/04/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/image-20210426091214157.png" alt="image-20210426091214157"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：两个队列"><a href="#方法一：两个队列" class="headerlink" title="方法一：两个队列"></a>方法一：两个队列</h4><p><img src="/2021/04/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/image-20210426091239013.png" alt="image-20210426091239013"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><p><img src="/2021/04/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/image-20210426091330492.png" alt="image-20210426091330492"></p>
<h4 id="方法二：一个队列"><a href="#方法二：一个队列" class="headerlink" title="方法二：一个队列"></a>方法二：一个队列</h4><p><img src="/2021/04/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/image-20210426091438432.png" alt="image-20210426091438432"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><p><img src="/2021/04/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/image-20210426091521670.png" alt="image-20210426091521670"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2021/04/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/04/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/image-20210426084254796.png" alt="image-20210426084254796"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h4><p><img src="/2021/04/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/image-20210426084333708.png" alt="image-20210426084333708"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><p><img src="/2021/04/26/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/image-20210426084429375.png" alt="image-20210426084429375"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
  </entry>
  <entry>
    <title>删除排序链表中的重复元素II</title>
    <url>/2021/04/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/04/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/image-20210425093256751.png" alt="image-20210425093256751"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h4><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a><strong>思路与算法</strong></h4><p><img src="/2021/04/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/image-20210425093410769.png" alt="image-20210425093410769"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = cur.next.val;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == x) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><p><img src="/2021/04/25/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/image-20210425093854718.png" alt="image-20210425093854718"></p>
<h4 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h4><p>用哈希表统计每个val出现的次数，将val出现次数大于大于1的节点删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();     </span><br><span class="line">        ListNode hair=<span class="keyword">new</span> ListNode();</span><br><span class="line">        hair.next=head;</span><br><span class="line">        ListNode pre=hair,p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(p.val,map.getOrDefault(p.val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next=p.next;</span><br><span class="line">            <span class="keyword">if</span>(map.get(p.val)!=<span class="number">1</span>)&#123;</span><br><span class="line">                pre.next=next;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre=p;</span><br><span class="line">                p=next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hair.next;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title>K个一组翻转链表</title>
    <url>/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20210424102742069.png" alt="image-20210424102742069"></p>
<h4 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h4><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a><strong>思路与算法</strong></h4><p><img src="/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20210424102850741.png" alt="image-20210424102850741"></p>
<p><img src="/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20210424102903084.png" alt="image-20210424102903084"></p>
<p><img src="/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20210424102912820.png" alt="image-20210424102912820"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode hair = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        hair.next = head;</span><br><span class="line">        ListNode pre = hair;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode tail = pre;</span><br><span class="line">            <span class="comment">// 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> hair.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode nex = tail.next;</span><br><span class="line">            ListNode[] reverse = myReverse(head, tail);</span><br><span class="line">            head = reverse[<span class="number">0</span>];</span><br><span class="line">            tail = reverse[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 把子链表重新接回原链表</span></span><br><span class="line">            pre.next = head;</span><br><span class="line">            tail.next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hair.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode[] myReverse(ListNode head, ListNode tail) &#123;</span><br><span class="line">        ListNode prev = tail.next;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (prev != tail) &#123;</span><br><span class="line">            ListNode nex = p.next;</span><br><span class="line">            p.next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><p><img src="/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20210424103021784.png" alt="image-20210424103021784"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title>合并K个升序链表</title>
    <url>/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20210424091626009.png" alt="image-20210424091626009"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一：顺序合并"><a href="#方法一：顺序合并" class="headerlink" title="方法一：顺序合并"></a>方法一：顺序合并</h4><p><strong>思路</strong></p>
<p>我们可以想到一种最朴素的方法：用一个变量 <code>ans</code> 来维护以及合并的链表，第 i<em>i</em> 次循环把第 i<em>i</em> 个链表和 <code>ans</code> 合并，答案保存到 <code>ans</code> 中。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; ++i) &#123;</span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a != <span class="keyword">null</span> ? a : b;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode tail = head, aPtr = a, bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr != <span class="keyword">null</span> &amp;&amp; bPtr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">                tail.next = aPtr;</span><br><span class="line">                aPtr = aPtr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = bPtr;</span><br><span class="line">                bPtr = bPtr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = (aPtr != <span class="keyword">null</span> ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p><img src="/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20210424091858652.png" alt="image-20210424091858652"></p>
<h4 id="方法二：分治合并"><a href="#方法二：分治合并" class="headerlink" title="方法二：分治合并"></a>方法二：分治合并</h4><p><strong>思路</strong></p>
<p><img src="/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20210424091940958.png" alt="image-20210424091940958"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a != <span class="keyword">null</span> ? a : b;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode tail = head, aPtr = a, bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr != <span class="keyword">null</span> &amp;&amp; bPtr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">                tail.next = aPtr;</span><br><span class="line">                aPtr = aPtr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = bPtr;</span><br><span class="line">                bPtr = bPtr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = (aPtr != <span class="keyword">null</span> ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><img src="/2021/04/24/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20210424092053206.png" alt="image-20210424092053206"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第N个结点</title>
    <url>/2021/04/23/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/04/23/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/image-20210423160555145.png" alt="image-20210423160555145"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><img src="/2021/04/23/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/image-20210423162030915.png" alt="image-20210423162030915"></p>
<p><img src="/2021/04/23/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/image-20210423162105868.png" alt="image-20210423162105868"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        ListNode ans = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><ul>
<li>时间复杂度：O(L)<em>O</em>(<em>L</em>)，其中 L<em>L</em> 是链表的长度。</li>
<li>空间复杂度：O(1)<em>O</em>(1)。</li>
</ul>
<h4 id="方法二：计算链表长度"><a href="#方法二：计算链表长度" class="headerlink" title="方法二：计算链表长度"></a>方法二：计算链表长度</h4><p><img src="/2021/04/23/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/image-20210423162320163.png" alt="image-20210423162320163"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a><strong>代码</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        ListNode ans = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><ul>
<li>时间复杂度：O(L)<em>O</em>(<em>L</em>)，其中 L<em>L</em> 是链表的长度。</li>
<li>空间复杂度：O(1)<em>O</em>(1)。</li>
</ul>
<h4 id="方法三：栈"><a href="#方法三：栈" class="headerlink" title="方法三：栈"></a>方法三：栈</h4><p><img src="/2021/04/23/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/image-20210423162642353.png" alt="image-20210423162642353"></p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a><strong>代码</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        stack&lt;ListNode*&gt; stk;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            stk.push(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev = stk.top();</span><br><span class="line">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        delete dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><ul>
<li>时间复杂度：O(L)<em>O</em>(<em>L</em>)，其中 L<em>L</em> 是链表的长度。</li>
<li>空间复杂度：O(L)<em>O</em>(<em>L</em>)，其中 L<em>L</em> 是链表的长度。主要为栈的开销。</li>
</ul>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title>两数相加</title>
    <url>/2021/04/23/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/2021/04/23/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/image-20210423153531123.png" alt="image-20210423153531123"></p>
<h3 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h3><p><img src="/2021/04/23/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/image-20210423160333190.png" alt="image-20210423160333190"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>, tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1 != <span class="keyword">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2 != <span class="keyword">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = n1 + n2 + carry;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = tail = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/23/%E5%8A%9B%E6%89%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/image-20210423160351867.png" alt="image-20210423160351867"></p>
]]></content>
      <categories>
        <category>力扣</category>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title>多线程打包压缩文件</title>
    <url>/2020/08/04/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h2><p>需要下载一个比较大的网络文件，想提高其下载速度。</p>
<h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2.问题分析"></a>2.问题分析</h2><p>可以将一个大的文件拆分为几个小的文件，使用多线程同时下载拆分后的线程片段，下载完成后进行拼接即可。</p>
<h2 id="3-类的设计"><a href="#3-类的设计" class="headerlink" title="3.类的设计"></a>3.类的设计</h2><h3 id="核心类："><a href="#核心类：" class="headerlink" title="核心类："></a>核心类：</h3><h5 id="1-DownloaderTask"><a href="#1-DownloaderTask" class="headerlink" title="1.DownloaderTask"></a>1.DownloaderTask</h5><p>下载任务类，即下载线程的创建。有三种创建方法：继承Thread方法、实现Runnable接口、实现Callable接口，这里选择实现<strong>Callable</strong>接口，可返回下载结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    分块载任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloaderTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下载的起始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下载的结束位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> endPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识当前是哪一部分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> part;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloaderTask</span><span class="params">(String url, <span class="keyword">long</span> startPos, <span class="keyword">long</span> endPos, <span class="keyword">int</span> part, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.startPos = startPos;</span><br><span class="line">        <span class="keyword">this</span>.endPos = endPos;</span><br><span class="line">        <span class="keyword">this</span>.part = part;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        String httpFileName = HttpUtils.getHttpFileName(url);</span><br><span class="line">        <span class="comment">//分块的文件名</span></span><br><span class="line">        httpFileName = httpFileName + <span class="string">&quot;.temp&quot;</span> + part;</span><br><span class="line">        <span class="comment">//下载路径</span></span><br><span class="line">        httpFileName = Constant.PATH + httpFileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取分块下载的连接</span></span><br><span class="line">        HttpURLConnection httpURLConnection = HttpUtils.getHttpURLConnection(url, startPos, endPos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                InputStream input = httpURLConnection.getInputStream();</span><br><span class="line">                BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(input);</span><br><span class="line">                RandomAccessFile accessFile = <span class="keyword">new</span> RandomAccessFile(httpFileName, <span class="string">&quot;rw&quot;</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[Constant.BYTE_SIZE];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//循环读取数据</span></span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//1秒内下载数据之和, 通过原子类进行操作</span></span><br><span class="line">                DownloadInfoThread.downSize.add(len);</span><br><span class="line">                accessFile.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            LogUtils.error(<span class="string">&quot;下载文件不存在&#123;&#125;&quot;</span>, url);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LogUtils.error(<span class="string">&quot;下载出现异常&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            httpURLConnection.disconnect();</span><br><span class="line"></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-Downloader"><a href="#2-Downloader" class="headerlink" title="2.Downloader"></a>2.Downloader</h5><p>下载器类：负责获取文件，创建线程池，拆分文件并创建下载任务、合并文件，清除临时文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//线程池对象</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(Constant.THREAD_NUM, Constant.THREAD_NUM, <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(Constant.THREAD_NUM));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(Constant.THREAD_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        String httpFileName = HttpUtils.getHttpFileName(url);</span><br><span class="line">        <span class="comment">//文件下载路径</span></span><br><span class="line">        httpFileName = Constant.PATH + httpFileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取本地文件的大小</span></span><br><span class="line">        <span class="keyword">long</span> localFileLength = FileUtils.getFileContentLength(httpFileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        HttpURLConnection httpURLConnection = <span class="keyword">null</span>;</span><br><span class="line">        DownloadInfoThread downloadInfoThread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpURLConnection = HttpUtils.getHttpURLConnection(url);</span><br><span class="line">            <span class="comment">//获取下载文件的总大小</span></span><br><span class="line">            <span class="keyword">int</span> contentLength = httpURLConnection.getContentLength();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断文件是否已下载过</span></span><br><span class="line">            <span class="keyword">if</span> (localFileLength &gt;= contentLength) &#123;</span><br><span class="line">                LogUtils.info(<span class="string">&quot;&#123;&#125;已下载完毕，无需重新下载&quot;</span>,httpFileName);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建获取下载信息的任务对象</span></span><br><span class="line">            downloadInfoThread = <span class="keyword">new</span> DownloadInfoThread(contentLength);</span><br><span class="line">            <span class="comment">//将任务交给线程执行，每隔1秒执行一次</span></span><br><span class="line">            scheduledExecutorService.scheduleAtFixedRate(downloadInfoThread,<span class="number">1</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//切分任务</span></span><br><span class="line">            ArrayList&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            spilt(url, list);</span><br><span class="line"></span><br><span class="line">            countDownLatch.await();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//合并文件</span></span><br><span class="line">            <span class="keyword">if</span> (merge(httpFileName)) &#123;</span><br><span class="line">                <span class="comment">//清除临时文件</span></span><br><span class="line">                clearTemp(httpFileName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">            <span class="comment">//关闭连接对象</span></span><br><span class="line">            <span class="keyword">if</span> (httpURLConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                httpURLConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            scheduledExecutorService.shutdownNow();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭线程池</span></span><br><span class="line">            poolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  文件切分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> futureList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spilt</span><span class="params">(String url, ArrayList&lt;Future&gt; futureList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取下载文件大小</span></span><br><span class="line">            <span class="keyword">long</span> contentLength = HttpUtils.getHttpFileContentLength(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算切分后的文件大小</span></span><br><span class="line">            <span class="keyword">long</span> size = contentLength / Constant.THREAD_NUM;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算分块个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Constant.THREAD_NUM; i++) &#123;</span><br><span class="line">                <span class="comment">//计算下载起始位置</span></span><br><span class="line">                <span class="keyword">long</span> startPos = i * size;</span><br><span class="line">                <span class="comment">//计算结束位置</span></span><br><span class="line">                <span class="keyword">long</span> endPos;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == Constant.THREAD_NUM - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//下载最后一块，下载剩余的部分</span></span><br><span class="line">                    endPos = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    endPos = startPos + size;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果不是第一块，起始位置要+1</span></span><br><span class="line">                <span class="keyword">if</span> (startPos != <span class="number">0</span>) &#123;</span><br><span class="line">                    startPos++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//创建任务对象</span></span><br><span class="line">                DownloaderTask downloaderTask = <span class="keyword">new</span> DownloaderTask(url, startPos, endPos,i,countDownLatch);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将任务提交到线程池中</span></span><br><span class="line">                Future&lt;Boolean&gt; future = poolExecutor.submit(downloaderTask);</span><br><span class="line"></span><br><span class="line">                futureList.add(future);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  文件合并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">merge</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        LogUtils.info(<span class="string">&quot;开始合并文件&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[Constant.BYTE_SIZE];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> (RandomAccessFile accessFile = <span class="keyword">new</span> RandomAccessFile(fileName, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Constant.THREAD_NUM ; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span>(BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(fileName + <span class="string">&quot;.temp&quot;</span> + i))) &#123;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        accessFile.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LogUtils.info(<span class="string">&quot;文件合并完毕&#123;&#125;&quot;</span> + fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        清除临时文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clearTemp</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Constant.THREAD_NUM; i++) &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(fileName + <span class="string">&quot;.temp&quot;</span> + i);</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-DownloadInfoThread"><a href="#3-DownloadInfoThread" class="headerlink" title="3.DownloadInfoThread"></a>3.DownloadInfoThread</h5><p><strong>下载信息展示类</strong>：展示下载信息，包括已下载的文件大小，未下载的文件大小和每秒下载速度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadInfoThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下载文件总大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> httpFileContentLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本地已下载文件的大小，</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LongAdder finishedSize = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本次累计下载的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LongAdder downSize = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前一次下载的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> prevSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadInfoThread</span><span class="params">(<span class="keyword">long</span> httpFileContentLength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpFileContentLength = httpFileContentLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算文件总大小 单位：mb</span></span><br><span class="line">        String httpFileSize = String.format(<span class="string">&quot;%.2f&quot;</span>, httpFileContentLength / Constant.MB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算每秒下载速度 kb</span></span><br><span class="line">        <span class="keyword">int</span> speed = (<span class="keyword">int</span>)((downSize.doubleValue() - prevSize) / <span class="number">1024d</span>);</span><br><span class="line">        prevSize = downSize.doubleValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剩余文件的大小</span></span><br><span class="line">        <span class="keyword">double</span> remainSize = httpFileContentLength - finishedSize.doubleValue() - downSize.doubleValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算剩余时间</span></span><br><span class="line">        String remainTime = String.format(<span class="string">&quot;%.1f&quot;</span>, remainSize / <span class="number">1024d</span> / speed);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Infinity&quot;</span>.equalsIgnoreCase(remainTime)) &#123;</span><br><span class="line">            remainTime = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//已下载大小</span></span><br><span class="line">        String currentFileSize = String.format(<span class="string">&quot;%.2f&quot;</span>, (downSize.doubleValue() - finishedSize.doubleValue()) / Constant.MB);</span><br><span class="line"></span><br><span class="line">        String downInfo = String.format(<span class="string">&quot;已下载 %smb/%smb,速度 %skb/s,剩余时间 %ss&quot;</span>,</span><br><span class="line">                currentFileSize, httpFileSize, speed, remainTime);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">        System.out.print(downInfo);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="工具类："><a href="#工具类：" class="headerlink" title="工具类："></a>工具类：</h3><h5 id="1-HttpUtils"><a href="#1-HttpUtils" class="headerlink" title="1.HttpUtils"></a>1.HttpUtils</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    http相关工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取下载文件大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getHttpFileContentLength</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> contentLength;</span><br><span class="line">        HttpURLConnection httpURLConnection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpURLConnection = getHttpURLConnection(url);</span><br><span class="line">            contentLength = httpURLConnection.getContentLength();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (httpURLConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                httpURLConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contentLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  分块下载</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url          下载地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startPos    下载文件起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endPos      下载文件的结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpURLConnection <span class="title">getHttpURLConnection</span><span class="params">(String url, <span class="keyword">long</span> startPos, <span class="keyword">long</span> endPos)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpURLConnection httpURLConnection = getHttpURLConnection(url);</span><br><span class="line">        LogUtils.info(<span class="string">&quot;下载的区间是：&#123;&#125;-&#123;&#125;&quot;</span>,startPos,endPos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (endPos != <span class="number">0</span>) &#123;</span><br><span class="line">            httpURLConnection.setRequestProperty(<span class="string">&quot;RANGE&quot;</span>,<span class="string">&quot;bytes=&quot;</span>+startPos + <span class="string">&quot;-&quot;</span> + endPos);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            httpURLConnection.setRequestProperty(<span class="string">&quot;RANGE&quot;</span>,<span class="string">&quot;bytes=&quot;</span>+startPos + <span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpURLConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取HttpURLConnection链接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url  文件的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpURLConnection <span class="title">getHttpURLConnection</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL httpUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">        HttpURLConnection httpURLConnection = (HttpURLConnection)httpUrl.openConnection();</span><br><span class="line">        <span class="comment">//向文件所在的服务器发送标识信息</span></span><br><span class="line">        httpURLConnection.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>,<span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> httpURLConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取下载文件的名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHttpFileName</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = url.lastIndexOf(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> url.substring(index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2.FileUtils</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本地文件的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getFileContentLength</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> file.exists() &amp;&amp; file.isFile() ? file.length() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3.LogUtils</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  日志工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String msg, Object... args)</span> </span>&#123;</span><br><span class="line">        print(msg,<span class="string">&quot;-info-&quot;</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String msg, Object... args)</span> </span>&#123;</span><br><span class="line">        print(msg,<span class="string">&quot;-error-&quot;</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String msg, String level, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            msg = String.format(msg.replace(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;%s&quot;</span>), args);</span><br><span class="line">        &#125;</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(LocalTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;hh:mm:ss&quot;</span>)) + <span class="string">&quot; &quot;</span> + name + level + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下载地址</span></span><br><span class="line">        String url = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span> || args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                LogUtils.info(<span class="string">&quot;请输入下载地址&quot;</span>);</span><br><span class="line">                Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                url = scanner.next();</span><br><span class="line">                <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            url = args[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Downloader downloader = <span class="keyword">new</span> Downloader();</span><br><span class="line">        downloader.download(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-存在问题"><a href="#4-存在问题" class="headerlink" title="4.存在问题"></a>4.<strong>存在问题</strong></h3><p>不能断点续传，即下载一半后关机，需重新下载。后期再进行优化哦~</p>
]]></content>
      <categories>
        <category>项目实践</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程打包压缩文件</title>
    <url>/2020/08/04/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8C%85%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h2><pre><code> 需要为每个业务对应的报表创建一个excel,多少个业务就有多少个报表，然后将多个excel导出为一个压缩包。
</code></pre>
<h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2.问题分析"></a>2.问题分析</h2><p>每个excel中可能有成千上万条数据，而创建excel和sheet又很耗费时间，那么此时该怎么解决呢？</p>
<p>想到的方法就是使用多线程，为每个excel创建一个任务，生成完所有的excel再进行压缩，为避免开启线程太多，使用线程池和计数器（countdownLatch）。</p>
<h2 id="3-类的设计"><a href="#3-类的设计" class="headerlink" title="3.类的设计"></a>3.类的设计</h2><h3 id="核心类："><a href="#核心类：" class="headerlink" title="核心类："></a>核心类：</h3><h5 id="1-ExcelTask"><a href="#1-ExcelTask" class="headerlink" title="1.ExcelTask"></a>1.ExcelTask</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelTask</span> <span class="keyword">extends</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//这里是所有需要传参的参数</span></span><br><span class="line">        ZipOutputStream zos;</span><br><span class="line">        CountDownLatch count;</span><br><span class="line">        String excelName;</span><br><span class="line">        Object data;</span><br><span class="line">        <span class="comment">/*,其他参数*/</span></span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        <span class="comment">//构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExcelTask</span><span class="params">(ZipOutputStream zos,CountDownLatch count,String excelName,Object data<span class="comment">/*,其他参数*/</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.zos = zos;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">            <span class="keyword">this</span>.excelName = excelName;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ThreadDeal(excelName,zos);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//-1</span></span><br><span class="line">            count.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ThreadDeal</span><span class="params">(String excelName,ZipOutputStream zos,Object data)</span></span>&#123;</span><br><span class="line">       Workbook newWorkbook = WorkbookFactory.create(<span class="keyword">new</span> File(excelName));</span><br><span class="line">       Sheet newsheet=newWorkbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">       ExcelUtils excelUtils=<span class="keyword">new</span> ExcelUtils();</span><br><span class="line">       <span class="comment">//填充数据</span></span><br><span class="line">       excelUtils.setData(newsheet,data);</span><br><span class="line">        <span class="comment">//创建对应数据的方法</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//多线程必须加锁</span></span><br><span class="line">        addLock(excelName,zos,workbook);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addLock</span><span class="params">(String excelName, ZipOutputStream zos, SXSSFWorkbook workbook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ZipEntry zipEntry = <span class="keyword">new</span> ZipEntry(excelName);</span><br><span class="line">            zos.putNextEntry(zipEntry);</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            workbook.write(bos);</span><br><span class="line">            bos.writeTo(zos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-ExcelPakage"><a href="#2-ExcelPakage" class="headerlink" title="2.ExcelPakage"></a>2.ExcelPakage</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExcelPakage</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> 	<span class="keyword">public</span> ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(Constant.THREAD_NUM, Constant.THREAD_NUM, <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(Constant.THREAD_NUM));</span><br><span class="line">   <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(Constant.THREAD_NUM);</span><br><span class="line">   OutputStream out = response.getOutputStream();<span class="comment">//response是HttpServletResponse</span></span><br><span class="line">   <span class="comment">//压缩包的文件名</span></span><br><span class="line">   String filename;</span><br><span class="line">   ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(out);</span><br><span class="line">   <span class="comment">//map中的key为excel的名字，data为excel对应的数据</span></span><br><span class="line">   </span><br><span class="line">   Map&lt;String,Object&gt; data;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">     	<span class="keyword">for</span> (Map.enteySet excelEntry:dataList.entrySet()) &#123;</span><br><span class="line">           String excelName=excelEntry.getKey();</span><br><span class="line">           Object data=excelEntry.getValue();</span><br><span class="line">       	ExcelTask task = <span class="keyword">new</span> ExcelTask(zos,countDownLatch,</span><br><span class="line">                                          excelName,data<span class="comment">/*,其他参数*/</span>);</span><br><span class="line">           poolExecutor.submit(task);<span class="comment">//执行任务</span></span><br><span class="line">           &#125;</span><br><span class="line">           count.await();<span class="comment">//等待所有Excel创建完成</span></span><br><span class="line">           zos.flush();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           executor.shutdown();<span class="comment">//关闭线程池</span></span><br><span class="line">           <span class="comment">//注意顺序</span></span><br><span class="line">           zos.close();</span><br><span class="line">           out.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="工具类："><a href="#工具类：" class="headerlink" title="工具类："></a>工具类：</h3><h5 id="1-ExcelUtils"><a href="#1-ExcelUtils" class="headerlink" title="1.ExcelUtils"></a>1.ExcelUtils</h5><p>操作excel的工具类</p>
<p><strong>2.fileUtils</strong></p>
<p>操作文件的工具类</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>这里只有核心代码哦，提供了一个大概的思路~</p>
]]></content>
      <categories>
        <category>项目实践</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
